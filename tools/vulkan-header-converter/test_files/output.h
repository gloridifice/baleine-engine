enum class AccelerationStructureBuildTypeKHR : u32 {
    HostKhr = VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR,
    DeviceKhr = VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR,
    HostOrDeviceKhr = VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR,
    MaxEnumKhr = VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR
};

enum class AccelerationStructureCompatibilityKHR : u32 {
    CompatibleKhr = VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR,
    IncompatibleKhr = VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR,
    MaxEnumKhr = VK_ACCELERATION_STRUCTURE_COMPATIBILITY_MAX_ENUM_KHR
};

enum class AccelerationStructureCreateFlagsKHR : u32 {
    DeviceAddressCaptureReplayKhr = VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR,
    DescriptorBufferCaptureReplayExt = VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
    MotionNv = VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV,
    FlagsMaxEnumKhr = VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(AccelerationStructureCreateFlagsKHR);

enum class AccelerationStructureMemoryRequirementsTypeNV : u32 {
    ObjectNv = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV,
    BuildScratchNv = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV,
    UpdateScratchNv = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV,
    MaxEnumNv = VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV
};

enum class AccelerationStructureMotionInstanceTypeNV : u32 {
    StaticNv = VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV,
    MatrixMotionNv = VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV,
    SrtMotionNv = VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV,
    MaxEnumNv = VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MAX_ENUM_NV
};

enum class AccelerationStructureTypeKHR : u32 {
    TopLevelKhr = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
    BottomLevelKhr = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
    GenericKhr = VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR,
    MaxEnumKhr = VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_KHR
};

enum class AccessFlags : u32 {
    IndirectCommandRead = VK_ACCESS_INDIRECT_COMMAND_READ_BIT,
    IndexRead = VK_ACCESS_INDEX_READ_BIT,
    VertexAttributeRead = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT,
    UniformRead = VK_ACCESS_UNIFORM_READ_BIT,
    InputAttachmentRead = VK_ACCESS_INPUT_ATTACHMENT_READ_BIT,
    ShaderRead = VK_ACCESS_SHADER_READ_BIT,
    ShaderWrite = VK_ACCESS_SHADER_WRITE_BIT,
    ColorAttachmentRead = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT,
    ColorAttachmentWrite = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
    DepthStencilAttachmentRead = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT,
    DepthStencilAttachmentWrite = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
    TransferRead = VK_ACCESS_TRANSFER_READ_BIT,
    TransferWrite = VK_ACCESS_TRANSFER_WRITE_BIT,
    HostRead = VK_ACCESS_HOST_READ_BIT,
    HostWrite = VK_ACCESS_HOST_WRITE_BIT,
    MemoryRead = VK_ACCESS_MEMORY_READ_BIT,
    MemoryWrite = VK_ACCESS_MEMORY_WRITE_BIT,
    None = VK_ACCESS_NONE,
    TransformFeedbackWriteExt = VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT,
    TransformFeedbackCounterReadExt = VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT,
    TransformFeedbackCounterWriteExt = VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT,
    ConditionalRenderingReadExt = VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT,
    ColorAttachmentReadNoncoherentExt = VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT,
    AccelerationStructureReadKhr = VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR,
    AccelerationStructureWriteKhr = VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR,
    FragmentDensityMapReadExt = VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT,
    FragmentShadingRateAttachmentReadKhr = VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR,
    CommandPreprocessReadExt = VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT,
    CommandPreprocessWriteExt = VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT,
    FlagsMaxEnum = VK_ACCESS_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(AccessFlags);

enum class AcquireProfilingLockFlagsKHR : u32 {
    VkAcquireProfilingLockFlagsMaxEnumKhr = VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(AcquireProfilingLockFlagsKHR);

enum class AntiLagModeAMD : u32 {
    DriverControlAmd = VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD,
    OnAmd = VK_ANTI_LAG_MODE_ON_AMD,
    OffAmd = VK_ANTI_LAG_MODE_OFF_AMD,
    MaxEnumAmd = VK_ANTI_LAG_MODE_MAX_ENUM_AMD
};

enum class AntiLagStageAMD : u32 {
    InputAmd = VK_ANTI_LAG_STAGE_INPUT_AMD,
    PresentAmd = VK_ANTI_LAG_STAGE_PRESENT_AMD,
    MaxEnumAmd = VK_ANTI_LAG_STAGE_MAX_ENUM_AMD
};

enum class AttachmentDescriptionFlags : u32 {
    MayAlias = VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT,
    FlagsMaxEnum = VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(AttachmentDescriptionFlags);

enum class AttachmentLoadOp : u32 {
    Load = VK_ATTACHMENT_LOAD_OP_LOAD,
    Clear = VK_ATTACHMENT_LOAD_OP_CLEAR,
    DontCare = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    None = VK_ATTACHMENT_LOAD_OP_NONE,
    MaxEnum = VK_ATTACHMENT_LOAD_OP_MAX_ENUM
};

enum class AttachmentStoreOp : u32 {
    Store = VK_ATTACHMENT_STORE_OP_STORE,
    DontCare = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    None = VK_ATTACHMENT_STORE_OP_NONE,
    MaxEnum = VK_ATTACHMENT_STORE_OP_MAX_ENUM
};

enum class BlendFactor : u32 {
    Zero = VK_BLEND_FACTOR_ZERO,
    One = VK_BLEND_FACTOR_ONE,
    SrcColor = VK_BLEND_FACTOR_SRC_COLOR,
    OneMinusSrcColor = VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR,
    DstColor = VK_BLEND_FACTOR_DST_COLOR,
    OneMinusDstColor = VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR,
    SrcAlpha = VK_BLEND_FACTOR_SRC_ALPHA,
    OneMinusSrcAlpha = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA,
    DstAlpha = VK_BLEND_FACTOR_DST_ALPHA,
    OneMinusDstAlpha = VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA,
    ConstantColor = VK_BLEND_FACTOR_CONSTANT_COLOR,
    OneMinusConstantColor = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR,
    ConstantAlpha = VK_BLEND_FACTOR_CONSTANT_ALPHA,
    OneMinusConstantAlpha = VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA,
    SrcAlphaSaturate = VK_BLEND_FACTOR_SRC_ALPHA_SATURATE,
    Src1Color = VK_BLEND_FACTOR_SRC1_COLOR,
    OneMinusSrc1Color = VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR,
    Src1Alpha = VK_BLEND_FACTOR_SRC1_ALPHA,
    OneMinusSrc1Alpha = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    MaxEnum = VK_BLEND_FACTOR_MAX_ENUM
};

enum class BlendOp : u32 {
    Add = VK_BLEND_OP_ADD,
    Subtract = VK_BLEND_OP_SUBTRACT,
    ReverseSubtract = VK_BLEND_OP_REVERSE_SUBTRACT,
    Min = VK_BLEND_OP_MIN,
    Max = VK_BLEND_OP_MAX,
    ZeroExt = VK_BLEND_OP_ZERO_EXT,
    SrcExt = VK_BLEND_OP_SRC_EXT,
    DstExt = VK_BLEND_OP_DST_EXT,
    SrcOverExt = VK_BLEND_OP_SRC_OVER_EXT,
    DstOverExt = VK_BLEND_OP_DST_OVER_EXT,
    SrcInExt = VK_BLEND_OP_SRC_IN_EXT,
    DstInExt = VK_BLEND_OP_DST_IN_EXT,
    SrcOutExt = VK_BLEND_OP_SRC_OUT_EXT,
    DstOutExt = VK_BLEND_OP_DST_OUT_EXT,
    SrcAtopExt = VK_BLEND_OP_SRC_ATOP_EXT,
    DstAtopExt = VK_BLEND_OP_DST_ATOP_EXT,
    XorExt = VK_BLEND_OP_XOR_EXT,
    MultiplyExt = VK_BLEND_OP_MULTIPLY_EXT,
    ScreenExt = VK_BLEND_OP_SCREEN_EXT,
    OverlayExt = VK_BLEND_OP_OVERLAY_EXT,
    DarkenExt = VK_BLEND_OP_DARKEN_EXT,
    LightenExt = VK_BLEND_OP_LIGHTEN_EXT,
    ColordodgeExt = VK_BLEND_OP_COLORDODGE_EXT,
    ColorburnExt = VK_BLEND_OP_COLORBURN_EXT,
    HardlightExt = VK_BLEND_OP_HARDLIGHT_EXT,
    SoftlightExt = VK_BLEND_OP_SOFTLIGHT_EXT,
    DifferenceExt = VK_BLEND_OP_DIFFERENCE_EXT,
    ExclusionExt = VK_BLEND_OP_EXCLUSION_EXT,
    InvertExt = VK_BLEND_OP_INVERT_EXT,
    InvertRgbExt = VK_BLEND_OP_INVERT_RGB_EXT,
    LineardodgeExt = VK_BLEND_OP_LINEARDODGE_EXT,
    LinearburnExt = VK_BLEND_OP_LINEARBURN_EXT,
    VividlightExt = VK_BLEND_OP_VIVIDLIGHT_EXT,
    LinearlightExt = VK_BLEND_OP_LINEARLIGHT_EXT,
    PinlightExt = VK_BLEND_OP_PINLIGHT_EXT,
    HardmixExt = VK_BLEND_OP_HARDMIX_EXT,
    HslHueExt = VK_BLEND_OP_HSL_HUE_EXT,
    HslSaturationExt = VK_BLEND_OP_HSL_SATURATION_EXT,
    HslColorExt = VK_BLEND_OP_HSL_COLOR_EXT,
    HslLuminosityExt = VK_BLEND_OP_HSL_LUMINOSITY_EXT,
    PlusExt = VK_BLEND_OP_PLUS_EXT,
    PlusClampedExt = VK_BLEND_OP_PLUS_CLAMPED_EXT,
    PlusClampedAlphaExt = VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT,
    PlusDarkerExt = VK_BLEND_OP_PLUS_DARKER_EXT,
    MinusExt = VK_BLEND_OP_MINUS_EXT,
    MinusClampedExt = VK_BLEND_OP_MINUS_CLAMPED_EXT,
    ContrastExt = VK_BLEND_OP_CONTRAST_EXT,
    InvertOvgExt = VK_BLEND_OP_INVERT_OVG_EXT,
    RedExt = VK_BLEND_OP_RED_EXT,
    GreenExt = VK_BLEND_OP_GREEN_EXT,
    BlueExt = VK_BLEND_OP_BLUE_EXT,
    MaxEnum = VK_BLEND_OP_MAX_ENUM
};

enum class BlendOverlapEXT : u32 {
    UncorrelatedExt = VK_BLEND_OVERLAP_UNCORRELATED_EXT,
    DisjointExt = VK_BLEND_OVERLAP_DISJOINT_EXT,
    ConjointExt = VK_BLEND_OVERLAP_CONJOINT_EXT,
    MaxEnumExt = VK_BLEND_OVERLAP_MAX_ENUM_EXT
};

enum class BlockMatchWindowCompareModeQCOM : u32 {
    InQcom = VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM,
    AxQcom = VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM,
    AxEnumQcom = VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_ENUM_QCOM
};

enum class BorderColor : u32 {
    FloatTransparentBlack = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    IntTransparentBlack = VK_BORDER_COLOR_INT_TRANSPARENT_BLACK,
    FloatOpaqueBlack = VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK,
    IntOpaqueBlack = VK_BORDER_COLOR_INT_OPAQUE_BLACK,
    FloatOpaqueWhite = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
    IntOpaqueWhite = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    FloatCustomExt = VK_BORDER_COLOR_FLOAT_CUSTOM_EXT,
    IntCustomExt = VK_BORDER_COLOR_INT_CUSTOM_EXT,
    MaxEnum = VK_BORDER_COLOR_MAX_ENUM
};

enum class BufferCreateFlags : u32 {
    SparseBinding = VK_BUFFER_CREATE_SPARSE_BINDING_BIT,
    SparseResidency = VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT,
    SparseAliased = VK_BUFFER_CREATE_SPARSE_ALIASED_BIT,
    Protected = VK_BUFFER_CREATE_PROTECTED_BIT,
    DeviceAddressCaptureReplay = VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
    DescriptorBufferCaptureReplayExt = VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
    VideoProfileIndependentKhr = VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR,
    FlagsMaxEnum = VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(BufferCreateFlags);

enum class BufferUsageFlags : u32 {
    TransferSrc = VK_BUFFER_USAGE_TRANSFER_SRC_BIT,
    TransferDst = VK_BUFFER_USAGE_TRANSFER_DST_BIT,
    UniformTexelBuffer = VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT,
    StorageTexelBuffer = VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT,
    UniformBuffer = VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT,
    StorageBuffer = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT,
    IndexBuffer = VK_BUFFER_USAGE_INDEX_BUFFER_BIT,
    VertexBuffer = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT,
    IndirectBuffer = VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT,
    ShaderDeviceAddress = VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT,
    VideoDecodeSrcKhr = VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR,
    VideoDecodeDstKhr = VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR,
    TransformFeedbackBufferExt = VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT,
    TransformFeedbackCounterBufferExt = VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT,
    ConditionalRenderingExt = VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT,
    AccelerationStructureBuildInputReadOnlyKhr = VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR,
    AccelerationStructureStorageKhr = VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR,
    ShaderBindingTableKhr = VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR,
    VideoEncodeDstKhr = VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR,
    VideoEncodeSrcKhr = VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR,
    SamplerDescriptorBufferExt = VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT,
    ResourceDescriptorBufferExt = VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT,
    PushDescriptorsDescriptorBufferExt = VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT,
    MicromapBuildInputReadOnlyExt = VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT,
    MicromapStorageExt = VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT,
    TileMemoryQcom = VK_BUFFER_USAGE_TILE_MEMORY_QCOM,
    FlagsMaxEnum = VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(BufferUsageFlags);

enum class BuildAccelerationStructureFlagsKHR : u32 {
    AllowUpdateKhr = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR,
    AllowCompactionKhr = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR,
    PreferFastTraceKhr = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
    PreferFastBuildKhr = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR,
    LowMemoryKhr = VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR,
    MotionNv = VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV,
    AllowOpacityMicromapUpdateExt = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT,
    AllowDisableOpacityMicromapsExt = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT,
    AllowOpacityMicromapDataUpdateExt = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT,
    AllowDataAccessKhr = VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR,
    FlagsMaxEnumKhr = VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(BuildAccelerationStructureFlagsKHR);

enum class BuildAccelerationStructureModeKHR : u32 {
    BuildKhr = VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR,
    UpdateKhr = VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR,
    MaxEnumKhr = VK_BUILD_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR
};

enum class BuildMicromapFlagsEXT : u32 {
    PreferFastTraceExt = VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT,
    PreferFastBuildExt = VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT,
    AllowCompactionExt = VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT,
    FlagsMaxEnumExt = VK_BUILD_MICROMAP_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(BuildMicromapFlagsEXT);

enum class BuildMicromapModeEXT : u32 {
    BuildExt = VK_BUILD_MICROMAP_MODE_BUILD_EXT,
    MaxEnumExt = VK_BUILD_MICROMAP_MODE_MAX_ENUM_EXT
};

enum class ChromaLocation : u32 {
    CositedEven = VK_CHROMA_LOCATION_COSITED_EVEN,
    Midpoint = VK_CHROMA_LOCATION_MIDPOINT,
    MaxEnum = VK_CHROMA_LOCATION_MAX_ENUM
};

enum class ClusterAccelerationStructureAddressResolutionFlagsNV : u32 {
    IndirectedDstImplicitDataNv = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV,
    IndirectedScratchDataNv = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV,
    IndirectedDstAddressArrayNv = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV,
    IndirectedDstSizesArrayNv = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV,
    IndirectedSrcInfosArrayNv = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV,
    IndirectedSrcInfosCountNv = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV,
    FlagsMaxEnumNv = VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(ClusterAccelerationStructureAddressResolutionFlagsNV);

enum class ClusterAccelerationStructureClusterFlagsNV : u32 {
    AllowDisableOpacityMicromapsNv = VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV,
    FlagsMaxEnumNv = VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(ClusterAccelerationStructureClusterFlagsNV);

enum class ClusterAccelerationStructureGeometryFlagsNV : u32 {
    CullDisableNv = VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV,
    NoDuplicateAnyhitInvocationNv = VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV,
    OpaqueNv = VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV,
    FlagsMaxEnumNv = VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(ClusterAccelerationStructureGeometryFlagsNV);

enum class ClusterAccelerationStructureIndexFormatFlagsNV : u32 {
    8bitNv = VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV,
    16bitNv = VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV,
    32bitNv = VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV,
    FlagsMaxEnumNv = VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(ClusterAccelerationStructureIndexFormatFlagsNV);

enum class ClusterAccelerationStructureOpModeNV : u32 {
    ImplicitDestinationsNv = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV,
    ExplicitDestinationsNv = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV,
    ComputeSizesNv = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV,
    MaxEnumNv = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_MAX_ENUM_NV
};

enum class ClusterAccelerationStructureOpTypeNV : u32 {
    MoveObjectsNv = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV,
    BuildClustersBottomLevelNv = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV,
    BuildTriangleClusterNv = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV,
    BuildTriangleClusterTemplateNv = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV,
    InstantiateTriangleClusterNv = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV,
    MaxEnumNv = VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MAX_ENUM_NV
};

enum class ClusterAccelerationStructureTypeNV : u32 {
    ClustersBottomLevelNv = VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV,
    TriangleClusterNv = VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV,
    TriangleClusterTemplateNv = VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV,
    MaxEnumNv = VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV
};

enum class CoarseSampleOrderTypeNV : u32 {
    DefaultNv = VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV,
    CustomNv = VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV,
    PixelMajorNv = VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV,
    SampleMajorNv = VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV,
    MaxEnumNv = VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV
};

enum class ColorComponentFlags : u32 {
    R = VK_COLOR_COMPONENT_R_BIT,
    G = VK_COLOR_COMPONENT_G_BIT,
    B = VK_COLOR_COMPONENT_B_BIT,
    A = VK_COLOR_COMPONENT_A_BIT,
    FlagsMaxEnum = VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ColorComponentFlags);

enum class ColorSpaceKHR : u32 {
    SrgbNonlinearKhr = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    DisplayP3NonlinearExt = VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT,
    ExtendedSrgbLinearExt = VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT,
    DisplayP3LinearExt = VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT,
    DciP3NonlinearExt = VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT,
    Bt709LinearExt = VK_COLOR_SPACE_BT709_LINEAR_EXT,
    Bt709NonlinearExt = VK_COLOR_SPACE_BT709_NONLINEAR_EXT,
    Bt2020LinearExt = VK_COLOR_SPACE_BT2020_LINEAR_EXT,
    Hdr10St2084Ext = VK_COLOR_SPACE_HDR10_ST2084_EXT,
    DolbyvisionExt = VK_COLOR_SPACE_DOLBYVISION_EXT,
    Hdr10HlgExt = VK_COLOR_SPACE_HDR10_HLG_EXT,
    AdobergbLinearExt = VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT,
    AdobergbNonlinearExt = VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT,
    PassThroughExt = VK_COLOR_SPACE_PASS_THROUGH_EXT,
    ExtendedSrgbNonlinearExt = VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT,
    DisplayNativeAmd = VK_COLOR_SPACE_DISPLAY_NATIVE_AMD,
    MaxEnumKhr = VK_COLOR_SPACE_MAX_ENUM_KHR
};

enum class CommandBufferLevel : u32 {
    Primary = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    Secondary = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    MaxEnum = VK_COMMAND_BUFFER_LEVEL_MAX_ENUM
};

enum class CommandBufferResetFlags : u32 {
    ReleaseResources = VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT,
    FlagsMaxEnum = VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(CommandBufferResetFlags);

enum class CommandBufferUsageFlags : u32 {
    OneTimeSubmit = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
    RenderPassContinue = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT,
    SimultaneousUse = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT,
    FlagsMaxEnum = VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(CommandBufferUsageFlags);

enum class CommandPoolCreateFlags : u32 {
    Transient = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT,
    ResetCommandBuffer = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT,
    Protected = VK_COMMAND_POOL_CREATE_PROTECTED_BIT,
    FlagsMaxEnum = VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(CommandPoolCreateFlags);

enum class CommandPoolResetFlags : u32 {
    ReleaseResources = VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT,
    FlagsMaxEnum = VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(CommandPoolResetFlags);

enum class CompareOp : u32 {
    Never = VK_COMPARE_OP_NEVER,
    Less = VK_COMPARE_OP_LESS,
    Equal = VK_COMPARE_OP_EQUAL,
    LessOrEqual = VK_COMPARE_OP_LESS_OR_EQUAL,
    Greater = VK_COMPARE_OP_GREATER,
    NotEqual = VK_COMPARE_OP_NOT_EQUAL,
    GreaterOrEqual = VK_COMPARE_OP_GREATER_OR_EQUAL,
    Always = VK_COMPARE_OP_ALWAYS,
    MaxEnum = VK_COMPARE_OP_MAX_ENUM
};

enum class ComponentSwizzle : u32 {
    Identity = VK_COMPONENT_SWIZZLE_IDENTITY,
    Zero = VK_COMPONENT_SWIZZLE_ZERO,
    One = VK_COMPONENT_SWIZZLE_ONE,
    R = VK_COMPONENT_SWIZZLE_R,
    G = VK_COMPONENT_SWIZZLE_G,
    B = VK_COMPONENT_SWIZZLE_B,
    A = VK_COMPONENT_SWIZZLE_A,
    MaxEnum = VK_COMPONENT_SWIZZLE_MAX_ENUM
};

enum class ComponentTypeKHR : u32 {
    Float16Khr = VK_COMPONENT_TYPE_FLOAT16_KHR,
    Float32Khr = VK_COMPONENT_TYPE_FLOAT32_KHR,
    Float64Khr = VK_COMPONENT_TYPE_FLOAT64_KHR,
    Sint8Khr = VK_COMPONENT_TYPE_SINT8_KHR,
    Sint16Khr = VK_COMPONENT_TYPE_SINT16_KHR,
    Sint32Khr = VK_COMPONENT_TYPE_SINT32_KHR,
    Sint64Khr = VK_COMPONENT_TYPE_SINT64_KHR,
    Uint8Khr = VK_COMPONENT_TYPE_UINT8_KHR,
    Uint16Khr = VK_COMPONENT_TYPE_UINT16_KHR,
    Uint32Khr = VK_COMPONENT_TYPE_UINT32_KHR,
    Uint64Khr = VK_COMPONENT_TYPE_UINT64_KHR,
    Bfloat16Khr = VK_COMPONENT_TYPE_BFLOAT16_KHR,
    Sint8PackedNv = VK_COMPONENT_TYPE_SINT8_PACKED_NV,
    Uint8PackedNv = VK_COMPONENT_TYPE_UINT8_PACKED_NV,
    FloatE4m3Nv = VK_COMPONENT_TYPE_FLOAT_E4M3_NV,
    FloatE5m2Nv = VK_COMPONENT_TYPE_FLOAT_E5M2_NV,
    MaxEnumKhr = VK_COMPONENT_TYPE_MAX_ENUM_KHR
};

enum class CompositeAlphaFlagsKHR : u32 {
    OpaqueKhr = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
    PreMultipliedKhr = VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
    PostMultipliedKhr = VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
    InheritKhr = VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR,
    FlagsMaxEnumKhr = VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(CompositeAlphaFlagsKHR);

enum class ConditionalRenderingFlagsEXT : u32 {
    InvertedExt = VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT,
    FlagsMaxEnumExt = VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(ConditionalRenderingFlagsEXT);

enum class ConservativeRasterizationModeEXT : u32 {
    DisabledExt = VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT,
    OverestimateExt = VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT,
    UnderestimateExt = VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT,
    MaxEnumExt = VK_CONSERVATIVE_RASTERIZATION_MODE_MAX_ENUM_EXT
};

enum class CooperativeVectorMatrixLayoutNV : u32 {
    RowMajorNv = VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV,
    ColumnMajorNv = VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV,
    InferencingOptimalNv = VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV,
    TrainingOptimalNv = VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV,
    MaxEnumNv = VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_MAX_ENUM_NV
};

enum class CopyAccelerationStructureModeKHR : u32 {
    CloneKhr = VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR,
    CompactKhr = VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR,
    SerializeKhr = VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR,
    DeserializeKhr = VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR,
    MaxEnumKhr = VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_KHR
};

enum class CopyMicromapModeEXT : u32 {
    CloneExt = VK_COPY_MICROMAP_MODE_CLONE_EXT,
    SerializeExt = VK_COPY_MICROMAP_MODE_SERIALIZE_EXT,
    DeserializeExt = VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT,
    CompactExt = VK_COPY_MICROMAP_MODE_COMPACT_EXT,
    MaxEnumExt = VK_COPY_MICROMAP_MODE_MAX_ENUM_EXT
};

enum class CoverageModulationModeNV : u32 {
    NoneNv = VK_COVERAGE_MODULATION_MODE_NONE_NV,
    RgbNv = VK_COVERAGE_MODULATION_MODE_RGB_NV,
    AlphaNv = VK_COVERAGE_MODULATION_MODE_ALPHA_NV,
    RgbaNv = VK_COVERAGE_MODULATION_MODE_RGBA_NV,
    MaxEnumNv = VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV
};

enum class CoverageReductionModeNV : u32 {
    MergeNv = VK_COVERAGE_REDUCTION_MODE_MERGE_NV,
    TruncateNv = VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV,
    MaxEnumNv = VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV
};

enum class CubicFilterWeightsQCOM : u32 {
    CatmullRomQcom = VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM,
    ZeroTangentCardinalQcom = VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM,
    BSplineQcom = VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM,
    MitchellNetravaliQcom = VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM,
    MaxEnumQcom = VK_CUBIC_FILTER_WEIGHTS_MAX_ENUM_QCOM
};

enum class CullModeFlags : u32 {
    None = VK_CULL_MODE_NONE,
    Front = VK_CULL_MODE_FRONT_BIT,
    Back = VK_CULL_MODE_BACK_BIT,
    FrontAndBack = VK_CULL_MODE_FRONT_AND_BACK,
    FlagsMaxEnum = VK_CULL_MODE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(CullModeFlags);

enum class DebugReportFlagsEXT : u32 {
    InformationExt = VK_DEBUG_REPORT_INFORMATION_BIT_EXT,
    WarningExt = VK_DEBUG_REPORT_WARNING_BIT_EXT,
    PerformanceWarningExt = VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT,
    ErrorExt = VK_DEBUG_REPORT_ERROR_BIT_EXT,
    DebugExt = VK_DEBUG_REPORT_DEBUG_BIT_EXT,
    FlagsMaxEnumExt = VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(DebugReportFlagsEXT);

enum class DebugReportObjectTypeEXT : u32 {
    UnknownExt = VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT,
    InstanceExt = VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
    PhysicalDeviceExt = VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT,
    DeviceExt = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT,
    QueueExt = VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT,
    SemaphoreExt = VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT,
    CommandBufferExt = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT,
    FenceExt = VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT,
    DeviceMemoryExt = VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT,
    BufferExt = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT,
    ImageExt = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
    EventExt = VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT,
    QueryPoolExt = VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT,
    BufferViewExt = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT,
    ImageViewExt = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT,
    ShaderModuleExt = VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT,
    PipelineCacheExt = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT,
    PipelineLayoutExt = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT,
    RenderPassExt = VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT,
    PipelineExt = VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT,
    DescriptorSetLayoutExt = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT,
    SamplerExt = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT,
    DescriptorPoolExt = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT,
    DescriptorSetExt = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT,
    FramebufferExt = VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT,
    CommandPoolExt = VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT,
    SurfaceKhrExt = VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT,
    SwapchainKhrExt = VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT,
    DebugReportCallbackExtExt = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
    DisplayKhrExt = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT,
    DisplayModeKhrExt = VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT,
    ValidationCacheExtExt = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
    SamplerYcbcrConversionExt = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
    DescriptorUpdateTemplateExt = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
    CuModuleNvxExt = VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT,
    CuFunctionNvxExt = VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT,
    AccelerationStructureKhrExt = VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT,
    AccelerationStructureNvExt = VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT,
    CudaModuleNvExt = VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT,
    CudaFunctionNvExt = VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT,
    BufferCollectionFuchsiaExt = VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT,
    MaxEnumExt = VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT
};

enum class DebugUtilsMessageSeverityFlagsEXT : u32 {
    VerboseExt = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT,
    InfoExt = VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT,
    WarningExt = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
    ErrorExt = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
    FlagsMaxEnumExt = VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(DebugUtilsMessageSeverityFlagsEXT);

enum class DebugUtilsMessageTypeFlagsEXT : u32 {
    GeneralExt = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
    ValidationExt = VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
    PerformanceExt = VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
    DeviceAddressBindingExt = VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT,
    FlagsMaxEnumExt = VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(DebugUtilsMessageTypeFlagsEXT);

enum class DependencyFlags : u32 {
    ByRegion = VK_DEPENDENCY_BY_REGION_BIT,
    DeviceGroup = VK_DEPENDENCY_DEVICE_GROUP_BIT,
    ViewLocal = VK_DEPENDENCY_VIEW_LOCAL_BIT,
    FeedbackLoopExt = VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT,
    QueueFamilyOwnershipTransferUseAllStagesKhr = VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR,
    FlagsMaxEnum = VK_DEPENDENCY_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(DependencyFlags);

enum class DepthBiasRepresentationEXT : u32 {
    LeastRepresentableValueFormatExt = VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT,
    LeastRepresentableValueForceUnormExt = VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT,
    FloatExt = VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT,
    MaxEnumExt = VK_DEPTH_BIAS_REPRESENTATION_MAX_ENUM_EXT
};

enum class DepthClampModeEXT : u32 {
    ViewportRangeExt = VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT,
    UserDefinedRangeExt = VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT,
    MaxEnumExt = VK_DEPTH_CLAMP_MODE_MAX_ENUM_EXT
};

enum class DescriptorBindingFlags : u32 {
    UpdateAfterBind = VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT,
    UpdateUnusedWhilePending = VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT,
    PartiallyBound = VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT,
    VariableDescriptorCount = VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT,
    FlagsMaxEnum = VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(DescriptorBindingFlags);

enum class DescriptorPoolCreateFlags : u32 {
    FreeDescriptorSet = VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT,
    UpdateAfterBind = VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT,
    HostOnlyExt = VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT,
    AllowOverallocationSetsNv = VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV,
    AllowOverallocationPoolsNv = VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV,
    FlagsMaxEnum = VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(DescriptorPoolCreateFlags);

enum class DescriptorSetLayoutCreateFlags : u32 {
    UpdateAfterBindPool = VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT,
    PushDescriptor = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT,
    DescriptorBufferExt = VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT,
    EmbeddedImmutableSamplersExt = VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT,
    IndirectBindableNv = VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV,
    HostOnlyPoolExt = VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT,
    PerStageNv = VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV,
    FlagsMaxEnum = VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(DescriptorSetLayoutCreateFlags);

enum class DescriptorType : u32 {
    Sampler = VK_DESCRIPTOR_TYPE_SAMPLER,
    CombinedImageSampler = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,
    SampledImage = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
    StorageImage = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
    UniformTexelBuffer = VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
    StorageTexelBuffer = VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
    UniformBuffer = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
    StorageBuffer = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER,
    UniformBufferDynamic = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC,
    StorageBufferDynamic = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC,
    InputAttachment = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    InlineUniformBlock = VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK,
    AccelerationStructureKhr = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR,
    AccelerationStructureNv = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV,
    SampleWeightImageQcom = VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM,
    BlockMatchImageQcom = VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM,
    MutableExt = VK_DESCRIPTOR_TYPE_MUTABLE_EXT,
    PartitionedAccelerationStructureNv = VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV,
    MaxEnum = VK_DESCRIPTOR_TYPE_MAX_ENUM
};

enum class DescriptorUpdateTemplateType : u32 {
    DescriptorSet = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET,
    PushDescriptors = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS,
    MaxEnum = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM
};

enum class DeviceAddressBindingFlagsEXT : u32 {
    InternalObjectExt = VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT,
    FlagsMaxEnumExt = VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(DeviceAddressBindingFlagsEXT);

enum class DeviceAddressBindingTypeEXT : u32 {
    BindExt = VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT,
    UnbindExt = VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT,
    MaxEnumExt = VK_DEVICE_ADDRESS_BINDING_TYPE_MAX_ENUM_EXT
};

enum class DeviceDiagnosticsConfigFlagsNV : u32 {
    EnableShaderDebugInfoNv = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV,
    EnableResourceTrackingNv = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV,
    EnableAutomaticCheckpointsNv = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV,
    EnableShaderErrorReportingNv = VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV,
    FlagsMaxEnumNv = VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(DeviceDiagnosticsConfigFlagsNV);

enum class DeviceEventTypeEXT : u32 {
    DisplayHotplugExt = VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT,
    MaxEnumExt = VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT
};

enum class DeviceFaultAddressTypeEXT : u32 {
    NoneExt = VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT,
    ReadInvalidExt = VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT,
    WriteInvalidExt = VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT,
    ExecuteInvalidExt = VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT,
    InstructionPointerUnknownExt = VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT,
    InstructionPointerInvalidExt = VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT,
    InstructionPointerFaultExt = VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT,
    MaxEnumExt = VK_DEVICE_FAULT_ADDRESS_TYPE_MAX_ENUM_EXT
};

enum class DeviceFaultVendorBinaryHeaderVersionEXT : u32 {
    OneExt = VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT,
    MaxEnumExt = VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_MAX_ENUM_EXT
};

enum class DeviceGroupPresentModeFlagsKHR : u32 {
    LocalKhr = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR,
    RemoteKhr = VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR,
    SumKhr = VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR,
    LocalMultiDeviceKhr = VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR,
    FlagsMaxEnumKhr = VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(DeviceGroupPresentModeFlagsKHR);

enum class DeviceMemoryReportEventTypeEXT : u32 {
    AllocateExt = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT,
    FreeExt = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT,
    ImportExt = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT,
    UnimportExt = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT,
    AllocationFailedExt = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT,
    MaxEnumExt = VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_MAX_ENUM_EXT
};

enum class DeviceQueueCreateFlags : u32 {
    Protected = VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT,
    FlagsMaxEnum = VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(DeviceQueueCreateFlags);

enum class DirectDriverLoadingModeLUNARG : u32 {
    ExclusiveLunarg = VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG,
    InclusiveLunarg = VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG,
    MaxEnumLunarg = VK_DIRECT_DRIVER_LOADING_MODE_MAX_ENUM_LUNARG
};

enum class DiscardRectangleModeEXT : u32 {
    InclusiveExt = VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT,
    ExclusiveExt = VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT,
    MaxEnumExt = VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT
};

enum class DisplayEventTypeEXT : u32 {
    FirstPixelOutExt = VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT,
    MaxEnumExt = VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT
};

enum class DisplayPlaneAlphaFlagsKHR : u32 {
    OpaqueKhr = VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR,
    GlobalKhr = VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR,
    PerPixelKhr = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR,
    PerPixelPremultipliedKhr = VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR,
    FlagsMaxEnumKhr = VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(DisplayPlaneAlphaFlagsKHR);

enum class DisplayPowerStateEXT : u32 {
    OffExt = VK_DISPLAY_POWER_STATE_OFF_EXT,
    SuspendExt = VK_DISPLAY_POWER_STATE_SUSPEND_EXT,
    OnExt = VK_DISPLAY_POWER_STATE_ON_EXT,
    MaxEnumExt = VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT
};

enum class DisplaySurfaceStereoTypeNV : u32 {
    NoneNv = VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV,
    OnboardDinNv = VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV,
    Hdmi3dNv = VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV,
    InbandDisplayportNv = VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV,
    MaxEnumNv = VK_DISPLAY_SURFACE_STEREO_TYPE_MAX_ENUM_NV
};

enum class DriverId : u32 {
    AmdProprietary = VK_DRIVER_ID_AMD_PROPRIETARY,
    AmdOpenSource = VK_DRIVER_ID_AMD_OPEN_SOURCE,
    MesaRadv = VK_DRIVER_ID_MESA_RADV,
    NvidiaProprietary = VK_DRIVER_ID_NVIDIA_PROPRIETARY,
    IntelProprietaryWindows = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS,
    IntelOpenSourceMesa = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA,
    ImaginationProprietary = VK_DRIVER_ID_IMAGINATION_PROPRIETARY,
    QualcommProprietary = VK_DRIVER_ID_QUALCOMM_PROPRIETARY,
    ArmProprietary = VK_DRIVER_ID_ARM_PROPRIETARY,
    GoogleSwiftshader = VK_DRIVER_ID_GOOGLE_SWIFTSHADER,
    GgpProprietary = VK_DRIVER_ID_GGP_PROPRIETARY,
    BroadcomProprietary = VK_DRIVER_ID_BROADCOM_PROPRIETARY,
    MesaLlvmpipe = VK_DRIVER_ID_MESA_LLVMPIPE,
    Moltenvk = VK_DRIVER_ID_MOLTENVK,
    CoreaviProprietary = VK_DRIVER_ID_COREAVI_PROPRIETARY,
    JuiceProprietary = VK_DRIVER_ID_JUICE_PROPRIETARY,
    VerisiliconProprietary = VK_DRIVER_ID_VERISILICON_PROPRIETARY,
    MesaTurnip = VK_DRIVER_ID_MESA_TURNIP,
    MesaV3dv = VK_DRIVER_ID_MESA_V3DV,
    MesaPanvk = VK_DRIVER_ID_MESA_PANVK,
    SamsungProprietary = VK_DRIVER_ID_SAMSUNG_PROPRIETARY,
    MesaVenus = VK_DRIVER_ID_MESA_VENUS,
    MesaDozen = VK_DRIVER_ID_MESA_DOZEN,
    MesaNvk = VK_DRIVER_ID_MESA_NVK,
    ImaginationOpenSourceMesa = VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA,
    MesaHoneykrisp = VK_DRIVER_ID_MESA_HONEYKRISP,
    VulkanScEmulationOnVulkan = VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN,
    MaxEnum = VK_DRIVER_ID_MAX_ENUM
};

enum class DynamicState : u32 {
    Viewport = VK_DYNAMIC_STATE_VIEWPORT,
    Scissor = VK_DYNAMIC_STATE_SCISSOR,
    LineWidth = VK_DYNAMIC_STATE_LINE_WIDTH,
    DepthBias = VK_DYNAMIC_STATE_DEPTH_BIAS,
    BlendConstants = VK_DYNAMIC_STATE_BLEND_CONSTANTS,
    DepthBounds = VK_DYNAMIC_STATE_DEPTH_BOUNDS,
    StencilCompareMask = VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK,
    StencilWriteMask = VK_DYNAMIC_STATE_STENCIL_WRITE_MASK,
    StencilReference = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    CullMode = VK_DYNAMIC_STATE_CULL_MODE,
    FrontFace = VK_DYNAMIC_STATE_FRONT_FACE,
    PrimitiveTopology = VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY,
    ViewportWithCount = VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT,
    ScissorWithCount = VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT,
    VertexInputBindingStride = VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE,
    DepthTestEnable = VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE,
    DepthWriteEnable = VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE,
    DepthCompareOp = VK_DYNAMIC_STATE_DEPTH_COMPARE_OP,
    DepthBoundsTestEnable = VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE,
    StencilTestEnable = VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE,
    StencilOp = VK_DYNAMIC_STATE_STENCIL_OP,
    RasterizerDiscardEnable = VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE,
    DepthBiasEnable = VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE,
    PrimitiveRestartEnable = VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE,
    LineStipple = VK_DYNAMIC_STATE_LINE_STIPPLE,
    ViewportWScalingNv = VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV,
    DiscardRectangleExt = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT,
    DiscardRectangleEnableExt = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT,
    DiscardRectangleModeExt = VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT,
    SampleLocationsExt = VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT,
    RayTracingPipelineStackSizeKhr = VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR,
    ViewportShadingRatePaletteNv = VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV,
    ViewportCoarseSampleOrderNv = VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV,
    ExclusiveScissorEnableNv = VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV,
    ExclusiveScissorNv = VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV,
    FragmentShadingRateKhr = VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR,
    VertexInputExt = VK_DYNAMIC_STATE_VERTEX_INPUT_EXT,
    PatchControlPointsExt = VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT,
    LogicOpExt = VK_DYNAMIC_STATE_LOGIC_OP_EXT,
    ColorWriteEnableExt = VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT,
    DepthClampEnableExt = VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT,
    PolygonModeExt = VK_DYNAMIC_STATE_POLYGON_MODE_EXT,
    RasterizationSamplesExt = VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT,
    SampleMaskExt = VK_DYNAMIC_STATE_SAMPLE_MASK_EXT,
    AlphaToCoverageEnableExt = VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT,
    AlphaToOneEnableExt = VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT,
    LogicOpEnableExt = VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT,
    ColorBlendEnableExt = VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT,
    ColorBlendEquationExt = VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT,
    ColorWriteMaskExt = VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT,
    TessellationDomainOriginExt = VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT,
    RasterizationStreamExt = VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT,
    ConservativeRasterizationModeExt = VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT,
    ExtraPrimitiveOverestimationSizeExt = VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT,
    DepthClipEnableExt = VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT,
    SampleLocationsEnableExt = VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT,
    ColorBlendAdvancedExt = VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT,
    ProvokingVertexModeExt = VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT,
    LineRasterizationModeExt = VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT,
    LineStippleEnableExt = VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT,
    DepthClipNegativeOneToOneExt = VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT,
    ViewportWScalingEnableNv = VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV,
    ViewportSwizzleNv = VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV,
    CoverageToColorEnableNv = VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV,
    CoverageToColorLocationNv = VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV,
    CoverageModulationModeNv = VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV,
    CoverageModulationTableEnableNv = VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV,
    CoverageModulationTableNv = VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV,
    ShadingRateImageEnableNv = VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV,
    RepresentativeFragmentTestEnableNv = VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV,
    CoverageReductionModeNv = VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV,
    AttachmentFeedbackLoopEnableExt = VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT,
    DepthClampRangeExt = VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT,
    MaxEnum = VK_DYNAMIC_STATE_MAX_ENUM
};

enum class EventCreateFlags : u32 {
    DeviceOnly = VK_EVENT_CREATE_DEVICE_ONLY_BIT,
    FlagsMaxEnum = VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(EventCreateFlags);

enum class ExternalFenceFeatureFlags : u32 {
    Exportable = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    Importable = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT,
    FlagsMaxEnum = VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ExternalFenceFeatureFlags);

enum class ExternalFenceHandleTypeFlags : u32 {
    OpaqueFd = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    OpaqueWin32 = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    OpaqueWin32Kmt = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    SyncFd = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,
    FlagsMaxEnum = VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ExternalFenceHandleTypeFlags);

enum class ExternalMemoryFeatureFlags : u32 {
    DedicatedOnly = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    Exportable = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    Importable = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT,
    FlagsMaxEnum = VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ExternalMemoryFeatureFlags);

enum class ExternalMemoryFeatureFlagsNV : u32 {
    DedicatedOnlyNv = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV,
    ExportableNv = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV,
    ImportableNv = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV,
    FlagsMaxEnumNv = VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(ExternalMemoryFeatureFlagsNV);

enum class ExternalMemoryHandleTypeFlags : u32 {
    OpaqueFd = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    OpaqueWin32 = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    OpaqueWin32Kmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    D3d11Texture = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    D3d11TextureKmt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    D3d12Heap = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    D3d12Resource = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    DmaBufExt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
    AndroidHardwareBufferAndroid = VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID,
    HostAllocationExt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT,
    HostMappedForeignMemoryExt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT,
    ZirconVmoFuchsia = VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA,
    RdmaAddressNv = VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV,
    ScreenBufferQnx = VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX,
    MtlbufferExt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT,
    MtltextureExt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT,
    MtlheapExt = VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT,
    FlagsMaxEnum = VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ExternalMemoryHandleTypeFlags);

enum class ExternalMemoryHandleTypeFlagsNV : u32 {
    OpaqueWin32Nv = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV,
    OpaqueWin32KmtNv = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV,
    D3d11ImageNv = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV,
    D3d11ImageKmtNv = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV,
    FlagsMaxEnumNv = VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(ExternalMemoryHandleTypeFlagsNV);

enum class ExternalSemaphoreFeatureFlags : u32 {
    Exportable = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    Importable = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT,
    FlagsMaxEnum = VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ExternalSemaphoreFeatureFlags);

enum class ExternalSemaphoreHandleTypeFlags : u32 {
    OpaqueFd = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    OpaqueWin32 = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    OpaqueWin32Kmt = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    D3d12Fence = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    SyncFd = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,
    ZirconEventFuchsia = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA,
    FlagsMaxEnum = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ExternalSemaphoreHandleTypeFlags);

enum class FenceCreateFlags : u32 {
    Signaled = VK_FENCE_CREATE_SIGNALED_BIT,
    FlagsMaxEnum = VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(FenceCreateFlags);

enum class FenceImportFlags : u32 {
    Temporary = VK_FENCE_IMPORT_TEMPORARY_BIT,
    FlagsMaxEnum = VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(FenceImportFlags);

enum class Filter : u32 {
    Nearest = VK_FILTER_NEAREST,
    Linear = VK_FILTER_LINEAR,
    CubicExt = VK_FILTER_CUBIC_EXT,
    MaxEnum = VK_FILTER_MAX_ENUM
};

enum class Format : u32 {
    Undefined = VK_FORMAT_UNDEFINED,
    R4g4UnormPack8 = VK_FORMAT_R4G4_UNORM_PACK8,
    R4g4b4a4UnormPack16 = VK_FORMAT_R4G4B4A4_UNORM_PACK16,
    B4g4r4a4UnormPack16 = VK_FORMAT_B4G4R4A4_UNORM_PACK16,
    R5g6b5UnormPack16 = VK_FORMAT_R5G6B5_UNORM_PACK16,
    B5g6r5UnormPack16 = VK_FORMAT_B5G6R5_UNORM_PACK16,
    R5g5b5a1UnormPack16 = VK_FORMAT_R5G5B5A1_UNORM_PACK16,
    B5g5r5a1UnormPack16 = VK_FORMAT_B5G5R5A1_UNORM_PACK16,
    A1r5g5b5UnormPack16 = VK_FORMAT_A1R5G5B5_UNORM_PACK16,
    R8Unorm = VK_FORMAT_R8_UNORM,
    R8Snorm = VK_FORMAT_R8_SNORM,
    R8Uscaled = VK_FORMAT_R8_USCALED,
    R8Sscaled = VK_FORMAT_R8_SSCALED,
    R8Uint = VK_FORMAT_R8_UINT,
    R8Sint = VK_FORMAT_R8_SINT,
    R8Srgb = VK_FORMAT_R8_SRGB,
    R8g8Unorm = VK_FORMAT_R8G8_UNORM,
    R8g8Snorm = VK_FORMAT_R8G8_SNORM,
    R8g8Uscaled = VK_FORMAT_R8G8_USCALED,
    R8g8Sscaled = VK_FORMAT_R8G8_SSCALED,
    R8g8Uint = VK_FORMAT_R8G8_UINT,
    R8g8Sint = VK_FORMAT_R8G8_SINT,
    R8g8Srgb = VK_FORMAT_R8G8_SRGB,
    R8g8b8Unorm = VK_FORMAT_R8G8B8_UNORM,
    R8g8b8Snorm = VK_FORMAT_R8G8B8_SNORM,
    R8g8b8Uscaled = VK_FORMAT_R8G8B8_USCALED,
    R8g8b8Sscaled = VK_FORMAT_R8G8B8_SSCALED,
    R8g8b8Uint = VK_FORMAT_R8G8B8_UINT,
    R8g8b8Sint = VK_FORMAT_R8G8B8_SINT,
    R8g8b8Srgb = VK_FORMAT_R8G8B8_SRGB,
    B8g8r8Unorm = VK_FORMAT_B8G8R8_UNORM,
    B8g8r8Snorm = VK_FORMAT_B8G8R8_SNORM,
    B8g8r8Uscaled = VK_FORMAT_B8G8R8_USCALED,
    B8g8r8Sscaled = VK_FORMAT_B8G8R8_SSCALED,
    B8g8r8Uint = VK_FORMAT_B8G8R8_UINT,
    B8g8r8Sint = VK_FORMAT_B8G8R8_SINT,
    B8g8r8Srgb = VK_FORMAT_B8G8R8_SRGB,
    R8g8b8a8Unorm = VK_FORMAT_R8G8B8A8_UNORM,
    R8g8b8a8Snorm = VK_FORMAT_R8G8B8A8_SNORM,
    R8g8b8a8Uscaled = VK_FORMAT_R8G8B8A8_USCALED,
    R8g8b8a8Sscaled = VK_FORMAT_R8G8B8A8_SSCALED,
    R8g8b8a8Uint = VK_FORMAT_R8G8B8A8_UINT,
    R8g8b8a8Sint = VK_FORMAT_R8G8B8A8_SINT,
    R8g8b8a8Srgb = VK_FORMAT_R8G8B8A8_SRGB,
    B8g8r8a8Unorm = VK_FORMAT_B8G8R8A8_UNORM,
    B8g8r8a8Snorm = VK_FORMAT_B8G8R8A8_SNORM,
    B8g8r8a8Uscaled = VK_FORMAT_B8G8R8A8_USCALED,
    B8g8r8a8Sscaled = VK_FORMAT_B8G8R8A8_SSCALED,
    B8g8r8a8Uint = VK_FORMAT_B8G8R8A8_UINT,
    B8g8r8a8Sint = VK_FORMAT_B8G8R8A8_SINT,
    B8g8r8a8Srgb = VK_FORMAT_B8G8R8A8_SRGB,
    A8b8g8r8UnormPack32 = VK_FORMAT_A8B8G8R8_UNORM_PACK32,
    A8b8g8r8SnormPack32 = VK_FORMAT_A8B8G8R8_SNORM_PACK32,
    A8b8g8r8UscaledPack32 = VK_FORMAT_A8B8G8R8_USCALED_PACK32,
    A8b8g8r8SscaledPack32 = VK_FORMAT_A8B8G8R8_SSCALED_PACK32,
    A8b8g8r8UintPack32 = VK_FORMAT_A8B8G8R8_UINT_PACK32,
    A8b8g8r8SintPack32 = VK_FORMAT_A8B8G8R8_SINT_PACK32,
    A8b8g8r8SrgbPack32 = VK_FORMAT_A8B8G8R8_SRGB_PACK32,
    A2r10g10b10UnormPack32 = VK_FORMAT_A2R10G10B10_UNORM_PACK32,
    A2r10g10b10SnormPack32 = VK_FORMAT_A2R10G10B10_SNORM_PACK32,
    A2r10g10b10UscaledPack32 = VK_FORMAT_A2R10G10B10_USCALED_PACK32,
    A2r10g10b10SscaledPack32 = VK_FORMAT_A2R10G10B10_SSCALED_PACK32,
    A2r10g10b10UintPack32 = VK_FORMAT_A2R10G10B10_UINT_PACK32,
    A2r10g10b10SintPack32 = VK_FORMAT_A2R10G10B10_SINT_PACK32,
    A2b10g10r10UnormPack32 = VK_FORMAT_A2B10G10R10_UNORM_PACK32,
    A2b10g10r10SnormPack32 = VK_FORMAT_A2B10G10R10_SNORM_PACK32,
    A2b10g10r10UscaledPack32 = VK_FORMAT_A2B10G10R10_USCALED_PACK32,
    A2b10g10r10SscaledPack32 = VK_FORMAT_A2B10G10R10_SSCALED_PACK32,
    A2b10g10r10UintPack32 = VK_FORMAT_A2B10G10R10_UINT_PACK32,
    A2b10g10r10SintPack32 = VK_FORMAT_A2B10G10R10_SINT_PACK32,
    R16Unorm = VK_FORMAT_R16_UNORM,
    R16Snorm = VK_FORMAT_R16_SNORM,
    R16Uscaled = VK_FORMAT_R16_USCALED,
    R16Sscaled = VK_FORMAT_R16_SSCALED,
    R16Uint = VK_FORMAT_R16_UINT,
    R16Sint = VK_FORMAT_R16_SINT,
    R16Sfloat = VK_FORMAT_R16_SFLOAT,
    R16g16Unorm = VK_FORMAT_R16G16_UNORM,
    R16g16Snorm = VK_FORMAT_R16G16_SNORM,
    R16g16Uscaled = VK_FORMAT_R16G16_USCALED,
    R16g16Sscaled = VK_FORMAT_R16G16_SSCALED,
    R16g16Uint = VK_FORMAT_R16G16_UINT,
    R16g16Sint = VK_FORMAT_R16G16_SINT,
    R16g16Sfloat = VK_FORMAT_R16G16_SFLOAT,
    R16g16b16Unorm = VK_FORMAT_R16G16B16_UNORM,
    R16g16b16Snorm = VK_FORMAT_R16G16B16_SNORM,
    R16g16b16Uscaled = VK_FORMAT_R16G16B16_USCALED,
    R16g16b16Sscaled = VK_FORMAT_R16G16B16_SSCALED,
    R16g16b16Uint = VK_FORMAT_R16G16B16_UINT,
    R16g16b16Sint = VK_FORMAT_R16G16B16_SINT,
    R16g16b16Sfloat = VK_FORMAT_R16G16B16_SFLOAT,
    R16g16b16a16Unorm = VK_FORMAT_R16G16B16A16_UNORM,
    R16g16b16a16Snorm = VK_FORMAT_R16G16B16A16_SNORM,
    R16g16b16a16Uscaled = VK_FORMAT_R16G16B16A16_USCALED,
    R16g16b16a16Sscaled = VK_FORMAT_R16G16B16A16_SSCALED,
    R16g16b16a16Uint = VK_FORMAT_R16G16B16A16_UINT,
    R16g16b16a16Sint = VK_FORMAT_R16G16B16A16_SINT,
    R16g16b16a16Sfloat = VK_FORMAT_R16G16B16A16_SFLOAT,
    R32Uint = VK_FORMAT_R32_UINT,
    R32Sint = VK_FORMAT_R32_SINT,
    R32Sfloat = VK_FORMAT_R32_SFLOAT,
    R32g32Uint = VK_FORMAT_R32G32_UINT,
    R32g32Sint = VK_FORMAT_R32G32_SINT,
    R32g32Sfloat = VK_FORMAT_R32G32_SFLOAT,
    R32g32b32Uint = VK_FORMAT_R32G32B32_UINT,
    R32g32b32Sint = VK_FORMAT_R32G32B32_SINT,
    R32g32b32Sfloat = VK_FORMAT_R32G32B32_SFLOAT,
    R32g32b32a32Uint = VK_FORMAT_R32G32B32A32_UINT,
    R32g32b32a32Sint = VK_FORMAT_R32G32B32A32_SINT,
    R32g32b32a32Sfloat = VK_FORMAT_R32G32B32A32_SFLOAT,
    R64Uint = VK_FORMAT_R64_UINT,
    R64Sint = VK_FORMAT_R64_SINT,
    R64Sfloat = VK_FORMAT_R64_SFLOAT,
    R64g64Uint = VK_FORMAT_R64G64_UINT,
    R64g64Sint = VK_FORMAT_R64G64_SINT,
    R64g64Sfloat = VK_FORMAT_R64G64_SFLOAT,
    R64g64b64Uint = VK_FORMAT_R64G64B64_UINT,
    R64g64b64Sint = VK_FORMAT_R64G64B64_SINT,
    R64g64b64Sfloat = VK_FORMAT_R64G64B64_SFLOAT,
    R64g64b64a64Uint = VK_FORMAT_R64G64B64A64_UINT,
    R64g64b64a64Sint = VK_FORMAT_R64G64B64A64_SINT,
    R64g64b64a64Sfloat = VK_FORMAT_R64G64B64A64_SFLOAT,
    B10g11r11UfloatPack32 = VK_FORMAT_B10G11R11_UFLOAT_PACK32,
    E5b9g9r9UfloatPack32 = VK_FORMAT_E5B9G9R9_UFLOAT_PACK32,
    D16Unorm = VK_FORMAT_D16_UNORM,
    X8D24UnormPack32 = VK_FORMAT_X8_D24_UNORM_PACK32,
    D32Sfloat = VK_FORMAT_D32_SFLOAT,
    S8Uint = VK_FORMAT_S8_UINT,
    D16UnormS8Uint = VK_FORMAT_D16_UNORM_S8_UINT,
    D24UnormS8Uint = VK_FORMAT_D24_UNORM_S8_UINT,
    D32SfloatS8Uint = VK_FORMAT_D32_SFLOAT_S8_UINT,
    Bc1RgbUnormBlock = VK_FORMAT_BC1_RGB_UNORM_BLOCK,
    Bc1RgbSrgbBlock = VK_FORMAT_BC1_RGB_SRGB_BLOCK,
    Bc1RgbaUnormBlock = VK_FORMAT_BC1_RGBA_UNORM_BLOCK,
    Bc1RgbaSrgbBlock = VK_FORMAT_BC1_RGBA_SRGB_BLOCK,
    Bc2UnormBlock = VK_FORMAT_BC2_UNORM_BLOCK,
    Bc2SrgbBlock = VK_FORMAT_BC2_SRGB_BLOCK,
    Bc3UnormBlock = VK_FORMAT_BC3_UNORM_BLOCK,
    Bc3SrgbBlock = VK_FORMAT_BC3_SRGB_BLOCK,
    Bc4UnormBlock = VK_FORMAT_BC4_UNORM_BLOCK,
    Bc4SnormBlock = VK_FORMAT_BC4_SNORM_BLOCK,
    Bc5UnormBlock = VK_FORMAT_BC5_UNORM_BLOCK,
    Bc5SnormBlock = VK_FORMAT_BC5_SNORM_BLOCK,
    Bc6hUfloatBlock = VK_FORMAT_BC6H_UFLOAT_BLOCK,
    Bc6hSfloatBlock = VK_FORMAT_BC6H_SFLOAT_BLOCK,
    Bc7UnormBlock = VK_FORMAT_BC7_UNORM_BLOCK,
    Bc7SrgbBlock = VK_FORMAT_BC7_SRGB_BLOCK,
    Etc2R8g8b8UnormBlock = VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK,
    Etc2R8g8b8SrgbBlock = VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK,
    Etc2R8g8b8a1UnormBlock = VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK,
    Etc2R8g8b8a1SrgbBlock = VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK,
    Etc2R8g8b8a8UnormBlock = VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK,
    Etc2R8g8b8a8SrgbBlock = VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK,
    EacR11UnormBlock = VK_FORMAT_EAC_R11_UNORM_BLOCK,
    EacR11SnormBlock = VK_FORMAT_EAC_R11_SNORM_BLOCK,
    EacR11g11UnormBlock = VK_FORMAT_EAC_R11G11_UNORM_BLOCK,
    EacR11g11SnormBlock = VK_FORMAT_EAC_R11G11_SNORM_BLOCK,
    Astc4x4UnormBlock = VK_FORMAT_ASTC_4x4_UNORM_BLOCK,
    Astc4x4SrgbBlock = VK_FORMAT_ASTC_4x4_SRGB_BLOCK,
    Astc5x4UnormBlock = VK_FORMAT_ASTC_5x4_UNORM_BLOCK,
    Astc5x4SrgbBlock = VK_FORMAT_ASTC_5x4_SRGB_BLOCK,
    Astc5x5UnormBlock = VK_FORMAT_ASTC_5x5_UNORM_BLOCK,
    Astc5x5SrgbBlock = VK_FORMAT_ASTC_5x5_SRGB_BLOCK,
    Astc6x5UnormBlock = VK_FORMAT_ASTC_6x5_UNORM_BLOCK,
    Astc6x5SrgbBlock = VK_FORMAT_ASTC_6x5_SRGB_BLOCK,
    Astc6x6UnormBlock = VK_FORMAT_ASTC_6x6_UNORM_BLOCK,
    Astc6x6SrgbBlock = VK_FORMAT_ASTC_6x6_SRGB_BLOCK,
    Astc8x5UnormBlock = VK_FORMAT_ASTC_8x5_UNORM_BLOCK,
    Astc8x5SrgbBlock = VK_FORMAT_ASTC_8x5_SRGB_BLOCK,
    Astc8x6UnormBlock = VK_FORMAT_ASTC_8x6_UNORM_BLOCK,
    Astc8x6SrgbBlock = VK_FORMAT_ASTC_8x6_SRGB_BLOCK,
    Astc8x8UnormBlock = VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
    Astc8x8SrgbBlock = VK_FORMAT_ASTC_8x8_SRGB_BLOCK,
    Astc10x5UnormBlock = VK_FORMAT_ASTC_10x5_UNORM_BLOCK,
    Astc10x5SrgbBlock = VK_FORMAT_ASTC_10x5_SRGB_BLOCK,
    Astc10x6UnormBlock = VK_FORMAT_ASTC_10x6_UNORM_BLOCK,
    Astc10x6SrgbBlock = VK_FORMAT_ASTC_10x6_SRGB_BLOCK,
    Astc10x8UnormBlock = VK_FORMAT_ASTC_10x8_UNORM_BLOCK,
    Astc10x8SrgbBlock = VK_FORMAT_ASTC_10x8_SRGB_BLOCK,
    Astc10x10UnormBlock = VK_FORMAT_ASTC_10x10_UNORM_BLOCK,
    Astc10x10SrgbBlock = VK_FORMAT_ASTC_10x10_SRGB_BLOCK,
    Astc12x10UnormBlock = VK_FORMAT_ASTC_12x10_UNORM_BLOCK,
    Astc12x10SrgbBlock = VK_FORMAT_ASTC_12x10_SRGB_BLOCK,
    Astc12x12UnormBlock = VK_FORMAT_ASTC_12x12_UNORM_BLOCK,
    Astc12x12SrgbBlock = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    G8b8g8r8422Unorm = VK_FORMAT_G8B8G8R8_422_UNORM,
    B8g8r8g8422Unorm = VK_FORMAT_B8G8R8G8_422_UNORM,
    G8B8R83plane420Unorm = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    G8B8r82plane420Unorm = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    G8B8R83plane422Unorm = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    G8B8r82plane422Unorm = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    G8B8R83plane444Unorm = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    R10x6UnormPack16 = VK_FORMAT_R10X6_UNORM_PACK16,
    R10x6g10x6Unorm2pack16 = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    R10x6g10x6b10x6a10x6Unorm4pack16 = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    G10x6b10x6g10x6r10x6422Unorm4pack16 = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    B10x6g10x6r10x6g10x6422Unorm4pack16 = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    G10x6B10x6R10x63plane420Unorm3pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    G10x6B10x6r10x62plane420Unorm3pack16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    G10x6B10x6R10x63plane422Unorm3pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    G10x6B10x6r10x62plane422Unorm3pack16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    G10x6B10x6R10x63plane444Unorm3pack16 = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    R12x4UnormPack16 = VK_FORMAT_R12X4_UNORM_PACK16,
    R12x4g12x4Unorm2pack16 = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    R12x4g12x4b12x4a12x4Unorm4pack16 = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    G12x4b12x4g12x4r12x4422Unorm4pack16 = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    B12x4g12x4r12x4g12x4422Unorm4pack16 = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    G12x4B12x4R12x43plane420Unorm3pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    G12x4B12x4r12x42plane420Unorm3pack16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    G12x4B12x4R12x43plane422Unorm3pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    G12x4B12x4r12x42plane422Unorm3pack16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    G12x4B12x4R12x43plane444Unorm3pack16 = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    G16b16g16r16422Unorm = VK_FORMAT_G16B16G16R16_422_UNORM,
    B16g16r16g16422Unorm = VK_FORMAT_B16G16R16G16_422_UNORM,
    G16B16R163plane420Unorm = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    G16B16r162plane420Unorm = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    G16B16R163plane422Unorm = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    G16B16r162plane422Unorm = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    G16B16R163plane444Unorm = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM,
    G8B8r82plane444Unorm = VK_FORMAT_G8_B8R8_2PLANE_444_UNORM,
    G10x6B10x6r10x62plane444Unorm3pack16 = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16,
    G12x4B12x4r12x42plane444Unorm3pack16 = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16,
    G16B16r162plane444Unorm = VK_FORMAT_G16_B16R16_2PLANE_444_UNORM,
    A4r4g4b4UnormPack16 = VK_FORMAT_A4R4G4B4_UNORM_PACK16,
    A4b4g4r4UnormPack16 = VK_FORMAT_A4B4G4R4_UNORM_PACK16,
    Astc4x4SfloatBlock = VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK,
    Astc5x4SfloatBlock = VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK,
    Astc5x5SfloatBlock = VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK,
    Astc6x5SfloatBlock = VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK,
    Astc6x6SfloatBlock = VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK,
    Astc8x5SfloatBlock = VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK,
    Astc8x6SfloatBlock = VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK,
    Astc8x8SfloatBlock = VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK,
    Astc10x5SfloatBlock = VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK,
    Astc10x6SfloatBlock = VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK,
    Astc10x8SfloatBlock = VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK,
    Astc10x10SfloatBlock = VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK,
    Astc12x10SfloatBlock = VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK,
    Astc12x12SfloatBlock = VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK,
    A1b5g5r5UnormPack16 = VK_FORMAT_A1B5G5R5_UNORM_PACK16,
    A8Unorm = VK_FORMAT_A8_UNORM,
    Pvrtc12bppUnormBlockImg = VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG,
    Pvrtc14bppUnormBlockImg = VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG,
    Pvrtc22bppUnormBlockImg = VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG,
    Pvrtc24bppUnormBlockImg = VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG,
    Pvrtc12bppSrgbBlockImg = VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG,
    Pvrtc14bppSrgbBlockImg = VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG,
    Pvrtc22bppSrgbBlockImg = VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG,
    Pvrtc24bppSrgbBlockImg = VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG,
    R16g16Sfixed5Nv = VK_FORMAT_R16G16_SFIXED5_NV,
    MaxEnum = VK_FORMAT_MAX_ENUM
};

enum class FormatFeatureFlags : u32 {
    SampledImage = VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT,
    StorageImage = VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT,
    StorageImageAtomic = VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT,
    UniformTexelBuffer = VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT,
    StorageTexelBuffer = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT,
    StorageTexelBufferAtomic = VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT,
    VertexBuffer = VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT,
    ColorAttachment = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT,
    ColorAttachmentBlend = VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT,
    DepthStencilAttachment = VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT,
    BlitSrc = VK_FORMAT_FEATURE_BLIT_SRC_BIT,
    BlitDst = VK_FORMAT_FEATURE_BLIT_DST_BIT,
    SampledImageFilterLinear = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT,
    TransferSrc = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    TransferDst = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    MidpointChromaSamples = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    SampledImageYcbcrConversionLinearFilter = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    SampledImageYcbcrConversionSeparateReconstructionFilter = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    SampledImageYcbcrConversionChromaReconstructionExplicit = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    SampledImageYcbcrConversionChromaReconstructionExplicitForceable = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    Disjoint = VK_FORMAT_FEATURE_DISJOINT_BIT,
    CositedChromaSamples = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT,
    SampledImageFilterMinmax = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT,
    VideoDecodeOutputKhr = VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR,
    VideoDecodeDpbKhr = VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR,
    AccelerationStructureVertexBufferKhr = VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR,
    SampledImageFilterCubicExt = VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT,
    FragmentDensityMapExt = VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT,
    FragmentShadingRateAttachmentKhr = VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    VideoEncodeInputKhr = VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR,
    VideoEncodeDpbKhr = VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR,
    FlagsMaxEnum = VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(FormatFeatureFlags);

enum class FragmentShadingRateCombinerOpKHR : u32 {
    KeepKhr = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR,
    ReplaceKhr = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR,
    MinKhr = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR,
    MaxKhr = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR,
    MulKhr = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR,
    MaxEnumKhr = VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_ENUM_KHR
};

enum class FragmentShadingRateNV : u32 {
    1InvocationPerPixelNv = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV,
    1InvocationPer1x2PixelsNv = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV,
    1InvocationPer2x1PixelsNv = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV,
    1InvocationPer2x2PixelsNv = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV,
    1InvocationPer2x4PixelsNv = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV,
    1InvocationPer4x2PixelsNv = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV,
    1InvocationPer4x4PixelsNv = VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV,
    2InvocationsPerPixelNv = VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV,
    4InvocationsPerPixelNv = VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV,
    8InvocationsPerPixelNv = VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV,
    16InvocationsPerPixelNv = VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV,
    NoInvocationsNv = VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV,
    MaxEnumNv = VK_FRAGMENT_SHADING_RATE_MAX_ENUM_NV
};

enum class FragmentShadingRateTypeNV : u32 {
    FragmentSizeNv = VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV,
    EnumsNv = VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV,
    MaxEnumNv = VK_FRAGMENT_SHADING_RATE_TYPE_MAX_ENUM_NV
};

enum class FrameBoundaryFlagsEXT : u32 {
    RameEndExt = VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT,
    LagsMaxEnumExt = VK_FRAME_BOUNDARY_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(FrameBoundaryFlagsEXT);

enum class FramebufferCreateFlags : u32 {
    Imageless = VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT,
    FlagsMaxEnum = VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(FramebufferCreateFlags);

enum class FrontFace : u32 {
    CounterClockwise = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    Clockwise = VK_FRONT_FACE_CLOCKWISE,
    MaxEnum = VK_FRONT_FACE_MAX_ENUM
};

enum class GeometryFlagsKHR : u32 {
    OpaqueKhr = VK_GEOMETRY_OPAQUE_BIT_KHR,
    NoDuplicateAnyHitInvocationKhr = VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR,
    FlagsMaxEnumKhr = VK_GEOMETRY_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(GeometryFlagsKHR);

enum class GeometryInstanceFlagsKHR : u32 {
    TriangleFacingCullDisableKhr = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR,
    TriangleFlipFacingKhr = VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR,
    ForceOpaqueKhr = VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR,
    ForceNoOpaqueKhr = VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR,
    ForceOpacityMicromap2StateExt = VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT,
    DisableOpacityMicromapsExt = VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT,
    TriangleFrontCounterclockwiseKhr = VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR,
    FlagsMaxEnumKhr = VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(GeometryInstanceFlagsKHR);

enum class GeometryTypeKHR : u32 {
    TrianglesKhr = VK_GEOMETRY_TYPE_TRIANGLES_KHR,
    AabbsKhr = VK_GEOMETRY_TYPE_AABBS_KHR,
    InstancesKhr = VK_GEOMETRY_TYPE_INSTANCES_KHR,
    SpheresNv = VK_GEOMETRY_TYPE_SPHERES_NV,
    LinearSweptSpheresNv = VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV,
    MaxEnumKhr = VK_GEOMETRY_TYPE_MAX_ENUM_KHR
};

enum class GraphicsPipelineLibraryFlagsEXT : u32 {
    VertexInputInterfaceExt = VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT,
    PreRasterizationShadersExt = VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT,
    FragmentShaderExt = VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT,
    FragmentOutputInterfaceExt = VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT,
    FlagsMaxEnumExt = VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(GraphicsPipelineLibraryFlagsEXT);

enum class HostImageCopyFlags : u32 {
    Memcpy = VK_HOST_IMAGE_COPY_MEMCPY,
    FlagsMaxEnum = VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(HostImageCopyFlags);

enum class ImageAspectFlags : u32 {
    Color = VK_IMAGE_ASPECT_COLOR_BIT,
    Depth = VK_IMAGE_ASPECT_DEPTH_BIT,
    Stencil = VK_IMAGE_ASPECT_STENCIL_BIT,
    Metadata = VK_IMAGE_ASPECT_METADATA_BIT,
    Plane0 = VK_IMAGE_ASPECT_PLANE_0_BIT,
    Plane1 = VK_IMAGE_ASPECT_PLANE_1_BIT,
    Plane2 = VK_IMAGE_ASPECT_PLANE_2_BIT,
    None = VK_IMAGE_ASPECT_NONE,
    MemoryPlane0Ext = VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT,
    MemoryPlane1Ext = VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT,
    MemoryPlane2Ext = VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT,
    MemoryPlane3Ext = VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT,
    FlagsMaxEnum = VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ImageAspectFlags);

enum class ImageCompressionFixedRateFlagsEXT : u32 {
    NoneExt = VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT,
    1bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT,
    2bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT,
    3bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT,
    4bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT,
    5bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT,
    6bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT,
    7bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT,
    8bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT,
    9bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT,
    10bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT,
    11bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT,
    12bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT,
    13bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT,
    14bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT,
    15bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT,
    16bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT,
    17bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT,
    18bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT,
    19bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT,
    20bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT,
    21bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT,
    22bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT,
    23bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT,
    24bpcExt = VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT,
    FlagsMaxEnumExt = VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(ImageCompressionFixedRateFlagsEXT);

enum class ImageCompressionFlagsEXT : u32 {
    DefaultExt = VK_IMAGE_COMPRESSION_DEFAULT_EXT,
    FixedRateDefaultExt = VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT,
    FixedRateExplicitExt = VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT,
    DisabledExt = VK_IMAGE_COMPRESSION_DISABLED_EXT,
    FlagsMaxEnumExt = VK_IMAGE_COMPRESSION_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(ImageCompressionFlagsEXT);

enum class ImageCreateFlags : u32 {
    SparseBinding = VK_IMAGE_CREATE_SPARSE_BINDING_BIT,
    SparseResidency = VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT,
    SparseAliased = VK_IMAGE_CREATE_SPARSE_ALIASED_BIT,
    MutableFormat = VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT,
    CubeCompatible = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
    Alias = VK_IMAGE_CREATE_ALIAS_BIT,
    SplitInstanceBindRegions = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    2dArrayCompatible = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    BlockTexelViewCompatible = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    ExtendedUsage = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    Protected = VK_IMAGE_CREATE_PROTECTED_BIT,
    Disjoint = VK_IMAGE_CREATE_DISJOINT_BIT,
    CornerSampledNv = VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV,
    SampleLocationsCompatibleDepthExt = VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT,
    SubsampledExt = VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT,
    DescriptorBufferCaptureReplayExt = VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
    MultisampledRenderToSingleSampledExt = VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT,
    2dViewCompatibleExt = VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT,
    VideoProfileIndependentKhr = VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR,
    FragmentDensityMapOffsetExt = VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT,
    FlagsMaxEnum = VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ImageCreateFlags);

enum class ImageLayout : u32 {
    Undefined = VK_IMAGE_LAYOUT_UNDEFINED,
    General = VK_IMAGE_LAYOUT_GENERAL,
    ColorAttachmentOptimal = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL,
    DepthStencilAttachmentOptimal = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL,
    DepthStencilReadOnlyOptimal = VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL,
    ShaderReadOnlyOptimal = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,
    TransferSrcOptimal = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
    TransferDstOptimal = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
    Preinitialized = VK_IMAGE_LAYOUT_PREINITIALIZED,
    DepthReadOnlyStencilAttachmentOptimal = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    DepthAttachmentStencilReadOnlyOptimal = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL,
    DepthAttachmentOptimal = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL,
    DepthReadOnlyOptimal = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL,
    StencilAttachmentOptimal = VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL,
    StencilReadOnlyOptimal = VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL,
    ReadOnlyOptimal = VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL,
    AttachmentOptimal = VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL,
    RenderingLocalRead = VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ,
    PresentSrcKhr = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR,
    VideoDecodeDstKhr = VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR,
    VideoDecodeSrcKhr = VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR,
    VideoDecodeDpbKhr = VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR,
    SharedPresentKhr = VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR,
    FragmentDensityMapOptimalExt = VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT,
    FragmentShadingRateAttachmentOptimalKhr = VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR,
    VideoEncodeDstKhr = VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR,
    VideoEncodeSrcKhr = VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR,
    VideoEncodeDpbKhr = VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR,
    AttachmentFeedbackLoopOptimalExt = VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT,
    VideoEncodeQuantizationMapKhr = VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR,
    MaxEnum = VK_IMAGE_LAYOUT_MAX_ENUM
};

enum class ImageTiling : u32 {
    Optimal = VK_IMAGE_TILING_OPTIMAL,
    Linear = VK_IMAGE_TILING_LINEAR,
    DrmFormatModifierExt = VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,
    MaxEnum = VK_IMAGE_TILING_MAX_ENUM
};

enum class ImageType : u32 {
    1d = VK_IMAGE_TYPE_1D,
    2d = VK_IMAGE_TYPE_2D,
    3d = VK_IMAGE_TYPE_3D,
    MaxEnum = VK_IMAGE_TYPE_MAX_ENUM
};

enum class ImageUsageFlags : u32 {
    TransferSrc = VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
    TransferDst = VK_IMAGE_USAGE_TRANSFER_DST_BIT,
    Sampled = VK_IMAGE_USAGE_SAMPLED_BIT,
    Storage = VK_IMAGE_USAGE_STORAGE_BIT,
    ColorAttachment = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
    DepthStencilAttachment = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
    TransientAttachment = VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT,
    InputAttachment = VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT,
    HostTransfer = VK_IMAGE_USAGE_HOST_TRANSFER_BIT,
    VideoDecodeDstKhr = VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR,
    VideoDecodeSrcKhr = VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR,
    VideoDecodeDpbKhr = VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR,
    FragmentDensityMapExt = VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT,
    FragmentShadingRateAttachmentKhr = VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    VideoEncodeDstKhr = VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR,
    VideoEncodeSrcKhr = VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR,
    VideoEncodeDpbKhr = VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR,
    AttachmentFeedbackLoopExt = VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT,
    InvocationMaskHuawei = VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI,
    SampleWeightQcom = VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM,
    SampleBlockMatchQcom = VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM,
    TileMemoryQcom = VK_IMAGE_USAGE_TILE_MEMORY_QCOM,
    VideoEncodeQuantizationDeltaMapKhr = VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR,
    VideoEncodeEmphasisMapKhr = VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR,
    FlagsMaxEnum = VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ImageUsageFlags);

enum class ImageViewCreateFlags : u32 {
    FragmentDensityMapDynamicExt = VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT,
    DescriptorBufferCaptureReplayExt = VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
    FragmentDensityMapDeferredExt = VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT,
    FlagsMaxEnum = VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ImageViewCreateFlags);

enum class ImageViewType : u32 {
    1d = VK_IMAGE_VIEW_TYPE_1D,
    2d = VK_IMAGE_VIEW_TYPE_2D,
    3d = VK_IMAGE_VIEW_TYPE_3D,
    Cube = VK_IMAGE_VIEW_TYPE_CUBE,
    1dArray = VK_IMAGE_VIEW_TYPE_1D_ARRAY,
    2dArray = VK_IMAGE_VIEW_TYPE_2D_ARRAY,
    CubeArray = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    MaxEnum = VK_IMAGE_VIEW_TYPE_MAX_ENUM
};

enum class IndexType : u32 {
    Uint16 = VK_INDEX_TYPE_UINT16,
    Uint32 = VK_INDEX_TYPE_UINT32,
    Uint8 = VK_INDEX_TYPE_UINT8,
    NoneKhr = VK_INDEX_TYPE_NONE_KHR,
    MaxEnum = VK_INDEX_TYPE_MAX_ENUM
};

enum class IndirectCommandsInputModeFlagsEXT : u32 {
    VulkanIndexBufferExt = VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT,
    DxgiIndexBufferExt = VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT,
    FlagsMaxEnumExt = VK_INDIRECT_COMMANDS_INPUT_MODE_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(IndirectCommandsInputModeFlagsEXT);

enum class IndirectCommandsLayoutUsageFlagsEXT : u32 {
    ExplicitPreprocessExt = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT,
    UnorderedSequencesExt = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT,
    FlagsMaxEnumExt = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(IndirectCommandsLayoutUsageFlagsEXT);

enum class IndirectCommandsLayoutUsageFlagsNV : u32 {
    ExplicitPreprocessNv = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV,
    IndexedSequencesNv = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV,
    UnorderedSequencesNv = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV,
    FlagsMaxEnumNv = VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(IndirectCommandsLayoutUsageFlagsNV);

enum class IndirectCommandsTokenTypeEXT : u32 {
    ExecutionSetExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT,
    PushConstantExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT,
    SequenceIndexExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT,
    IndexBufferExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT,
    VertexBufferExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT,
    DrawIndexedExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT,
    DrawExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT,
    DrawIndexedCountExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT,
    DrawCountExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT,
    DispatchExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT,
    DrawMeshTasksNvExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT,
    DrawMeshTasksCountNvExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT,
    DrawMeshTasksExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT,
    DrawMeshTasksCountExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT,
    TraceRays2Ext = VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT,
    MaxEnumExt = VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_EXT
};

enum class IndirectCommandsTokenTypeNV : u32 {
    ShaderGroupNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV,
    StateFlagsNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV,
    IndexBufferNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV,
    VertexBufferNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV,
    PushConstantNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV,
    DrawIndexedNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV,
    DrawNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV,
    DrawTasksNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV,
    DrawMeshTasksNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV,
    PipelineNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV,
    DispatchNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV,
    MaxEnumNv = VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NV
};

enum class IndirectExecutionSetInfoTypeEXT : u32 {
    PipelinesExt = VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT,
    ShaderObjectsExt = VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT,
    MaxEnumExt = VK_INDIRECT_EXECUTION_SET_INFO_TYPE_MAX_ENUM_EXT
};

enum class IndirectStateFlagsNV : u32 {
    FrontfaceNv = VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV,
    BitsMaxEnumNv = VK_INDIRECT_STATE_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(IndirectStateFlagsNV);

enum class InstanceCreateFlags : u32 {
    EnumeratePortabilityKhr = VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR,
    FlagsMaxEnum = VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(InstanceCreateFlags);

enum class InternalAllocationType : u32 {
    Executable = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    MaxEnum = VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM
};

enum class LatencyMarkerNV : u32 {
    SimulationStartNv = VK_LATENCY_MARKER_SIMULATION_START_NV,
    SimulationEndNv = VK_LATENCY_MARKER_SIMULATION_END_NV,
    RendersubmitStartNv = VK_LATENCY_MARKER_RENDERSUBMIT_START_NV,
    RendersubmitEndNv = VK_LATENCY_MARKER_RENDERSUBMIT_END_NV,
    PresentStartNv = VK_LATENCY_MARKER_PRESENT_START_NV,
    PresentEndNv = VK_LATENCY_MARKER_PRESENT_END_NV,
    InputSampleNv = VK_LATENCY_MARKER_INPUT_SAMPLE_NV,
    TriggerFlashNv = VK_LATENCY_MARKER_TRIGGER_FLASH_NV,
    OutOfBandRendersubmitStartNv = VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV,
    OutOfBandRendersubmitEndNv = VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV,
    OutOfBandPresentStartNv = VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV,
    OutOfBandPresentEndNv = VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV,
    MaxEnumNv = VK_LATENCY_MARKER_MAX_ENUM_NV
};

enum class LayerSettingTypeEXT : u32 {
    Bool32Ext = VK_LAYER_SETTING_TYPE_BOOL32_EXT,
    Int32Ext = VK_LAYER_SETTING_TYPE_INT32_EXT,
    Int64Ext = VK_LAYER_SETTING_TYPE_INT64_EXT,
    Uint32Ext = VK_LAYER_SETTING_TYPE_UINT32_EXT,
    Uint64Ext = VK_LAYER_SETTING_TYPE_UINT64_EXT,
    Float32Ext = VK_LAYER_SETTING_TYPE_FLOAT32_EXT,
    Float64Ext = VK_LAYER_SETTING_TYPE_FLOAT64_EXT,
    StringExt = VK_LAYER_SETTING_TYPE_STRING_EXT,
    MaxEnumExt = VK_LAYER_SETTING_TYPE_MAX_ENUM_EXT
};

enum class LayeredDriverUnderlyingApiMSFT : u32 {
    NoneMsft = VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT,
    D3d12Msft = VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT,
    MaxEnumMsft = VK_LAYERED_DRIVER_UNDERLYING_API_MAX_ENUM_MSFT
};

enum class LineRasterizationMode : u32 {
    Default = VK_LINE_RASTERIZATION_MODE_DEFAULT,
    Rectangular = VK_LINE_RASTERIZATION_MODE_RECTANGULAR,
    Bresenham = VK_LINE_RASTERIZATION_MODE_BRESENHAM,
    RectangularSmooth = VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH,
    MaxEnum = VK_LINE_RASTERIZATION_MODE_MAX_ENUM
};

enum class LogicOp : u32 {
    Clear = VK_LOGIC_OP_CLEAR,
    And = VK_LOGIC_OP_AND,
    AndReverse = VK_LOGIC_OP_AND_REVERSE,
    Copy = VK_LOGIC_OP_COPY,
    AndInverted = VK_LOGIC_OP_AND_INVERTED,
    NoOp = VK_LOGIC_OP_NO_OP,
    Xor = VK_LOGIC_OP_XOR,
    Or = VK_LOGIC_OP_OR,
    Nor = VK_LOGIC_OP_NOR,
    Equivalent = VK_LOGIC_OP_EQUIVALENT,
    Invert = VK_LOGIC_OP_INVERT,
    OrReverse = VK_LOGIC_OP_OR_REVERSE,
    CopyInverted = VK_LOGIC_OP_COPY_INVERTED,
    OrInverted = VK_LOGIC_OP_OR_INVERTED,
    Nand = VK_LOGIC_OP_NAND,
    Set = VK_LOGIC_OP_SET,
    MaxEnum = VK_LOGIC_OP_MAX_ENUM
};

enum class MemoryAllocateFlags : u32 {
    DeviceMask = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT,
    DeviceAddress = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT,
    DeviceAddressCaptureReplay = VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT,
    FlagsMaxEnum = VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(MemoryAllocateFlags);

enum class MemoryHeapFlags : u32 {
    DeviceLocal = VK_MEMORY_HEAP_DEVICE_LOCAL_BIT,
    MultiInstance = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT,
    TileMemoryQcom = VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM,
    FlagsMaxEnum = VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(MemoryHeapFlags);

enum class MemoryMapFlags : u32 {
    PlacedExt = VK_MEMORY_MAP_PLACED_BIT_EXT,
    FlagsMaxEnum = VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(MemoryMapFlags);

enum class MemoryOverallocationBehaviorAMD : u32 {
    DefaultAmd = VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD,
    AllowedAmd = VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD,
    DisallowedAmd = VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD,
    MaxEnumAmd = VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD
};

enum class MemoryPropertyFlags : u32 {
    DeviceLocal = VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
    HostVisible = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
    HostCoherent = VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,
    HostCached = VK_MEMORY_PROPERTY_HOST_CACHED_BIT,
    LazilyAllocated = VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT,
    Protected = VK_MEMORY_PROPERTY_PROTECTED_BIT,
    DeviceCoherentAmd = VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD,
    DeviceUncachedAmd = VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD,
    RdmaCapableNv = VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV,
    FlagsMaxEnum = VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(MemoryPropertyFlags);

enum class MemoryUnmapFlags : u32 {
    ReserveExt = VK_MEMORY_UNMAP_RESERVE_BIT_EXT,
    FlagsMaxEnum = VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(MemoryUnmapFlags);

enum class MicromapCreateFlagsEXT : u32 {
    DeviceAddressCaptureReplayExt = VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT,
    FlagsMaxEnumExt = VK_MICROMAP_CREATE_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(MicromapCreateFlagsEXT);

enum class MicromapTypeEXT : u32 {
    OpacityMicromapExt = VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT,
    MaxEnumExt = VK_MICROMAP_TYPE_MAX_ENUM_EXT
};

enum class ObjectType : u32 {
    Unknown = VK_OBJECT_TYPE_UNKNOWN,
    Instance = VK_OBJECT_TYPE_INSTANCE,
    PhysicalDevice = VK_OBJECT_TYPE_PHYSICAL_DEVICE,
    Device = VK_OBJECT_TYPE_DEVICE,
    Queue = VK_OBJECT_TYPE_QUEUE,
    Semaphore = VK_OBJECT_TYPE_SEMAPHORE,
    CommandBuffer = VK_OBJECT_TYPE_COMMAND_BUFFER,
    Fence = VK_OBJECT_TYPE_FENCE,
    DeviceMemory = VK_OBJECT_TYPE_DEVICE_MEMORY,
    Buffer = VK_OBJECT_TYPE_BUFFER,
    Image = VK_OBJECT_TYPE_IMAGE,
    Event = VK_OBJECT_TYPE_EVENT,
    QueryPool = VK_OBJECT_TYPE_QUERY_POOL,
    BufferView = VK_OBJECT_TYPE_BUFFER_VIEW,
    ImageView = VK_OBJECT_TYPE_IMAGE_VIEW,
    ShaderModule = VK_OBJECT_TYPE_SHADER_MODULE,
    PipelineCache = VK_OBJECT_TYPE_PIPELINE_CACHE,
    PipelineLayout = VK_OBJECT_TYPE_PIPELINE_LAYOUT,
    RenderPass = VK_OBJECT_TYPE_RENDER_PASS,
    Pipeline = VK_OBJECT_TYPE_PIPELINE,
    DescriptorSetLayout = VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT,
    Sampler = VK_OBJECT_TYPE_SAMPLER,
    DescriptorPool = VK_OBJECT_TYPE_DESCRIPTOR_POOL,
    DescriptorSet = VK_OBJECT_TYPE_DESCRIPTOR_SET,
    Framebuffer = VK_OBJECT_TYPE_FRAMEBUFFER,
    CommandPool = VK_OBJECT_TYPE_COMMAND_POOL,
    SamplerYcbcrConversion = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    DescriptorUpdateTemplate = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    PrivateDataSlot = VK_OBJECT_TYPE_PRIVATE_DATA_SLOT,
    SurfaceKhr = VK_OBJECT_TYPE_SURFACE_KHR,
    SwapchainKhr = VK_OBJECT_TYPE_SWAPCHAIN_KHR,
    DisplayKhr = VK_OBJECT_TYPE_DISPLAY_KHR,
    DisplayModeKhr = VK_OBJECT_TYPE_DISPLAY_MODE_KHR,
    DebugReportCallbackExt = VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT,
    VideoSessionKhr = VK_OBJECT_TYPE_VIDEO_SESSION_KHR,
    VideoSessionParametersKhr = VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR,
    CuModuleNvx = VK_OBJECT_TYPE_CU_MODULE_NVX,
    CuFunctionNvx = VK_OBJECT_TYPE_CU_FUNCTION_NVX,
    DebugUtilsMessengerExt = VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT,
    AccelerationStructureKhr = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR,
    ValidationCacheExt = VK_OBJECT_TYPE_VALIDATION_CACHE_EXT,
    AccelerationStructureNv = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV,
    PerformanceConfigurationIntel = VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL,
    DeferredOperationKhr = VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR,
    IndirectCommandsLayoutNv = VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV,
    BufferCollectionFuchsia = VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA,
    MicromapExt = VK_OBJECT_TYPE_MICROMAP_EXT,
    OpticalFlowSessionNv = VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV,
    ShaderExt = VK_OBJECT_TYPE_SHADER_EXT,
    PipelineBinaryKhr = VK_OBJECT_TYPE_PIPELINE_BINARY_KHR,
    ExternalComputeQueueNv = VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV,
    IndirectCommandsLayoutExt = VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT,
    IndirectExecutionSetExt = VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT,
    MaxEnum = VK_OBJECT_TYPE_MAX_ENUM
};

enum class OpacityMicromapFormatEXT : u32 {
    2StateExt = VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT,
    4StateExt = VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT,
    MaxEnumExt = VK_OPACITY_MICROMAP_FORMAT_MAX_ENUM_EXT
};

enum class OpacityMicromapSpecialIndexEXT : u32 {
    FullyTransparentExt = VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT,
    FullyOpaqueExt = VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT,
    FullyUnknownTransparentExt = VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT,
    FullyUnknownOpaqueExt = VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT,
    ClusterGeometryDisableOpacityMicromapNv = VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV,
    MaxEnumExt = VK_OPACITY_MICROMAP_SPECIAL_INDEX_MAX_ENUM_EXT
};

enum class OpticalFlowExecuteFlagsNV : u32 {
    DisableTemporalHintsNv = VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV,
    FlagsMaxEnumNv = VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(OpticalFlowExecuteFlagsNV);

enum class OpticalFlowGridSizeFlagsNV : u32 {
    UnknownNv = VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV,
    1x1Nv = VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV,
    2x2Nv = VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV,
    4x4Nv = VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV,
    8x8Nv = VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV,
    FlagsMaxEnumNv = VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(OpticalFlowGridSizeFlagsNV);

enum class OpticalFlowPerformanceLevelNV : u32 {
    UnknownNv = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV,
    SlowNv = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV,
    MediumNv = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV,
    FastNv = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV,
    MaxEnumNv = VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MAX_ENUM_NV
};

enum class OpticalFlowSessionBindingPointNV : u32 {
    UnknownNv = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV,
    InputNv = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV,
    ReferenceNv = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV,
    HintNv = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV,
    FlowVectorNv = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV,
    BackwardFlowVectorNv = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV,
    CostNv = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV,
    BackwardCostNv = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV,
    GlobalFlowNv = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV,
    MaxEnumNv = VK_OPTICAL_FLOW_SESSION_BINDING_POINT_MAX_ENUM_NV
};

enum class OpticalFlowSessionCreateFlagsNV : u32 {
    EnableHintNv = VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV,
    EnableCostNv = VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV,
    EnableGlobalFlowNv = VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV,
    AllowRegionsNv = VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV,
    BothDirectionsNv = VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV,
    FlagsMaxEnumNv = VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(OpticalFlowSessionCreateFlagsNV);

enum class OpticalFlowUsageFlagsNV : u32 {
    UnknownNv = VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV,
    InputNv = VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV,
    OutputNv = VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV,
    HintNv = VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV,
    CostNv = VK_OPTICAL_FLOW_USAGE_COST_BIT_NV,
    GlobalFlowNv = VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV,
    FlagsMaxEnumNv = VK_OPTICAL_FLOW_USAGE_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(OpticalFlowUsageFlagsNV);

enum class OutOfBandQueueTypeNV : u32 {
    RenderNv = VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV,
    PresentNv = VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV,
    MaxEnumNv = VK_OUT_OF_BAND_QUEUE_TYPE_MAX_ENUM_NV
};

enum class PartitionedAccelerationStructureInstanceFlagsNV : u32 {
    TriangleFacingCullDisableNv = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV,
    TriangleFlipFacingNv = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV,
    ForceOpaqueNv = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV,
    ForceNoOpaqueNv = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV,
    EnableExplicitBoundingBoxNv = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV,
    BitsMaxEnumNv = VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_BITS_MAX_ENUM_NV
};
ENABLE_BITMASK_OPERATORS(PartitionedAccelerationStructureInstanceFlagsNV);

enum class PartitionedAccelerationStructureOpTypeNV : u32 {
    WriteInstanceNv = VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV,
    UpdateInstanceNv = VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV,
    WritePartitionTranslationNv = VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV,
    MaxEnumNv = VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_MAX_ENUM_NV
};

enum class PeerMemoryFeatureFlags : u32 {
    CopySrc = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    CopyDst = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    GenericSrc = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    GenericDst = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT,
    FlagsMaxEnum = VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(PeerMemoryFeatureFlags);

enum class PerformanceConfigurationTypeINTEL : u32 {
    CommandQueueMetricsDiscoveryActivatedIntel = VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL,
    MaxEnumIntel = VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL
};

enum class PerformanceCounterDescriptionFlagsKHR : u32 {
    PerformanceImpactingKhr = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR,
    ConcurrentlyImpactedKhr = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR,
    FlagsMaxEnumKhr = VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(PerformanceCounterDescriptionFlagsKHR);

enum class PerformanceCounterScopeKHR : u32 {
    CommandBufferKhr = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR,
    RenderPassKhr = VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR,
    CommandKhr = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR,
    MaxEnumKhr = VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR
};

enum class PerformanceCounterStorageKHR : u32 {
    Int32Khr = VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR,
    Int64Khr = VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR,
    Uint32Khr = VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR,
    Uint64Khr = VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR,
    Float32Khr = VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR,
    Float64Khr = VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR,
    MaxEnumKhr = VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR
};

enum class PerformanceCounterUnitKHR : u32 {
    GenericKhr = VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR,
    PercentageKhr = VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR,
    NanosecondsKhr = VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR,
    BytesKhr = VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR,
    BytesPerSecondKhr = VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR,
    KelvinKhr = VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR,
    WattsKhr = VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR,
    VoltsKhr = VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR,
    AmpsKhr = VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR,
    HertzKhr = VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR,
    CyclesKhr = VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR,
    MaxEnumKhr = VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR
};

enum class PerformanceOverrideTypeINTEL : u32 {
    NullHardwareIntel = VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL,
    FlushGpuCachesIntel = VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL,
    MaxEnumIntel = VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL
};

enum class PerformanceParameterTypeINTEL : u32 {
    HwCountersSupportedIntel = VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL,
    StreamMarkerValidsIntel = VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL,
    MaxEnumIntel = VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL
};

enum class PerformanceValueTypeINTEL : u32 {
    Uint32Intel = VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL,
    Uint64Intel = VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL,
    FloatIntel = VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL,
    BoolIntel = VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL,
    StringIntel = VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL,
    MaxEnumIntel = VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL
};

enum class PhysicalDeviceLayeredApiKHR : u32 {
    VulkanKhr = VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR,
    D3d12Khr = VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR,
    MetalKhr = VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR,
    OpenglKhr = VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR,
    OpenglesKhr = VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR,
    MaxEnumKhr = VK_PHYSICAL_DEVICE_LAYERED_API_MAX_ENUM_KHR
};

enum class PhysicalDeviceType : u32 {
    Other = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    IntegratedGpu = VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU,
    DiscreteGpu = VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU,
    VirtualGpu = VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU,
    Cpu = VK_PHYSICAL_DEVICE_TYPE_CPU,
    MaxEnum = VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM
};

enum class PipelineBindPoint : u32 {
    Graphics = VK_PIPELINE_BIND_POINT_GRAPHICS,
    Compute = VK_PIPELINE_BIND_POINT_COMPUTE,
    RayTracingKhr = VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR,
    SubpassShadingHuawei = VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI,
    MaxEnum = VK_PIPELINE_BIND_POINT_MAX_ENUM
};

enum class PipelineCacheCreateFlags : u32 {
    ExternallySynchronized = VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT,
    InternallySynchronizedMergeKhr = VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR,
    FlagsMaxEnum = VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(PipelineCacheCreateFlags);

enum class PipelineCacheHeaderVersion : u32 {
    One = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    MaxEnum = VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM
};

enum class PipelineColorBlendStateCreateFlags : u32 {
    RasterizationOrderAttachmentAccessExt = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT,
    FlagsMaxEnum = VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(PipelineColorBlendStateCreateFlags);

enum class PipelineCompilerControlFlagBitsAMD : u32 {
    VkPipelineCompilerControlFlagsMaxEnumAmd = VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD
};

enum class PipelineCreateFlags : u32 {
    DisableOptimization = VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT,
    AllowDerivatives = VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT,
    Derivative = VK_PIPELINE_CREATE_DERIVATIVE_BIT,
    ViewIndexFromDeviceIndex = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    DispatchBase = VK_PIPELINE_CREATE_DISPATCH_BASE_BIT,
    FailOnPipelineCompileRequired = VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT,
    EarlyReturnOnFailure = VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT,
    NoProtectedAccess = VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT,
    ProtectedAccessOnly = VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT,
    RayTracingNoNullAnyHitShadersKhr = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR,
    RayTracingNoNullClosestHitShadersKhr = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR,
    RayTracingNoNullMissShadersKhr = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR,
    RayTracingNoNullIntersectionShadersKhr = VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR,
    RayTracingSkipTrianglesKhr = VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR,
    RayTracingSkipAabbsKhr = VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR,
    RayTracingShaderGroupHandleCaptureReplayKhr = VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR,
    DeferCompileNv = VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV,
    RenderingFragmentDensityMapAttachmentExt = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
    RenderingFragmentShadingRateAttachmentKhr = VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    CaptureStatisticsKhr = VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR,
    CaptureInternalRepresentationsKhr = VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR,
    IndirectBindableNv = VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV,
    LibraryKhr = VK_PIPELINE_CREATE_LIBRARY_BIT_KHR,
    DescriptorBufferExt = VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT,
    RetainLinkTimeOptimizationInfoExt = VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT,
    LinkTimeOptimizationExt = VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT,
    RayTracingAllowMotionNv = VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV,
    ColorAttachmentFeedbackLoopExt = VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT,
    DepthStencilAttachmentFeedbackLoopExt = VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT,
    RayTracingOpacityMicromapExt = VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT,
    DispatchBase = VK_PIPELINE_CREATE_DISPATCH_BASE,
    FlagsMaxEnum = VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(PipelineCreateFlags);

enum class PipelineCreationFeedbackFlags : u32 {
    Valid = VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT,
    ApplicationPipelineCacheHit = VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT,
    BasePipelineAcceleration = VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT,
    FlagsMaxEnum = VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(PipelineCreationFeedbackFlags);

enum class PipelineDepthStencilStateCreateFlags : u32 {
    RasterizationOrderAttachmentDepthAccessExt = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
    RasterizationOrderAttachmentStencilAccessExt = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
    FlagsMaxEnum = VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(PipelineDepthStencilStateCreateFlags);

enum class PipelineExecutableStatisticFormatKHR : u32 {
    Bool32Khr = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR,
    Int64Khr = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR,
    Uint64Khr = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR,
    Float64Khr = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR,
    MaxEnumKhr = VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR
};

enum class PipelineLayoutCreateFlags : u32 {
    IndependentSetsExt = VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT,
    FlagsMaxEnum = VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(PipelineLayoutCreateFlags);

enum class PipelineRobustnessBufferBehavior : u32 {
    DeviceDefault = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT,
    Disabled = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED,
    RobustBufferAccess = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS,
    RobustBufferAccess2 = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2,
    MaxEnum = VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM
};

enum class PipelineRobustnessImageBehavior : u32 {
    DeviceDefault = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT,
    Disabled = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED,
    RobustImageAccess = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS,
    RobustImageAccess2 = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2,
    MaxEnum = VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM
};

enum class PipelineShaderStageCreateFlags : u32 {
    AllowVaryingSubgroupSize = VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT,
    RequireFullSubgroups = VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT,
    FlagsMaxEnum = VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(PipelineShaderStageCreateFlags);

enum class PipelineStageFlags : u32 {
    TopOfPipe = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
    DrawIndirect = VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT,
    VertexInput = VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,
    VertexShader = VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,
    TessellationControlShader = VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT,
    TessellationEvaluationShader = VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT,
    GeometryShader = VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT,
    FragmentShader = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
    EarlyFragmentTests = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT,
    LateFragmentTests = VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
    ColorAttachmentOutput = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,
    ComputeShader = VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
    Transfer = VK_PIPELINE_STAGE_TRANSFER_BIT,
    BottomOfPipe = VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
    Host = VK_PIPELINE_STAGE_HOST_BIT,
    AllGraphics = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
    AllCommands = VK_PIPELINE_STAGE_ALL_COMMANDS_BIT,
    None = VK_PIPELINE_STAGE_NONE,
    TransformFeedbackExt = VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT,
    ConditionalRenderingExt = VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT,
    AccelerationStructureBuildKhr = VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR,
    RayTracingShaderKhr = VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR,
    FragmentDensityProcessExt = VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT,
    FragmentShadingRateAttachmentKhr = VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR,
    TaskShaderExt = VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT,
    MeshShaderExt = VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT,
    CommandPreprocessExt = VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT,
    FlagsMaxEnum = VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(PipelineStageFlags);

enum class PointClippingBehavior : u32 {
    AllClipPlanes = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    UserClipPlanesOnly = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY,
    MaxEnum = VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM
};

enum class PolygonMode : u32 {
    Fill = VK_POLYGON_MODE_FILL,
    Line = VK_POLYGON_MODE_LINE,
    Point = VK_POLYGON_MODE_POINT,
    FillRectangleNv = VK_POLYGON_MODE_FILL_RECTANGLE_NV,
    MaxEnum = VK_POLYGON_MODE_MAX_ENUM
};

enum class PresentGravityFlagsEXT : u32 {
    MinExt = VK_PRESENT_GRAVITY_MIN_BIT_EXT,
    MaxExt = VK_PRESENT_GRAVITY_MAX_BIT_EXT,
    CenteredExt = VK_PRESENT_GRAVITY_CENTERED_BIT_EXT,
    FlagsMaxEnumExt = VK_PRESENT_GRAVITY_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(PresentGravityFlagsEXT);

enum class PresentModeKHR : u32 {
    ImmediateKhr = VK_PRESENT_MODE_IMMEDIATE_KHR,
    MailboxKhr = VK_PRESENT_MODE_MAILBOX_KHR,
    FifoKhr = VK_PRESENT_MODE_FIFO_KHR,
    FifoRelaxedKhr = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    SharedDemandRefreshKhr = VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR,
    SharedContinuousRefreshKhr = VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR,
    FifoLatestReadyExt = VK_PRESENT_MODE_FIFO_LATEST_READY_EXT,
    MaxEnumKhr = VK_PRESENT_MODE_MAX_ENUM_KHR
};

enum class PresentScalingFlagsEXT : u32 {
    OneToOneExt = VK_PRESENT_SCALING_ONE_TO_ONE_BIT_EXT,
    AspectRatioStretchExt = VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_EXT,
    StretchExt = VK_PRESENT_SCALING_STRETCH_BIT_EXT,
    FlagsMaxEnumExt = VK_PRESENT_SCALING_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(PresentScalingFlagsEXT);

enum class PrimitiveTopology : u32 {
    PointList = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    LineList = VK_PRIMITIVE_TOPOLOGY_LINE_LIST,
    LineStrip = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP,
    TriangleList = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST,
    TriangleStrip = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP,
    TriangleFan = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN,
    LineListWithAdjacency = VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY,
    LineStripWithAdjacency = VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY,
    TriangleListWithAdjacency = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY,
    TriangleStripWithAdjacency = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY,
    PatchList = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    MaxEnum = VK_PRIMITIVE_TOPOLOGY_MAX_ENUM
};

enum class ProvokingVertexModeEXT : u32 {
    FirstVertexExt = VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT,
    LastVertexExt = VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT,
    MaxEnumExt = VK_PROVOKING_VERTEX_MODE_MAX_ENUM_EXT
};

enum class QueryControlFlags : u32 {
    Precise = VK_QUERY_CONTROL_PRECISE_BIT,
    FlagsMaxEnum = VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(QueryControlFlags);

enum class QueryPipelineStatisticFlags : u32 {
    InputAssemblyVertices = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT,
    InputAssemblyPrimitives = VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT,
    VertexShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT,
    GeometryShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT,
    GeometryShaderPrimitives = VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT,
    ClippingInvocations = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT,
    ClippingPrimitives = VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT,
    FragmentShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT,
    TessellationControlShaderPatches = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT,
    TessellationEvaluationShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT,
    ComputeShaderInvocations = VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT,
    TaskShaderInvocationsExt = VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT,
    MeshShaderInvocationsExt = VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT,
    ClusterCullingShaderInvocationsHuawei = VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI,
    FlagsMaxEnum = VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(QueryPipelineStatisticFlags);

enum class QueryPoolSamplingModeINTEL : u32 {
    NualIntel = VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL,
    XEnumIntel = VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL
};

enum class QueryResultFlags : u32 {
    64 = VK_QUERY_RESULT_64_BIT,
    Wait = VK_QUERY_RESULT_WAIT_BIT,
    WithAvailability = VK_QUERY_RESULT_WITH_AVAILABILITY_BIT,
    Partial = VK_QUERY_RESULT_PARTIAL_BIT,
    WithStatusKhr = VK_QUERY_RESULT_WITH_STATUS_BIT_KHR,
    FlagsMaxEnum = VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(QueryResultFlags);

enum class QueryResultStatusKHR : u32 {
    ErrorKhr = VK_QUERY_RESULT_STATUS_ERROR_KHR,
    NotReadyKhr = VK_QUERY_RESULT_STATUS_NOT_READY_KHR,
    CompleteKhr = VK_QUERY_RESULT_STATUS_COMPLETE_KHR,
    InsufficientstreamBufferRangeKhr = VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR,
    MaxEnumKhr = VK_QUERY_RESULT_STATUS_MAX_ENUM_KHR
};

enum class QueryType : u32 {
    Occlusion = VK_QUERY_TYPE_OCCLUSION,
    PipelineStatistics = VK_QUERY_TYPE_PIPELINE_STATISTICS,
    Timestamp = VK_QUERY_TYPE_TIMESTAMP,
    ResultStatusOnlyKhr = VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR,
    TransformFeedbackStreamExt = VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT,
    PerformanceQueryKhr = VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR,
    AccelerationStructureCompactedSizeKhr = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR,
    AccelerationStructureSerializationSizeKhr = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR,
    AccelerationStructureCompactedSizeNv = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV,
    PerformanceQueryIntel = VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL,
    VideoEncodeFeedbackKhr = VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR,
    MeshPrimitivesGeneratedExt = VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT,
    PrimitivesGeneratedExt = VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT,
    AccelerationStructureSerializationBottomLevelPointersKhr = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR,
    AccelerationStructureSizeKhr = VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR,
    MicromapSerializationSizeExt = VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT,
    MicromapCompactedSizeExt = VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT,
    MaxEnum = VK_QUERY_TYPE_MAX_ENUM
};

enum class QueueFlags : u32 {
    Graphics = VK_QUEUE_GRAPHICS_BIT,
    Compute = VK_QUEUE_COMPUTE_BIT,
    Transfer = VK_QUEUE_TRANSFER_BIT,
    SparseBinding = VK_QUEUE_SPARSE_BINDING_BIT,
    Protected = VK_QUEUE_PROTECTED_BIT,
    VideoDecodeKhr = VK_QUEUE_VIDEO_DECODE_BIT_KHR,
    VideoEncodeKhr = VK_QUEUE_VIDEO_ENCODE_BIT_KHR,
    OpticalFlowNv = VK_QUEUE_OPTICAL_FLOW_BIT_NV,
    FlagsMaxEnum = VK_QUEUE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(QueueFlags);

enum class QueueGlobalPriority : u32 {
    Low = VK_QUEUE_GLOBAL_PRIORITY_LOW,
    Medium = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM,
    High = VK_QUEUE_GLOBAL_PRIORITY_HIGH,
    Realtime = VK_QUEUE_GLOBAL_PRIORITY_REALTIME,
    MaxEnum = VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM
};

enum class RasterizationOrderAMD : u32 {
    StrictAmd = VK_RASTERIZATION_ORDER_STRICT_AMD,
    RelaxedAmd = VK_RASTERIZATION_ORDER_RELAXED_AMD,
    MaxEnumAmd = VK_RASTERIZATION_ORDER_MAX_ENUM_AMD
};

enum class RayTracingInvocationReorderModeNV : u32 {
    NoneNv = VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV,
    ReorderNv = VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV,
    MaxEnumNv = VK_RAY_TRACING_INVOCATION_REORDER_MODE_MAX_ENUM_NV
};

enum class RayTracingLssIndexingModeNV : u32 {
    ListNv = VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV,
    SuccessiveNv = VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV,
    MaxEnumNv = VK_RAY_TRACING_LSS_INDEXING_MODE_MAX_ENUM_NV
};

enum class RayTracingLssPrimitiveEndCapsModeNV : u32 {
    NoneNv = VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV,
    ChainedNv = VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV,
    MaxEnumNv = VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_MAX_ENUM_NV
};

enum class RayTracingShaderGroupTypeKHR : u32 {
    GeneralKhr = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR,
    TrianglesHitGroupKhr = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR,
    ProceduralHitGroupKhr = VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR,
    MaxEnumKhr = VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_KHR
};

enum class RenderPassCreateFlags : u32 {
    TransformQcom = VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM,
    FlagsMaxEnum = VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(RenderPassCreateFlags);

enum class RenderingFlags : u32 {
    ContentsSecondaryCommandBuffers = VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT,
    Suspending = VK_RENDERING_SUSPENDING_BIT,
    Resuming = VK_RENDERING_RESUMING_BIT,
    EnableLegacyDitheringExt = VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT,
    ContentsInlineKhr = VK_RENDERING_CONTENTS_INLINE_BIT_KHR,
    FlagsMaxEnum = VK_RENDERING_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(RenderingFlags);

enum class ResolveModeFlags : u32 {
    None = VK_RESOLVE_MODE_NONE,
    SampleZero = VK_RESOLVE_MODE_SAMPLE_ZERO_BIT,
    Average = VK_RESOLVE_MODE_AVERAGE_BIT,
    Min = VK_RESOLVE_MODE_MIN_BIT,
    Max = VK_RESOLVE_MODE_MAX_BIT,
    ExternalFormatDownsampleAndroid = VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID,
    FlagsMaxEnum = VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ResolveModeFlags);

enum class SampleCountFlags : u32 {
    1 = VK_SAMPLE_COUNT_1_BIT,
    2 = VK_SAMPLE_COUNT_2_BIT,
    4 = VK_SAMPLE_COUNT_4_BIT,
    8 = VK_SAMPLE_COUNT_8_BIT,
    16 = VK_SAMPLE_COUNT_16_BIT,
    32 = VK_SAMPLE_COUNT_32_BIT,
    64 = VK_SAMPLE_COUNT_64_BIT,
    FlagsMaxEnum = VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(SampleCountFlags);

enum class SamplerAddressMode : u32 {
    Repeat = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    MirroredRepeat = VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT,
    ClampToEdge = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,
    ClampToBorder = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER,
    MirrorClampToEdge = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
    MaxEnum = VK_SAMPLER_ADDRESS_MODE_MAX_ENUM
};

enum class SamplerCreateFlags : u32 {
    SubsampledExt = VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT,
    SubsampledCoarseReconstructionExt = VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT,
    DescriptorBufferCaptureReplayExt = VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT,
    NonSeamlessCubeMapExt = VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT,
    ImageProcessingQcom = VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM,
    FlagsMaxEnum = VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(SamplerCreateFlags);

enum class SamplerMipmapMode : u32 {
    Nearest = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    Linear = VK_SAMPLER_MIPMAP_MODE_LINEAR,
    MaxEnum = VK_SAMPLER_MIPMAP_MODE_MAX_ENUM
};

enum class SamplerReductionMode : u32 {
    WeightedAverage = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE,
    Min = VK_SAMPLER_REDUCTION_MODE_MIN,
    Max = VK_SAMPLER_REDUCTION_MODE_MAX,
    WeightedAverageRangeclampQcom = VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM,
    MaxEnum = VK_SAMPLER_REDUCTION_MODE_MAX_ENUM
};

enum class SamplerYcbcrModelConversion : u32 {
    RgbIdentity = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    YcbcrIdentity = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    Ycbcr709 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    Ycbcr601 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    Ycbcr2020 = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020,
    MaxEnum = VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM
};

enum class SamplerYcbcrRange : u32 {
    ItuFull = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    ItuNarrow = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW,
    MaxEnum = VK_SAMPLER_YCBCR_RANGE_MAX_ENUM
};

enum class ScopeKHR : u32 {
    DeviceKhr = VK_SCOPE_DEVICE_KHR,
    WorkgroupKhr = VK_SCOPE_WORKGROUP_KHR,
    SubgroupKhr = VK_SCOPE_SUBGROUP_KHR,
    QueueFamilyKhr = VK_SCOPE_QUEUE_FAMILY_KHR,
    MaxEnumKhr = VK_SCOPE_MAX_ENUM_KHR
};

enum class SemaphoreImportFlags : u32 {
    Temporary = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT,
    FlagsMaxEnum = VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(SemaphoreImportFlags);

enum class SemaphoreType : u32 {
    Binary = VK_SEMAPHORE_TYPE_BINARY,
    Timeline = VK_SEMAPHORE_TYPE_TIMELINE,
    MaxEnum = VK_SEMAPHORE_TYPE_MAX_ENUM
};

enum class SemaphoreWaitFlags : u32 {
    Any = VK_SEMAPHORE_WAIT_ANY_BIT,
    FlagsMaxEnum = VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(SemaphoreWaitFlags);

enum class ShaderCodeTypeEXT : u32 {
    BinaryExt = VK_SHADER_CODE_TYPE_BINARY_EXT,
    SpirvExt = VK_SHADER_CODE_TYPE_SPIRV_EXT,
    MaxEnumExt = VK_SHADER_CODE_TYPE_MAX_ENUM_EXT
};

enum class ShaderCorePropertiesFlagBitsAMD : u32 {
    VkShaderCorePropertiesFlagsMaxEnumAmd = VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD
};

enum class ShaderCreateFlagsEXT : u32 {
    LinkStageExt = VK_SHADER_CREATE_LINK_STAGE_BIT_EXT,
    AllowVaryingSubgroupSizeExt = VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT,
    RequireFullSubgroupsExt = VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT,
    NoTaskShaderExt = VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT,
    DispatchBaseExt = VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT,
    FragmentShadingRateAttachmentExt = VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT,
    FragmentDensityMapAttachmentExt = VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT,
    IndirectBindableExt = VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT,
    FlagsMaxEnumExt = VK_SHADER_CREATE_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(ShaderCreateFlagsEXT);

enum class ShaderFloatControlsIndependence : u32 {
    32Only = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY,
    All = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL,
    None = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE,
    MaxEnum = VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM
};

enum class ShaderGroupShaderKHR : u32 {
    GeneralKhr = VK_SHADER_GROUP_SHADER_GENERAL_KHR,
    ClosestHitKhr = VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR,
    AnyHitKhr = VK_SHADER_GROUP_SHADER_ANY_HIT_KHR,
    IntersectionKhr = VK_SHADER_GROUP_SHADER_INTERSECTION_KHR,
    MaxEnumKhr = VK_SHADER_GROUP_SHADER_MAX_ENUM_KHR
};

enum class ShaderInfoTypeAMD : u32 {
    StatisticsAmd = VK_SHADER_INFO_TYPE_STATISTICS_AMD,
    BinaryAmd = VK_SHADER_INFO_TYPE_BINARY_AMD,
    DisassemblyAmd = VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    MaxEnumAmd = VK_SHADER_INFO_TYPE_MAX_ENUM_AMD
};

enum class ShaderStageFlags : u32 {
    Vertex = VK_SHADER_STAGE_VERTEX_BIT,
    TessellationControl = VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    TessellationEvaluation = VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    Geometry = VK_SHADER_STAGE_GEOMETRY_BIT,
    Fragment = VK_SHADER_STAGE_FRAGMENT_BIT,
    Compute = VK_SHADER_STAGE_COMPUTE_BIT,
    AllGraphics = VK_SHADER_STAGE_ALL_GRAPHICS,
    All = VK_SHADER_STAGE_ALL,
    RaygenKhr = VK_SHADER_STAGE_RAYGEN_BIT_KHR,
    AnyHitKhr = VK_SHADER_STAGE_ANY_HIT_BIT_KHR,
    ClosestHitKhr = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR,
    MissKhr = VK_SHADER_STAGE_MISS_BIT_KHR,
    IntersectionKhr = VK_SHADER_STAGE_INTERSECTION_BIT_KHR,
    CallableKhr = VK_SHADER_STAGE_CALLABLE_BIT_KHR,
    TaskExt = VK_SHADER_STAGE_TASK_BIT_EXT,
    MeshExt = VK_SHADER_STAGE_MESH_BIT_EXT,
    SubpassShadingHuawei = VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI,
    ClusterCullingHuawei = VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI,
    FlagsMaxEnum = VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ShaderStageFlags);

enum class ShadingRatePaletteEntryNV : u32 {
    NoInvocationsNv = VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV,
    16InvocationsPerPixelNv = VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV,
    8InvocationsPerPixelNv = VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV,
    4InvocationsPerPixelNv = VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV,
    2InvocationsPerPixelNv = VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV,
    1InvocationPerPixelNv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV,
    1InvocationPer2x1PixelsNv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV,
    1InvocationPer1x2PixelsNv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV,
    1InvocationPer2x2PixelsNv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV,
    1InvocationPer4x2PixelsNv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV,
    1InvocationPer2x4PixelsNv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV,
    1InvocationPer4x4PixelsNv = VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV,
    MaxEnumNv = VK_SHADING_RATE_PALETTE_ENTRY_MAX_ENUM_NV
};

enum class SharingMode : u32 {
    Exclusive = VK_SHARING_MODE_EXCLUSIVE,
    Concurrent = VK_SHARING_MODE_CONCURRENT,
    MaxEnum = VK_SHARING_MODE_MAX_ENUM
};

enum class SparseImageFormatFlags : u32 {
    SingleMiptail = VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT,
    AlignedMipSize = VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT,
    NonstandardBlockSize = VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT,
    FlagsMaxEnum = VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(SparseImageFormatFlags);

enum class SparseMemoryBindFlags : u32 {
    Metadata = VK_SPARSE_MEMORY_BIND_METADATA_BIT,
    FlagsMaxEnum = VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(SparseMemoryBindFlags);

enum class StencilFaceFlags : u32 {
    Front = VK_STENCIL_FACE_FRONT_BIT,
    Back = VK_STENCIL_FACE_BACK_BIT,
    FrontAndBack = VK_STENCIL_FACE_FRONT_AND_BACK,
    FlagsMaxEnum = VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(StencilFaceFlags);

enum class StencilOp : u32 {
    Keep = VK_STENCIL_OP_KEEP,
    Zero = VK_STENCIL_OP_ZERO,
    Replace = VK_STENCIL_OP_REPLACE,
    IncrementAndClamp = VK_STENCIL_OP_INCREMENT_AND_CLAMP,
    DecrementAndClamp = VK_STENCIL_OP_DECREMENT_AND_CLAMP,
    Invert = VK_STENCIL_OP_INVERT,
    IncrementAndWrap = VK_STENCIL_OP_INCREMENT_AND_WRAP,
    DecrementAndWrap = VK_STENCIL_OP_DECREMENT_AND_WRAP,
    MaxEnum = VK_STENCIL_OP_MAX_ENUM
};

enum class SubgroupFeatureFlags : u32 {
    Basic = VK_SUBGROUP_FEATURE_BASIC_BIT,
    Vote = VK_SUBGROUP_FEATURE_VOTE_BIT,
    Arithmetic = VK_SUBGROUP_FEATURE_ARITHMETIC_BIT,
    Ballot = VK_SUBGROUP_FEATURE_BALLOT_BIT,
    Shuffle = VK_SUBGROUP_FEATURE_SHUFFLE_BIT,
    ShuffleRelative = VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT,
    Clustered = VK_SUBGROUP_FEATURE_CLUSTERED_BIT,
    Quad = VK_SUBGROUP_FEATURE_QUAD_BIT,
    Rotate = VK_SUBGROUP_FEATURE_ROTATE_BIT,
    RotateClustered = VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT,
    PartitionedNv = VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV,
    FlagsMaxEnum = VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(SubgroupFeatureFlags);

enum class SubmitFlags : u32 {
    Protected = VK_SUBMIT_PROTECTED_BIT,
    FlagsMaxEnum = VK_SUBMIT_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(SubmitFlags);

enum class SubpassContents : u32 {
    Inline = VK_SUBPASS_CONTENTS_INLINE,
    SecondaryCommandBuffers = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    InlineAndSecondaryCommandBuffersKhr = VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR,
    MaxEnum = VK_SUBPASS_CONTENTS_MAX_ENUM
};

enum class SubpassDescriptionFlags : u32 {
    PerViewAttributesNvx = VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX,
    PerViewPositionXOnlyNvx = VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX,
    FragmentRegionQcom = VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM,
    ShaderResolveQcom = VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM,
    TileShadingApronQcom = VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM,
    RasterizationOrderAttachmentColorAccessExt = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT,
    RasterizationOrderAttachmentDepthAccessExt = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT,
    RasterizationOrderAttachmentStencilAccessExt = VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT,
    EnableLegacyDitheringExt = VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT,
    FlagsMaxEnum = VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(SubpassDescriptionFlags);

enum class SubpassMergeStatusEXT : u32 {
    MergedExt = VK_SUBPASS_MERGE_STATUS_MERGED_EXT,
    DisallowedExt = VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT,
    NotMergedSideEffectsExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT,
    NotMergedSamplesMismatchExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT,
    NotMergedViewsMismatchExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT,
    NotMergedAliasingExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT,
    NotMergedDependenciesExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT,
    NotMergedIncompatibleInputAttachmentExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT,
    NotMergedTooManyAttachmentsExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT,
    NotMergedInsufficientStorageExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT,
    NotMergedDepthStencilCountExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT,
    NotMergedResolveAttachmentReuseExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT,
    NotMergedSingleSubpassExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT,
    NotMergedUnspecifiedExt = VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT,
    MaxEnumExt = VK_SUBPASS_MERGE_STATUS_MAX_ENUM_EXT
};

enum class SurfaceCounterFlagsEXT : u32 {
    VblankExt = VK_SURFACE_COUNTER_VBLANK_BIT_EXT,
    FlagsMaxEnumExt = VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT
};
ENABLE_BITMASK_OPERATORS(SurfaceCounterFlagsEXT);

enum class SurfaceTransformFlagsKHR : u32 {
    IdentityKhr = VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR,
    Rotate90Khr = VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR,
    Rotate180Khr = VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR,
    Rotate270Khr = VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR,
    HorizontalMirrorKhr = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR,
    HorizontalMirrorRotate90Khr = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR,
    HorizontalMirrorRotate180Khr = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR,
    HorizontalMirrorRotate270Khr = VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR,
    InheritKhr = VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR,
    FlagsMaxEnumKhr = VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(SurfaceTransformFlagsKHR);

enum class SwapchainCreateFlagsKHR : u32 {
    SplitInstanceBindRegionsKhr = VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR,
    ProtectedKhr = VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR,
    MutableFormatKhr = VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR,
    DeferredMemoryAllocationExt = VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT,
    FlagsMaxEnumKhr = VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(SwapchainCreateFlagsKHR);

enum class SystemAllocationScope : u32 {
    Command = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    Object = VK_SYSTEM_ALLOCATION_SCOPE_OBJECT,
    Cache = VK_SYSTEM_ALLOCATION_SCOPE_CACHE,
    Device = VK_SYSTEM_ALLOCATION_SCOPE_DEVICE,
    Instance = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    MaxEnum = VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM
};

enum class TessellationDomainOrigin : u32 {
    UpperLeft = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    LowerLeft = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT,
    MaxEnum = VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM
};

enum class TileShadingRenderPassFlagBitsQCOM : u32 {
    EnableQcom = VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM,
    PerTileExecutionQcom = VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM,
    FlagsMaxEnumQcom = VK_TILE_SHADING_RENDER_PASS_FLAG_BITS_MAX_ENUM_QCOM
};

enum class TimeDomainKHR : u32 {
    DeviceKhr = VK_TIME_DOMAIN_DEVICE_KHR,
    ClockMonotonicKhr = VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR,
    ClockMonotonicRawKhr = VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR,
    QueryPerformanceCounterKhr = VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR,
    MaxEnumKhr = VK_TIME_DOMAIN_MAX_ENUM_KHR
};

enum class ToolPurposeFlags : u32 {
    Validation = VK_TOOL_PURPOSE_VALIDATION_BIT,
    Profiling = VK_TOOL_PURPOSE_PROFILING_BIT,
    Tracing = VK_TOOL_PURPOSE_TRACING_BIT,
    AdditionalFeatures = VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT,
    ModifyingFeatures = VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT,
    DebugReportingExt = VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT,
    DebugMarkersExt = VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT,
    FlagsMaxEnum = VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM
};
ENABLE_BITMASK_OPERATORS(ToolPurposeFlags);

enum class ValidationCacheHeaderVersionEXT : u32 {
    OneExt = VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT,
    MaxEnumExt = VK_VALIDATION_CACHE_HEADER_VERSION_MAX_ENUM_EXT
};

enum class ValidationCheckEXT : u32 {
    AllExt = VK_VALIDATION_CHECK_ALL_EXT,
    ShadersExt = VK_VALIDATION_CHECK_SHADERS_EXT,
    MaxEnumExt = VK_VALIDATION_CHECK_MAX_ENUM_EXT
};

enum class ValidationFeatureDisableEXT : u32 {
    AllExt = VK_VALIDATION_FEATURE_DISABLE_ALL_EXT,
    ShadersExt = VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT,
    ThreadSafetyExt = VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT,
    ApiParametersExt = VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT,
    ObjectLifetimesExt = VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT,
    CoreChecksExt = VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT,
    UniqueHandlesExt = VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT,
    ShaderValidationCacheExt = VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT,
    MaxEnumExt = VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT
};

enum class ValidationFeatureEnableEXT : u32 {
    GpuAssistedExt = VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT,
    GpuAssistedReserveBindingSlotExt = VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT,
    BestPracticesExt = VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT,
    DebugPrintfExt = VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT,
    SynchronizationValidationExt = VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT,
    MaxEnumExt = VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT
};

enum class VendorId : u32 {
    Khronos = VK_VENDOR_ID_KHRONOS,
    Viv = VK_VENDOR_ID_VIV,
    Vsi = VK_VENDOR_ID_VSI,
    Kazan = VK_VENDOR_ID_KAZAN,
    Codeplay = VK_VENDOR_ID_CODEPLAY,
    Mesa = VK_VENDOR_ID_MESA,
    Pocl = VK_VENDOR_ID_POCL,
    Mobileye = VK_VENDOR_ID_MOBILEYE,
    MaxEnum = VK_VENDOR_ID_MAX_ENUM
};

enum class VertexInputRate : u32 {
    Vertex = VK_VERTEX_INPUT_RATE_VERTEX,
    Instance = VK_VERTEX_INPUT_RATE_INSTANCE,
    MaxEnum = VK_VERTEX_INPUT_RATE_MAX_ENUM
};

enum class VideoCapabilityFlagsKHR : u32 {
    ProtectedContentKhr = VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR,
    SeparateReferenceImagesKhr = VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoCapabilityFlagsKHR);

enum class VideoChromaSubsamplingFlagsKHR : u32 {
    InvalidKhr = VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR,
    MonochromeKhr = VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR,
    420Khr = VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR,
    422Khr = VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR,
    444Khr = VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_CHROMA_SUBSAMPLING_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoChromaSubsamplingFlagsKHR);

enum class VideoCodecOperationFlagsKHR : u32 {
    NoneKhr = VK_VIDEO_CODEC_OPERATION_NONE_KHR,
    EncodeH264Khr = VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR,
    EncodeH265Khr = VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR,
    DecodeH264Khr = VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR,
    DecodeH265Khr = VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR,
    DecodeAv1Khr = VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR,
    EncodeAv1Khr = VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_CODEC_OPERATION_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoCodecOperationFlagsKHR);

enum class VideoCodingControlFlagsKHR : u32 {
    ResetKhr = VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR,
    EncodeRateControlKhr = VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR,
    EncodeQualityLevelKhr = VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_CODING_CONTROL_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoCodingControlFlagsKHR);

enum class VideoComponentBitDepthFlagsKHR : u32 {
    InvalidKhr = VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR,
    8Khr = VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR,
    10Khr = VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR,
    12Khr = VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_COMPONENT_BIT_DEPTH_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoComponentBitDepthFlagsKHR);

enum class VideoDecodeCapabilityFlagsKHR : u32 {
    DpbAndOutputCoincideKhr = VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR,
    DpbAndOutputDistinctKhr = VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_DECODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoDecodeCapabilityFlagsKHR);

enum class VideoDecodeH264PictureLayoutFlagsKHR : u32 {
    ProgressiveKhr = VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR,
    InterlacedInterleavedLinesKhr = VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR,
    InterlacedSeparatePlanesKhr = VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoDecodeH264PictureLayoutFlagsKHR);

enum class VideoDecodeUsageFlagsKHR : u32 {
    DefaultKhr = VK_VIDEO_DECODE_USAGE_DEFAULT_KHR,
    TranscodingKhr = VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR,
    OfflineKhr = VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR,
    StreamingKhr = VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_DECODE_USAGE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoDecodeUsageFlagsKHR);

enum class VideoEncodeAV1CapabilityFlagsKHR : u32 {
    PerRateControlGroupMinMaxQIndexKhr = VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR,
    GenerateObuExtensionHeaderKhr = VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR,
    PrimaryReferenceCdfOnlyKhr = VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR,
    FrameSizeOverrideKhr = VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR,
    MotionVectorScalingKhr = VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_AV1_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeAV1CapabilityFlagsKHR);

enum class VideoEncodeAV1PredictionModeKHR : u32 {
    IntraOnlyKhr = VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR,
    SingleReferenceKhr = VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR,
    UnidirectionalCompoundKhr = VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR,
    BidirectionalCompoundKhr = VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR,
    MaxEnumKhr = VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_MAX_ENUM_KHR
};

enum class VideoEncodeAV1RateControlFlagsKHR : u32 {
    RegularGopKhr = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR,
    TemporalLayerPatternDyadicKhr = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR,
    ReferencePatternFlatKhr = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR,
    ReferencePatternDyadicKhr = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeAV1RateControlFlagsKHR);

enum class VideoEncodeAV1RateControlGroupKHR : u32 {
    IntraKhr = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR,
    PredictiveKhr = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR,
    BipredictiveKhr = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR,
    MaxEnumKhr = VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_MAX_ENUM_KHR
};

enum class VideoEncodeAV1StdFlagsKHR : u32 {
    UniformTileSpacingFlagSetKhr = VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR,
    SkipModePresentUnsetKhr = VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR,
    PrimaryRefFrameKhr = VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR,
    DeltaQKhr = VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_AV1_STD_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeAV1StdFlagsKHR);

enum class VideoEncodeAV1SuperblockSizeFlagsKHR : u32 {
    64Khr = VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR,
    128Khr = VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeAV1SuperblockSizeFlagsKHR);

enum class VideoEncodeCapabilityFlagsKHR : u32 {
    PrecedingExternallyEncodedBytesKhr = VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR,
    InsufficientstreamBufferRangeDetectionKhr = VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR,
    QuantizationDeltaMapKhr = VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR,
    EmphasisMapKhr = VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeCapabilityFlagsKHR);

enum class VideoEncodeContentFlagsKHR : u32 {
    DefaultKhr = VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR,
    CameraKhr = VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR,
    DesktopKhr = VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR,
    RenderedKhr = VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeContentFlagsKHR);

enum class VideoEncodeFeedbackFlagsKHR : u32 {
    BitstreamBufferOffsetKhr = VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR,
    BitstreamBytesWrittenKhr = VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR,
    BitstreamHasOverridesKhr = VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeFeedbackFlagsKHR);

enum class VideoEncodeFlagsKHR : u32 {
    WithQuantizationDeltaMapKhr = VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR,
    WithEmphasisMapKhr = VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeFlagsKHR);

enum class VideoEncodeH264CapabilityFlagsKHR : u32 {
    HrdComplianceKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR,
    PredictionWeightTableGeneratedKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR,
    RowUnalignedSliceKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR,
    DifferentSliceTypeKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR,
    BFrameInL0ListKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR,
    BFrameInL1ListKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR,
    PerPictureTypeMinMaxQpKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR,
    PerSliceConstantQpKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR,
    GeneratePrefixNaluKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR,
    MbQpDiffWraparoundKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_H264_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeH264CapabilityFlagsKHR);

enum class VideoEncodeH264RateControlFlagsKHR : u32 {
    AttemptHrdComplianceKhr = VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR,
    RegularGopKhr = VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR,
    ReferencePatternFlatKhr = VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR,
    ReferencePatternDyadicKhr = VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR,
    TemporalLayerPatternDyadicKhr = VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_H264_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeH264RateControlFlagsKHR);

enum class VideoEncodeH264StdFlagsKHR : u32 {
    SeparateColorPlaneFlagSetKhr = VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR,
    QpprimeYZeroTransformBypassFlagSetKhr = VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR,
    ScalingMatrixPresentFlagSetKhr = VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR,
    ChromaQpIndexOffsetKhr = VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR,
    SecondChromaQpIndexOffsetKhr = VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR,
    PicInitQpMinus26Khr = VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR,
    WeightedPredFlagSetKhr = VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR,
    WeightedBipredIdcExplicitKhr = VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR,
    WeightedBipredIdcImplicitKhr = VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR,
    Transform8x8ModeFlagSetKhr = VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR,
    DirectSpatialMvPredFlagUnsetKhr = VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR,
    EntropyCodingModeFlagUnsetKhr = VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR,
    EntropyCodingModeFlagSetKhr = VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR,
    Direct8x8InferenceFlagUnsetKhr = VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR,
    ConstrainedIntraPredFlagSetKhr = VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR,
    DeblockingFilterDisabledKhr = VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR,
    DeblockingFilterEnabledKhr = VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR,
    DeblockingFilterPartialKhr = VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR,
    SliceQpDeltaKhr = VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR,
    DifferentSliceQpDeltaKhr = VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_H264_STD_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeH264StdFlagsKHR);

enum class VideoEncodeH265CapabilityFlagsKHR : u32 {
    HrdComplianceKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR,
    PredictionWeightTableGeneratedKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR,
    RowUnalignedSliceSegmentKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR,
    DifferentSliceSegmentTypeKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR,
    BFrameInL0ListKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR,
    BFrameInL1ListKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR,
    PerPictureTypeMinMaxQpKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR,
    PerSliceSegmentConstantQpKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR,
    MultipleTilesPerSliceSegmentKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR,
    MultipleSliceSegmentsPerTileKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR,
    CuQpDiffWraparoundKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_H265_CAPABILITY_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeH265CapabilityFlagsKHR);

enum class VideoEncodeH265CtbSizeFlagsKHR : u32 {
    16Khr = VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR,
    32Khr = VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR,
    64Khr = VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_H265_CTB_SIZE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeH265CtbSizeFlagsKHR);

enum class VideoEncodeH265RateControlFlagsKHR : u32 {
    AttemptHrdComplianceKhr = VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR,
    RegularGopKhr = VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR,
    ReferencePatternFlatKhr = VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR,
    ReferencePatternDyadicKhr = VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR,
    TemporalSubLayerPatternDyadicKhr = VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_H265_RATE_CONTROL_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeH265RateControlFlagsKHR);

enum class VideoEncodeH265StdFlagsKHR : u32 {
    SeparateColorPlaneFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR,
    SampleAdaptiveOffsetEnabledFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR,
    ScalingListDataPresentFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR,
    PcmEnabledFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR,
    SpsTemporalMvpEnabledFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR,
    InitQpMinus26Khr = VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR,
    WeightedPredFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR,
    WeightedBipredFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR,
    Log2ParallelMergeLevelMinus2Khr = VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR,
    SignDataHidingEnabledFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR,
    TransformSkipEnabledFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR,
    TransformSkipEnabledFlagUnsetKhr = VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR,
    PpsSliceChromaQpOffsetsPresentFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR,
    TransquantBypassEnabledFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR,
    ConstrainedIntraPredFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR,
    EntropyCodingSyncEnabledFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR,
    DeblockingFilterOverrideEnabledFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR,
    DependentSliceSegmentsEnabledFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR,
    DependentSliceSegmentFlagSetKhr = VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR,
    SliceQpDeltaKhr = VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR,
    DifferentSliceQpDeltaKhr = VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_H265_STD_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeH265StdFlagsKHR);

enum class VideoEncodeH265TransformBlockSizeFlagsKHR : u32 {
    4Khr = VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR,
    8Khr = VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR,
    16Khr = VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR,
    32Khr = VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeH265TransformBlockSizeFlagsKHR);

enum class VideoEncodeRateControlModeFlagsKHR : u32 {
    DefaultKhr = VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR,
    DisabledKhr = VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR,
    CbrKhr = VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR,
    VbrKhr = VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeRateControlModeFlagsKHR);

enum class VideoEncodeTuningModeKHR : u32 {
    DefaultKhr = VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR,
    HighQualityKhr = VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR,
    LowLatencyKhr = VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR,
    UltraLowLatencyKhr = VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR,
    LosslessKhr = VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR,
    MaxEnumKhr = VK_VIDEO_ENCODE_TUNING_MODE_MAX_ENUM_KHR
};

enum class VideoEncodeUsageFlagsKHR : u32 {
    DefaultKhr = VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR,
    TranscodingKhr = VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR,
    StreamingKhr = VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR,
    RecordingKhr = VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR,
    ConferencingKhr = VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_ENCODE_USAGE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoEncodeUsageFlagsKHR);

enum class VideoSessionCreateFlagsKHR : u32 {
    ProtectedContentKhr = VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR,
    AllowEncodeParameterOptimizationsKhr = VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR,
    InlineQueriesKhr = VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR,
    AllowEncodeQuantizationDeltaMapKhr = VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR,
    AllowEncodeEmphasisMapKhr = VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR,
    InlineSessionParametersKhr = VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_SESSION_CREATE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoSessionCreateFlagsKHR);

enum class VideoSessionParametersCreateFlagsKHR : u32 {
    QuantizationMapCompatibleKhr = VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR,
    FlagsMaxEnumKhr = VK_VIDEO_SESSION_PARAMETERS_CREATE_FLAG_BITS_MAX_ENUM_KHR
};
ENABLE_BITMASK_OPERATORS(VideoSessionParametersCreateFlagsKHR);

enum class ViewportCoordinateSwizzleNV : u32 {
    PositiveXNv = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV,
    NegativeXNv = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV,
    PositiveYNv = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV,
    NegativeYNv = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV,
    PositiveZNv = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV,
    NegativeZNv = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV,
    PositiveWNv = VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV,
    NegativeWNv = VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV,
    MaxEnumNv = VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV
};


struct AabbPositionsKHR {
    f32 min_x;
    f32 min_y;
    f32 min_z;
    f32 max_x;
    f32 max_y;
    f32 max_z;
    
    VkAabbPositionsKHR raw() {
        return VkAabbPositionsKHR {
            .minX = min_x,
            .minY = min_y,
            .minZ = min_z,
            .maxX = max_x,
            .maxY = max_y,
            .maxZ = max_z
        };
    }
};

struct AccelerationStructureBuildGeometryInfoKHR {
    AccelerationStructureTypeKHR type;
    VkBuildAccelerationStructureFlagsKHR flags;
    BuildAccelerationStructureModeKHR mode;
    VkAccelerationStructureKHR src_acceleration_structure;
    VkAccelerationStructureKHR dst_acceleration_structure;
    u32 geometry_count;
    VkAccelerationStructureGeometryKHR* geometries;
    VkAccelerationStructureGeometryKHR** pp_geometries;
    VkDeviceOrHostAddressKHR scratch_data;
    
    VkAccelerationStructureBuildGeometryInfoKHR raw() {
        return VkAccelerationStructureBuildGeometryInfoKHR {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
            .pNext = nullptr,
            .type = static_cast<VkAccelerationStructureTypeKHR>(type),
            .flags = flags,
            .mode = static_cast<VkBuildAccelerationStructureModeKHR>(mode),
            .srcAccelerationStructure = src_acceleration_structure,
            .dstAccelerationStructure = dst_acceleration_structure,
            .geometryCount = geometry_count,
            .pGeometries = geometries,
            .ppGeometries = pp_geometries,
            .scratchData = scratch_data
        };
    }
};

struct AccelerationStructureBuildRangeInfoKHR {
    u32 primitive_count;
    u32 primitive_offset;
    u32 first_vertex;
    u32 transform_offset;
    
    VkAccelerationStructureBuildRangeInfoKHR raw() {
        return VkAccelerationStructureBuildRangeInfoKHR {
            .primitiveCount = primitive_count,
            .primitiveOffset = primitive_offset,
            .firstVertex = first_vertex,
            .transformOffset = transform_offset
        };
    }
};

struct AccelerationStructureBuildSizesInfoKHR {
    VkDeviceSize acceleration_structure_size;
    VkDeviceSize update_scratch_size;
    VkDeviceSize build_scratch_size;
    
    VkAccelerationStructureBuildSizesInfoKHR raw() {
        return VkAccelerationStructureBuildSizesInfoKHR {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,
            .pNext = nullptr,
            .accelerationStructureSize = acceleration_structure_size,
            .updateScratchSize = update_scratch_size,
            .buildScratchSize = build_scratch_size
        };
    }
};

struct AccelerationStructureCaptureDescriptorDataInfoEXT {
    VkAccelerationStructureKHR acceleration_structure;
    VkAccelerationStructureNV acceleration_structure_nv;
    
    VkAccelerationStructureCaptureDescriptorDataInfoEXT raw() {
        return VkAccelerationStructureCaptureDescriptorDataInfoEXT {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
            .pNext = nullptr,
            .accelerationStructure = acceleration_structure,
            .accelerationStructureNV = acceleration_structure_nv
        };
    }
};

struct AccelerationStructureCreateInfoKHR {
    VkAccelerationStructureCreateFlagsKHR create_flags;
    VkBuffer buffer;
    VkDeviceSize offset;
    VkDeviceSize size;
    AccelerationStructureTypeKHR type;
    VkDeviceAddress device_address;
    
    VkAccelerationStructureCreateInfoKHR raw() {
        return VkAccelerationStructureCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,
            .pNext = nullptr,
            .createFlags = create_flags,
            .buffer = buffer,
            .offset = offset,
            .size = size,
            .type = static_cast<VkAccelerationStructureTypeKHR>(type),
            .deviceAddress = device_address
        };
    }
};

struct AccelerationStructureCreateInfoNV {
    VkDeviceSize compacted_size;
    AccelerationStructureInfoNV info;
    
    VkAccelerationStructureCreateInfoNV raw() {
        return VkAccelerationStructureCreateInfoNV {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
            .pNext = nullptr,
            .compactedSize = compacted_size,
            .info = info.raw()
        };
    }
};

struct AccelerationStructureDeviceAddressInfoKHR {
    VkAccelerationStructureKHR acceleration_structure;
    
    VkAccelerationStructureDeviceAddressInfoKHR raw() {
        return VkAccelerationStructureDeviceAddressInfoKHR {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,
            .pNext = nullptr,
            .accelerationStructure = acceleration_structure
        };
    }
};

struct AccelerationStructureGeometryAabbsDataKHR {
    VkDeviceOrHostAddressConstKHR data;
    VkDeviceSize stride;
    
    VkAccelerationStructureGeometryAabbsDataKHR raw() {
        return VkAccelerationStructureGeometryAabbsDataKHR {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR,
            .pNext = nullptr,
            .data = data,
            .stride = stride
        };
    }
};

struct AccelerationStructureGeometryInstancesDataKHR {
    bool array_of_pointers;
    VkDeviceOrHostAddressConstKHR data;
    
    VkAccelerationStructureGeometryInstancesDataKHR raw() {
        return VkAccelerationStructureGeometryInstancesDataKHR {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,
            .pNext = nullptr,
            .arrayOfPointers = static_cast<VkBool32>(array_of_pointers),
            .data = data
        };
    }
};

struct AccelerationStructureGeometryKHR {
    GeometryTypeKHR geometry_type;
    VkAccelerationStructureGeometryDataKHR geometry;
    VkGeometryFlagsKHR flags;
    
    VkAccelerationStructureGeometryKHR raw() {
        return VkAccelerationStructureGeometryKHR {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,
            .pNext = nullptr,
            .geometryType = static_cast<VkGeometryTypeKHR>(geometry_type),
            .geometry = geometry,
            .flags = flags
        };
    }
};

struct AccelerationStructureGeometryLinearSweptSpheresDataNV {
    Format vertex_format;
    VkDeviceOrHostAddressConstKHR vertex_data;
    VkDeviceSize vertex_stride;
    Format radius_format;
    VkDeviceOrHostAddressConstKHR radius_data;
    VkDeviceSize radius_stride;
    IndexType index_type;
    VkDeviceOrHostAddressConstKHR index_data;
    VkDeviceSize index_stride;
    RayTracingLssIndexingModeNV indexing_mode;
    RayTracingLssPrimitiveEndCapsModeNV end_caps_mode;
    
    VkAccelerationStructureGeometryLinearSweptSpheresDataNV raw() {
        return VkAccelerationStructureGeometryLinearSweptSpheresDataNV {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV,
            .pNext = nullptr,
            .vertexFormat = static_cast<VkFormat>(vertex_format),
            .vertexData = vertex_data,
            .vertexStride = vertex_stride,
            .radiusFormat = static_cast<VkFormat>(radius_format),
            .radiusData = radius_data,
            .radiusStride = radius_stride,
            .indexType = static_cast<VkIndexType>(index_type),
            .indexData = index_data,
            .indexStride = index_stride,
            .indexingMode = static_cast<VkRayTracingLssIndexingModeNV>(indexing_mode),
            .endCapsMode = static_cast<VkRayTracingLssPrimitiveEndCapsModeNV>(end_caps_mode)
        };
    }
};

struct AccelerationStructureGeometryMotionTrianglesDataNV {
    VkDeviceOrHostAddressConstKHR vertex_data;
    
    VkAccelerationStructureGeometryMotionTrianglesDataNV raw() {
        return VkAccelerationStructureGeometryMotionTrianglesDataNV {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV,
            .pNext = nullptr,
            .vertexData = vertex_data
        };
    }
};

struct AccelerationStructureGeometrySpheresDataNV {
    Format vertex_format;
    VkDeviceOrHostAddressConstKHR vertex_data;
    VkDeviceSize vertex_stride;
    Format radius_format;
    VkDeviceOrHostAddressConstKHR radius_data;
    VkDeviceSize radius_stride;
    IndexType index_type;
    VkDeviceOrHostAddressConstKHR index_data;
    VkDeviceSize index_stride;
    
    VkAccelerationStructureGeometrySpheresDataNV raw() {
        return VkAccelerationStructureGeometrySpheresDataNV {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV,
            .pNext = nullptr,
            .vertexFormat = static_cast<VkFormat>(vertex_format),
            .vertexData = vertex_data,
            .vertexStride = vertex_stride,
            .radiusFormat = static_cast<VkFormat>(radius_format),
            .radiusData = radius_data,
            .radiusStride = radius_stride,
            .indexType = static_cast<VkIndexType>(index_type),
            .indexData = index_data,
            .indexStride = index_stride
        };
    }
};

struct AccelerationStructureGeometryTrianglesDataKHR {
    Format vertex_format;
    VkDeviceOrHostAddressConstKHR vertex_data;
    VkDeviceSize vertex_stride;
    u32 max_vertex;
    IndexType index_type;
    VkDeviceOrHostAddressConstKHR index_data;
    VkDeviceOrHostAddressConstKHR transform_data;
    
    VkAccelerationStructureGeometryTrianglesDataKHR raw() {
        return VkAccelerationStructureGeometryTrianglesDataKHR {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,
            .pNext = nullptr,
            .vertexFormat = static_cast<VkFormat>(vertex_format),
            .vertexData = vertex_data,
            .vertexStride = vertex_stride,
            .maxVertex = max_vertex,
            .indexType = static_cast<VkIndexType>(index_type),
            .indexData = index_data,
            .transformData = transform_data
        };
    }
};

struct AccelerationStructureInfoNV {
    VkAccelerationStructureTypeNV type;
    VkBuildAccelerationStructureFlagsNV flags;
    u32 instance_count;
    u32 geometry_count;
    VkGeometryNV* geometries;
    
    VkAccelerationStructureInfoNV raw() {
        return VkAccelerationStructureInfoNV {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_INFO_NV,
            .pNext = nullptr,
            .type = type,
            .flags = flags,
            .instanceCount = instance_count,
            .geometryCount = geometry_count,
            .pGeometries = geometries
        };
    }
};

struct AccelerationStructureInstanceKHR {
    TransformMatrixKHR transform;
    u32 instance_custom_index;
    u32 mask;
    u32 instance_shader_binding_table_record_offset;
    VkGeometryInstanceFlagsKHR flags;
    uint64_t acceleration_structure_reference;
    
    VkAccelerationStructureInstanceKHR raw() {
        return VkAccelerationStructureInstanceKHR {
            .transform = transform.raw(),
            .instanceCustomIndex = instance_custom_index,
            .mask = mask,
            .instanceShaderBindingTableRecordOffset = instance_shader_binding_table_record_offset,
            .flags = flags,
            .accelerationStructureReference = acceleration_structure_reference
        };
    }
};

struct AccelerationStructureMatrixMotionInstanceNV {
    TransformMatrixKHR transform_t0;
    TransformMatrixKHR transform_t1;
    u32 instance_custom_index;
    u32 mask;
    u32 instance_shader_binding_table_record_offset;
    VkGeometryInstanceFlagsKHR flags;
    uint64_t acceleration_structure_reference;
    
    VkAccelerationStructureMatrixMotionInstanceNV raw() {
        return VkAccelerationStructureMatrixMotionInstanceNV {
            .transformT0 = transform_t0.raw(),
            .transformT1 = transform_t1.raw(),
            .instanceCustomIndex = instance_custom_index,
            .mask = mask,
            .instanceShaderBindingTableRecordOffset = instance_shader_binding_table_record_offset,
            .flags = flags,
            .accelerationStructureReference = acceleration_structure_reference
        };
    }
};

struct AccelerationStructureMemoryRequirementsInfoNV {
    AccelerationStructureMemoryRequirementsTypeNV type;
    VkAccelerationStructureNV acceleration_structure;
    
    VkAccelerationStructureMemoryRequirementsInfoNV raw() {
        return VkAccelerationStructureMemoryRequirementsInfoNV {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV,
            .pNext = nullptr,
            .type = static_cast<VkAccelerationStructureMemoryRequirementsTypeNV>(type),
            .accelerationStructure = acceleration_structure
        };
    }
};

struct AccelerationStructureMotionInfoNV {
    u32 max_instances;
    VkAccelerationStructureMotionInfoFlagsNV flags;
    
    VkAccelerationStructureMotionInfoNV raw() {
        return VkAccelerationStructureMotionInfoNV {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV,
            .pNext = nullptr,
            .maxInstances = max_instances,
            .flags = flags
        };
    }
};

struct AccelerationStructureMotionInstanceNV {
    AccelerationStructureMotionInstanceTypeNV type;
    VkAccelerationStructureMotionInstanceFlagsNV flags;
    VkAccelerationStructureMotionInstanceDataNV data;
    
    VkAccelerationStructureMotionInstanceNV raw() {
        return VkAccelerationStructureMotionInstanceNV {
            .type = static_cast<VkAccelerationStructureMotionInstanceTypeNV>(type),
            .flags = flags,
            .data = data
        };
    }
};

struct AccelerationStructureSRTMotionInstanceNV {
    SRTDataNV transform_t0;
    SRTDataNV transform_t1;
    u32 instance_custom_index;
    u32 mask;
    u32 instance_shader_binding_table_record_offset;
    VkGeometryInstanceFlagsKHR flags;
    uint64_t acceleration_structure_reference;
    
    VkAccelerationStructureSRTMotionInstanceNV raw() {
        return VkAccelerationStructureSRTMotionInstanceNV {
            .transformT0 = transform_t0.raw(),
            .transformT1 = transform_t1.raw(),
            .instanceCustomIndex = instance_custom_index,
            .mask = mask,
            .instanceShaderBindingTableRecordOffset = instance_shader_binding_table_record_offset,
            .flags = flags,
            .accelerationStructureReference = acceleration_structure_reference
        };
    }
};

struct AccelerationStructureTrianglesOpacityMicromapEXT {
    IndexType index_type;
    VkDeviceOrHostAddressConstKHR index_buffer;
    VkDeviceSize index_stride;
    u32 base_triangle;
    u32 usage_counts_count;
    VkMicromapUsageEXT* usage_counts;
    VkMicromapUsageEXT** pp_usage_counts;
    VkMicromapEXT micromap;
    
    VkAccelerationStructureTrianglesOpacityMicromapEXT raw() {
        return VkAccelerationStructureTrianglesOpacityMicromapEXT {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT,
            .pNext = nullptr,
            .indexType = static_cast<VkIndexType>(index_type),
            .indexBuffer = index_buffer,
            .indexStride = index_stride,
            .baseTriangle = base_triangle,
            .usageCountsCount = usage_counts_count,
            .pUsageCounts = usage_counts,
            .ppUsageCounts = pp_usage_counts,
            .micromap = micromap
        };
    }
};

struct AccelerationStructureVersionInfoKHR {
    uint8_t* version_data;
    
    VkAccelerationStructureVersionInfoKHR raw() {
        return VkAccelerationStructureVersionInfoKHR {
            .sType = VK_STRUCT_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR,
            .pNext = nullptr,
            .pVersionData = version_data
        };
    }
};

struct AcquireNextImageInfoKHR {
    VkSwapchainKHR swapchain;
    uint64_t timeout;
    VkSemaphore semaphore;
    VkFence fence;
    u32 device_mask;
    
    VkAcquireNextImageInfoKHR raw() {
        return VkAcquireNextImageInfoKHR {
            .sType = VK_STRUCT_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR,
            .pNext = nullptr,
            .swapchain = swapchain,
            .timeout = timeout,
            .semaphore = semaphore,
            .fence = fence,
            .deviceMask = device_mask
        };
    }
};

struct AcquireProfilingLockInfoKHR {
    VkAcquireProfilingLockFlagsKHR flags;
    uint64_t timeout;
    
    VkAcquireProfilingLockInfoKHR raw() {
        return VkAcquireProfilingLockInfoKHR {
            .sType = VK_STRUCT_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .timeout = timeout
        };
    }
};

struct AllocationCallbacks {
    void* user_data;
    PFN_vkAllocationFunction pfn_allocation;
    PFN_vkReallocationFunction pfn_reallocation;
    PFN_vkFreeFunction pfn_free;
    PFN_vkInternalAllocationNotification pfn_internal_allocation;
    PFN_vkInternalFreeNotification pfn_internal_free;
    
    VkAllocationCallbacks raw() {
        return VkAllocationCallbacks {
            .pUserData = user_data,
            .pfnAllocation = pfn_allocation,
            .pfnReallocation = pfn_reallocation,
            .pfnFree = pfn_free,
            .pfnInternalAllocation = pfn_internal_allocation,
            .pfnInternalFree = pfn_internal_free
        };
    }
};

struct AmigoProfilingSubmitInfoSEC {
    uint64_t first_draw_timestamp;
    uint64_t swap_buffer_timestamp;
    
    VkAmigoProfilingSubmitInfoSEC raw() {
        return VkAmigoProfilingSubmitInfoSEC {
            .sType = VK_STRUCT_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC,
            .pNext = nullptr,
            .firstDrawTimestamp = first_draw_timestamp,
            .swapBufferTimestamp = swap_buffer_timestamp
        };
    }
};

struct AntiLagDataAMD {
    AntiLagModeAMD mode;
    u32 max_fps;
    VkAntiLagPresentationInfoAMD* presentation_info;
    
    VkAntiLagDataAMD raw() {
        return VkAntiLagDataAMD {
            .sType = VK_STRUCT_TYPE_ANTI_LAG_DATA_AMD,
            .pNext = nullptr,
            .mode = static_cast<VkAntiLagModeAMD>(mode),
            .maxFPS = max_fps,
            .pPresentationInfo = presentation_info
        };
    }
};

struct AntiLagPresentationInfoAMD {
    AntiLagStageAMD stage;
    uint64_t frame_index;
    
    VkAntiLagPresentationInfoAMD raw() {
        return VkAntiLagPresentationInfoAMD {
            .sType = VK_STRUCT_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD,
            .pNext = nullptr,
            .stage = static_cast<VkAntiLagStageAMD>(stage),
            .frameIndex = frame_index
        };
    }
};

struct ApplicationInfo {
    char* application_name;
    u32 application_version;
    char* engine_name;
    u32 engine_version;
    u32 api_version;
    
    VkApplicationInfo raw() {
        return VkApplicationInfo {
            .sType = VK_STRUCT_TYPE_APPLICATION_INFO,
            .pNext = nullptr,
            .pApplicationName = application_name,
            .applicationVersion = application_version,
            .pEngineName = engine_name,
            .engineVersion = engine_version,
            .apiVersion = api_version
        };
    }
};

struct AttachmentDescription {
    VkAttachmentDescriptionFlags flags;
    Format format;
    SampleCountFlags samples;
    AttachmentLoadOp load_op;
    AttachmentStoreOp store_op;
    AttachmentLoadOp stencil_load_op;
    AttachmentStoreOp stencil_store_op;
    ImageLayout initial_layout;
    ImageLayout final_layout;
    
    VkAttachmentDescription raw() {
        return VkAttachmentDescription {
            .flags = flags,
            .format = static_cast<VkFormat>(format),
            .samples = static_cast<VkSampleCountFlagBits>(samples),
            .loadOp = static_cast<VkAttachmentLoadOp>(load_op),
            .storeOp = static_cast<VkAttachmentStoreOp>(store_op),
            .stencilLoadOp = static_cast<VkAttachmentLoadOp>(stencil_load_op),
            .stencilStoreOp = static_cast<VkAttachmentStoreOp>(stencil_store_op),
            .initialLayout = static_cast<VkImageLayout>(initial_layout),
            .finalLayout = static_cast<VkImageLayout>(final_layout)
        };
    }
};

struct AttachmentDescription2 {
    VkAttachmentDescriptionFlags flags;
    Format format;
    SampleCountFlags samples;
    AttachmentLoadOp load_op;
    AttachmentStoreOp store_op;
    AttachmentLoadOp stencil_load_op;
    AttachmentStoreOp stencil_store_op;
    ImageLayout initial_layout;
    ImageLayout final_layout;
    
    VkAttachmentDescription2 raw() {
        return VkAttachmentDescription2 {
            .sType = VK_STRUCT_TYPE_ATTACHMENT_DESCRIPTION2,
            .pNext = nullptr,
            .flags = flags,
            .format = static_cast<VkFormat>(format),
            .samples = static_cast<VkSampleCountFlagBits>(samples),
            .loadOp = static_cast<VkAttachmentLoadOp>(load_op),
            .storeOp = static_cast<VkAttachmentStoreOp>(store_op),
            .stencilLoadOp = static_cast<VkAttachmentLoadOp>(stencil_load_op),
            .stencilStoreOp = static_cast<VkAttachmentStoreOp>(stencil_store_op),
            .initialLayout = static_cast<VkImageLayout>(initial_layout),
            .finalLayout = static_cast<VkImageLayout>(final_layout)
        };
    }
};

struct AttachmentDescriptionStencilLayout {
    ImageLayout stencil_initial_layout;
    ImageLayout stencil_final_layout;
    
    VkAttachmentDescriptionStencilLayout raw() {
        return VkAttachmentDescriptionStencilLayout {
            .sType = VK_STRUCT_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT,
            .pNext = nullptr,
            .stencilInitialLayout = static_cast<VkImageLayout>(stencil_initial_layout),
            .stencilFinalLayout = static_cast<VkImageLayout>(stencil_final_layout)
        };
    }
};

struct AttachmentReference {
    u32 attachment;
    ImageLayout layout;
    
    VkAttachmentReference raw() {
        return VkAttachmentReference {
            .attachment = attachment,
            .layout = static_cast<VkImageLayout>(layout)
        };
    }
};

struct AttachmentReference2 {
    u32 attachment;
    ImageLayout layout;
    VkImageAspectFlags aspect_mask;
    
    VkAttachmentReference2 raw() {
        return VkAttachmentReference2 {
            .sType = VK_STRUCT_TYPE_ATTACHMENT_REFERENCE2,
            .pNext = nullptr,
            .attachment = attachment,
            .layout = static_cast<VkImageLayout>(layout),
            .aspectMask = aspect_mask
        };
    }
};

struct AttachmentReferenceStencilLayout {
    ImageLayout stencil_layout;
    
    VkAttachmentReferenceStencilLayout raw() {
        return VkAttachmentReferenceStencilLayout {
            .sType = VK_STRUCT_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT,
            .pNext = nullptr,
            .stencilLayout = static_cast<VkImageLayout>(stencil_layout)
        };
    }
};

struct AttachmentSampleCountInfoAMD {
    u32 color_attachment_count;
    VkSampleCountFlagBits* color_attachment_samples;
    SampleCountFlags depth_stencil_attachment_samples;
    
    VkAttachmentSampleCountInfoAMD raw() {
        return VkAttachmentSampleCountInfoAMD {
            .sType = VK_STRUCT_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD,
            .pNext = nullptr,
            .colorAttachmentCount = color_attachment_count,
            .pColorAttachmentSamples = color_attachment_samples,
            .depthStencilAttachmentSamples = static_cast<VkSampleCountFlagBits>(depth_stencil_attachment_samples)
        };
    }
};

struct AttachmentSampleLocationsEXT {
    u32 attachment_index;
    SampleLocationsInfoEXT sample_locations_info;
    
    VkAttachmentSampleLocationsEXT raw() {
        return VkAttachmentSampleLocationsEXT {
            .attachmentIndex = attachment_index,
            .sampleLocationsInfo = sample_locations_info.raw()
        };
    }
};

struct BaseInStructure {
    
    VkBaseInStructure raw() {
        return VkBaseInStructure {
            .sType = VK_STRUCT_TYPE_BASE_IN_STRUCTURE,
            .pNext = nullptr,
        };
    }
};

struct BaseOutStructure {
    
    VkBaseOutStructure raw() {
        return VkBaseOutStructure {
            .sType = VK_STRUCT_TYPE_BASE_OUT_STRUCTURE,
            .pNext = nullptr,
        };
    }
};

struct BindAccelerationStructureMemoryInfoNV {
    VkAccelerationStructureNV acceleration_structure;
    VkDeviceMemory memory;
    VkDeviceSize memory_offset;
    u32 device_index_count;
    uint32_t* device_indices;
    
    VkBindAccelerationStructureMemoryInfoNV raw() {
        return VkBindAccelerationStructureMemoryInfoNV {
            .sType = VK_STRUCT_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV,
            .pNext = nullptr,
            .accelerationStructure = acceleration_structure,
            .memory = memory,
            .memoryOffset = memory_offset,
            .deviceIndexCount = device_index_count,
            .pDeviceIndices = device_indices
        };
    }
};

struct BindBufferMemoryDeviceGroupInfo {
    u32 device_index_count;
    uint32_t* device_indices;
    
    VkBindBufferMemoryDeviceGroupInfo raw() {
        return VkBindBufferMemoryDeviceGroupInfo {
            .sType = VK_STRUCT_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
            .pNext = nullptr,
            .deviceIndexCount = device_index_count,
            .pDeviceIndices = device_indices
        };
    }
};

struct BindBufferMemoryInfo {
    VkBuffer buffer;
    VkDeviceMemory memory;
    VkDeviceSize memory_offset;
    
    VkBindBufferMemoryInfo raw() {
        return VkBindBufferMemoryInfo {
            .sType = VK_STRUCT_TYPE_BIND_BUFFER_MEMORY_INFO,
            .pNext = nullptr,
            .buffer = buffer,
            .memory = memory,
            .memoryOffset = memory_offset
        };
    }
};

struct BindDescriptorBufferEmbeddedSamplersInfoEXT {
    VkShaderStageFlags stage_flags;
    VkPipelineLayout layout;
    u32 set;
    
    VkBindDescriptorBufferEmbeddedSamplersInfoEXT raw() {
        return VkBindDescriptorBufferEmbeddedSamplersInfoEXT {
            .sType = VK_STRUCT_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT,
            .pNext = nullptr,
            .stageFlags = stage_flags,
            .layout = layout,
            .set = set
        };
    }
};

struct BindDescriptorSetsInfo {
    VkShaderStageFlags stage_flags;
    VkPipelineLayout layout;
    u32 first_set;
    u32 descriptor_set_count;
    VkDescriptorSet* descriptor_sets;
    u32 dynamic_offset_count;
    uint32_t* dynamic_offsets;
    
    VkBindDescriptorSetsInfo raw() {
        return VkBindDescriptorSetsInfo {
            .sType = VK_STRUCT_TYPE_BIND_DESCRIPTOR_SETS_INFO,
            .pNext = nullptr,
            .stageFlags = stage_flags,
            .layout = layout,
            .firstSet = first_set,
            .descriptorSetCount = descriptor_set_count,
            .pDescriptorSets = descriptor_sets,
            .dynamicOffsetCount = dynamic_offset_count,
            .pDynamicOffsets = dynamic_offsets
        };
    }
};

struct BindImageMemoryDeviceGroupInfo {
    u32 device_index_count;
    uint32_t* device_indices;
    u32 split_instance_bind_region_count;
    VkRect2D* split_instance_bind_regions;
    
    VkBindImageMemoryDeviceGroupInfo raw() {
        return VkBindImageMemoryDeviceGroupInfo {
            .sType = VK_STRUCT_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
            .pNext = nullptr,
            .deviceIndexCount = device_index_count,
            .pDeviceIndices = device_indices,
            .splitInstanceBindRegionCount = split_instance_bind_region_count,
            .pSplitInstanceBindRegions = split_instance_bind_regions
        };
    }
};

struct BindImageMemoryInfo {
    VkImage image;
    VkDeviceMemory memory;
    VkDeviceSize memory_offset;
    
    VkBindImageMemoryInfo raw() {
        return VkBindImageMemoryInfo {
            .sType = VK_STRUCT_TYPE_BIND_IMAGE_MEMORY_INFO,
            .pNext = nullptr,
            .image = image,
            .memory = memory,
            .memoryOffset = memory_offset
        };
    }
};

struct BindImageMemorySwapchainInfoKHR {
    VkSwapchainKHR swapchain;
    u32 image_index;
    
    VkBindImageMemorySwapchainInfoKHR raw() {
        return VkBindImageMemorySwapchainInfoKHR {
            .sType = VK_STRUCT_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR,
            .pNext = nullptr,
            .swapchain = swapchain,
            .imageIndex = image_index
        };
    }
};

struct BindImagePlaneMemoryInfo {
    ImageAspectFlags plane_aspect;
    
    VkBindImagePlaneMemoryInfo raw() {
        return VkBindImagePlaneMemoryInfo {
            .sType = VK_STRUCT_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
            .pNext = nullptr,
            .planeAspect = static_cast<VkImageAspectFlagBits>(plane_aspect)
        };
    }
};

struct BindIndexBufferIndirectCommandEXT {
    VkDeviceAddress buffer_address;
    u32 size;
    IndexType index_type;
    
    VkBindIndexBufferIndirectCommandEXT raw() {
        return VkBindIndexBufferIndirectCommandEXT {
            .bufferAddress = buffer_address,
            .size = size,
            .indexType = static_cast<VkIndexType>(index_type)
        };
    }
};

struct BindIndexBufferIndirectCommandNV {
    VkDeviceAddress buffer_address;
    u32 size;
    IndexType index_type;
    
    VkBindIndexBufferIndirectCommandNV raw() {
        return VkBindIndexBufferIndirectCommandNV {
            .bufferAddress = buffer_address,
            .size = size,
            .indexType = static_cast<VkIndexType>(index_type)
        };
    }
};

struct BindMemoryStatus {
    VkResult* result;
    
    VkBindMemoryStatus raw() {
        return VkBindMemoryStatus {
            .sType = VK_STRUCT_TYPE_BIND_MEMORY_STATUS,
            .pNext = nullptr,
            .pResult = result
        };
    }
};

struct BindPipelineIndirectCommandNV {
    VkDeviceAddress pipeline_address;
    
    VkBindPipelineIndirectCommandNV raw() {
        return VkBindPipelineIndirectCommandNV {
            .pipelineAddress = pipeline_address
        };
    }
};

struct BindShaderGroupIndirectCommandNV {
    u32 group_index;
    
    VkBindShaderGroupIndirectCommandNV raw() {
        return VkBindShaderGroupIndirectCommandNV {
            .groupIndex = group_index
        };
    }
};

struct BindSparseInfo {
    u32 wait_semaphore_count;
    VkSemaphore* wait_semaphores;
    u32 buffer_bind_count;
    VkSparseBufferMemoryBindInfo* buffer_binds;
    u32 image_opaque_bind_count;
    VkSparseImageOpaqueMemoryBindInfo* image_opaque_binds;
    u32 image_bind_count;
    VkSparseImageMemoryBindInfo* image_binds;
    u32 signal_semaphore_count;
    VkSemaphore* signal_semaphores;
    
    VkBindSparseInfo raw() {
        return VkBindSparseInfo {
            .sType = VK_STRUCT_TYPE_BIND_SPARSE_INFO,
            .pNext = nullptr,
            .waitSemaphoreCount = wait_semaphore_count,
            .pWaitSemaphores = wait_semaphores,
            .bufferBindCount = buffer_bind_count,
            .pBufferBinds = buffer_binds,
            .imageOpaqueBindCount = image_opaque_bind_count,
            .pImageOpaqueBinds = image_opaque_binds,
            .imageBindCount = image_bind_count,
            .pImageBinds = image_binds,
            .signalSemaphoreCount = signal_semaphore_count,
            .pSignalSemaphores = signal_semaphores
        };
    }
};

struct BindVertexBufferIndirectCommandEXT {
    VkDeviceAddress buffer_address;
    u32 size;
    u32 stride;
    
    VkBindVertexBufferIndirectCommandEXT raw() {
        return VkBindVertexBufferIndirectCommandEXT {
            .bufferAddress = buffer_address,
            .size = size,
            .stride = stride
        };
    }
};

struct BindVertexBufferIndirectCommandNV {
    VkDeviceAddress buffer_address;
    u32 size;
    u32 stride;
    
    VkBindVertexBufferIndirectCommandNV raw() {
        return VkBindVertexBufferIndirectCommandNV {
            .bufferAddress = buffer_address,
            .size = size,
            .stride = stride
        };
    }
};

struct BindVideoSessionMemoryInfoKHR {
    u32 memory_bind_index;
    VkDeviceMemory memory;
    VkDeviceSize memory_offset;
    VkDeviceSize memory_size;
    
    VkBindVideoSessionMemoryInfoKHR raw() {
        return VkBindVideoSessionMemoryInfoKHR {
            .sType = VK_STRUCT_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR,
            .pNext = nullptr,
            .memoryBindIndex = memory_bind_index,
            .memory = memory,
            .memoryOffset = memory_offset,
            .memorySize = memory_size
        };
    }
};

struct BlitImageCubicWeightsInfoQCOM {
    CubicFilterWeightsQCOM cubic_weights;
    
    VkBlitImageCubicWeightsInfoQCOM raw() {
        return VkBlitImageCubicWeightsInfoQCOM {
            .sType = VK_STRUCT_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM,
            .pNext = nullptr,
            .cubicWeights = static_cast<VkCubicFilterWeightsQCOM>(cubic_weights)
        };
    }
};

struct BlitImageInfo2 {
    VkImage src_image;
    ImageLayout src_image_layout;
    VkImage dst_image;
    ImageLayout dst_image_layout;
    u32 region_count;
    VkImageBlit2* regions;
    Filter filter;
    
    VkBlitImageInfo2 raw() {
        return VkBlitImageInfo2 {
            .sType = VK_STRUCT_TYPE_BLIT_IMAGE_INFO2,
            .pNext = nullptr,
            .srcImage = src_image,
            .srcImageLayout = static_cast<VkImageLayout>(src_image_layout),
            .dstImage = dst_image,
            .dstImageLayout = static_cast<VkImageLayout>(dst_image_layout),
            .regionCount = region_count,
            .pRegions = regions,
            .filter = static_cast<VkFilter>(filter)
        };
    }
};

struct BufferCaptureDescriptorDataInfoEXT {
    VkBuffer buffer;
    
    VkBufferCaptureDescriptorDataInfoEXT raw() {
        return VkBufferCaptureDescriptorDataInfoEXT {
            .sType = VK_STRUCT_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
            .pNext = nullptr,
            .buffer = buffer
        };
    }
};

struct BufferCopy {
    VkDeviceSize src_offset;
    VkDeviceSize dst_offset;
    VkDeviceSize size;
    
    VkBufferCopy raw() {
        return VkBufferCopy {
            .srcOffset = src_offset,
            .dstOffset = dst_offset,
            .size = size
        };
    }
};

struct BufferCopy2 {
    VkDeviceSize src_offset;
    VkDeviceSize dst_offset;
    VkDeviceSize size;
    
    VkBufferCopy2 raw() {
        return VkBufferCopy2 {
            .sType = VK_STRUCT_TYPE_BUFFER_COPY2,
            .pNext = nullptr,
            .srcOffset = src_offset,
            .dstOffset = dst_offset,
            .size = size
        };
    }
};

struct BufferCreateInfo {
    VkBufferCreateFlags flags;
    VkDeviceSize size;
    VkBufferUsageFlags usage;
    SharingMode sharing_mode;
    u32 queue_family_index_count;
    uint32_t* queue_family_indices;
    
    VkBufferCreateInfo raw() {
        return VkBufferCreateInfo {
            .sType = VK_STRUCT_TYPE_BUFFER_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .size = size,
            .usage = usage,
            .sharingMode = static_cast<VkSharingMode>(sharing_mode),
            .queueFamilyIndexCount = queue_family_index_count,
            .pQueueFamilyIndices = queue_family_indices
        };
    }
};

struct BufferDeviceAddressCreateInfoEXT {
    VkDeviceAddress device_address;
    
    VkBufferDeviceAddressCreateInfoEXT raw() {
        return VkBufferDeviceAddressCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT,
            .pNext = nullptr,
            .deviceAddress = device_address
        };
    }
};

struct BufferDeviceAddressInfo {
    VkBuffer buffer;
    
    VkBufferDeviceAddressInfo raw() {
        return VkBufferDeviceAddressInfo {
            .sType = VK_STRUCT_TYPE_BUFFER_DEVICE_ADDRESS_INFO,
            .pNext = nullptr,
            .buffer = buffer
        };
    }
};

struct BufferImageCopy {
    VkDeviceSize buffer_offset;
    u32 buffer_row_length;
    u32 buffer_image_height;
    ImageSubresourceLayers image_subresource;
    Offset3D image_offset;
    Extent3D image_extent;
    
    VkBufferImageCopy raw() {
        return VkBufferImageCopy {
            .bufferOffset = buffer_offset,
            .bufferRowLength = buffer_row_length,
            .bufferImageHeight = buffer_image_height,
            .imageSubresource = image_subresource.raw(),
            .imageOffset = image_offset.raw(),
            .imageExtent = image_extent.raw()
        };
    }
};

struct BufferImageCopy2 {
    VkDeviceSize buffer_offset;
    u32 buffer_row_length;
    u32 buffer_image_height;
    ImageSubresourceLayers image_subresource;
    Offset3D image_offset;
    Extent3D image_extent;
    
    VkBufferImageCopy2 raw() {
        return VkBufferImageCopy2 {
            .sType = VK_STRUCT_TYPE_BUFFER_IMAGE_COPY2,
            .pNext = nullptr,
            .bufferOffset = buffer_offset,
            .bufferRowLength = buffer_row_length,
            .bufferImageHeight = buffer_image_height,
            .imageSubresource = image_subresource.raw(),
            .imageOffset = image_offset.raw(),
            .imageExtent = image_extent.raw()
        };
    }
};

struct BufferMemoryBarrier {
    VkAccessFlags src_access_mask;
    VkAccessFlags dst_access_mask;
    u32 src_queue_family_index;
    u32 dst_queue_family_index;
    VkBuffer buffer;
    VkDeviceSize offset;
    VkDeviceSize size;
    
    VkBufferMemoryBarrier raw() {
        return VkBufferMemoryBarrier {
            .sType = VK_STRUCT_TYPE_BUFFER_MEMORY_BARRIER,
            .pNext = nullptr,
            .srcAccessMask = src_access_mask,
            .dstAccessMask = dst_access_mask,
            .srcQueueFamilyIndex = src_queue_family_index,
            .dstQueueFamilyIndex = dst_queue_family_index,
            .buffer = buffer,
            .offset = offset,
            .size = size
        };
    }
};

struct BufferMemoryBarrier2 {
    VkPipelineStageFlags2 src_stage_mask;
    VkAccessFlags2 src_access_mask;
    VkPipelineStageFlags2 dst_stage_mask;
    VkAccessFlags2 dst_access_mask;
    u32 src_queue_family_index;
    u32 dst_queue_family_index;
    VkBuffer buffer;
    VkDeviceSize offset;
    VkDeviceSize size;
    
    VkBufferMemoryBarrier2 raw() {
        return VkBufferMemoryBarrier2 {
            .sType = VK_STRUCT_TYPE_BUFFER_MEMORY_BARRIER2,
            .pNext = nullptr,
            .srcStageMask = src_stage_mask,
            .srcAccessMask = src_access_mask,
            .dstStageMask = dst_stage_mask,
            .dstAccessMask = dst_access_mask,
            .srcQueueFamilyIndex = src_queue_family_index,
            .dstQueueFamilyIndex = dst_queue_family_index,
            .buffer = buffer,
            .offset = offset,
            .size = size
        };
    }
};

struct BufferMemoryRequirementsInfo2 {
    VkBuffer buffer;
    
    VkBufferMemoryRequirementsInfo2 raw() {
        return VkBufferMemoryRequirementsInfo2 {
            .sType = VK_STRUCT_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO2,
            .pNext = nullptr,
            .buffer = buffer
        };
    }
};

struct BufferOpaqueCaptureAddressCreateInfo {
    uint64_t opaque_capture_address;
    
    VkBufferOpaqueCaptureAddressCreateInfo raw() {
        return VkBufferOpaqueCaptureAddressCreateInfo {
            .sType = VK_STRUCT_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO,
            .pNext = nullptr,
            .opaqueCaptureAddress = opaque_capture_address
        };
    }
};

struct BufferUsageFlags2CreateInfo {
    VkBufferUsageFlags2 usage;
    
    VkBufferUsageFlags2CreateInfo raw() {
        return VkBufferUsageFlags2CreateInfo {
            .sType = VK_STRUCT_TYPE_BUFFER_USAGE_FLAGS2CREATE_INFO,
            .pNext = nullptr,
            .usage = usage
        };
    }
};

struct BufferViewCreateInfo {
    VkBufferViewCreateFlags flags;
    VkBuffer buffer;
    Format format;
    VkDeviceSize offset;
    VkDeviceSize range;
    
    VkBufferViewCreateInfo raw() {
        return VkBufferViewCreateInfo {
            .sType = VK_STRUCT_TYPE_BUFFER_VIEW_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .buffer = buffer,
            .format = static_cast<VkFormat>(format),
            .offset = offset,
            .range = range
        };
    }
};

struct BuildPartitionedAccelerationStructureIndirectCommandNV {
    PartitionedAccelerationStructureOpTypeNV op_type;
    u32 arg_count;
    StridedDeviceAddressNV arg_data;
    
    VkBuildPartitionedAccelerationStructureIndirectCommandNV raw() {
        return VkBuildPartitionedAccelerationStructureIndirectCommandNV {
            .opType = static_cast<VkPartitionedAccelerationStructureOpTypeNV>(op_type),
            .argCount = arg_count,
            .argData = arg_data.raw()
        };
    }
};

struct BuildPartitionedAccelerationStructureInfoNV {
    PartitionedAccelerationStructureInstancesInputNV input;
    VkDeviceAddress src_acceleration_structure_data;
    VkDeviceAddress dst_acceleration_structure_data;
    VkDeviceAddress scratch_data;
    VkDeviceAddress src_infos;
    VkDeviceAddress src_infos_count;
    
    VkBuildPartitionedAccelerationStructureInfoNV raw() {
        return VkBuildPartitionedAccelerationStructureInfoNV {
            .sType = VK_STRUCT_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV,
            .pNext = nullptr,
            .input = input.raw(),
            .srcAccelerationStructureData = src_acceleration_structure_data,
            .dstAccelerationStructureData = dst_acceleration_structure_data,
            .scratchData = scratch_data,
            .srcInfos = src_infos,
            .srcInfosCount = src_infos_count
        };
    }
};

struct CalibratedTimestampInfoKHR {
    TimeDomainKHR time_domain;
    
    VkCalibratedTimestampInfoKHR raw() {
        return VkCalibratedTimestampInfoKHR {
            .sType = VK_STRUCT_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR,
            .pNext = nullptr,
            .timeDomain = static_cast<VkTimeDomainKHR>(time_domain)
        };
    }
};

struct CheckpointData2NV {
    VkPipelineStageFlags2 stage;
    void* checkpoint_marker;
    
    VkCheckpointData2NV raw() {
        return VkCheckpointData2NV {
            .sType = VK_STRUCT_TYPE_CHECKPOINT_DATA2NV,
            .pNext = nullptr,
            .stage = stage,
            .pCheckpointMarker = checkpoint_marker
        };
    }
};

struct CheckpointDataNV {
    PipelineStageFlags stage;
    void* checkpoint_marker;
    
    VkCheckpointDataNV raw() {
        return VkCheckpointDataNV {
            .sType = VK_STRUCT_TYPE_CHECKPOINT_DATA_NV,
            .pNext = nullptr,
            .stage = static_cast<VkPipelineStageFlagBits>(stage),
            .pCheckpointMarker = checkpoint_marker
        };
    }
};

struct ClearAttachment {
    VkImageAspectFlags aspect_mask;
    u32 color_attachment;
    VkClearValue clear_value;
    
    VkClearAttachment raw() {
        return VkClearAttachment {
            .aspectMask = aspect_mask,
            .colorAttachment = color_attachment,
            .clearValue = clear_value
        };
    }
};

struct ClearDepthStencilValue {
    f32 depth;
    u32 stencil;
    
    VkClearDepthStencilValue raw() {
        return VkClearDepthStencilValue {
            .depth = depth,
            .stencil = stencil
        };
    }
};

struct ClearRect {
    Rect2D rect;
    u32 base_array_layer;
    u32 layer_count;
    
    VkClearRect raw() {
        return VkClearRect {
            .rect = rect.raw(),
            .baseArrayLayer = base_array_layer,
            .layerCount = layer_count
        };
    }
};

struct ClusterAccelerationStructureBuildClustersBottomLevelInfoNV {
    u32 cluster_references_count;
    u32 cluster_references_stride;
    VkDeviceAddress cluster_references;
    
    VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV raw() {
        return VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV {
            .clusterReferencesCount = cluster_references_count,
            .clusterReferencesStride = cluster_references_stride,
            .clusterReferences = cluster_references
        };
    }
};

struct ClusterAccelerationStructureBuildTriangleClusterInfoNV {
    u32 cluster_id;
    VkClusterAccelerationStructureClusterFlagsNV cluster_flags;
    u32 triangle_count;
    u32 vertex_count;
    u32 position_truncate_bit_count;
    u32 index_type;
    u32 opacity_micromap_index_type;
    ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV base_geometry_index_and_geometry_flags;
    u16 index_buffer_stride;
    u16 vertex_buffer_stride;
    u16 geometry_index_and_flags_buffer_stride;
    u16 opacity_micromap_index_buffer_stride;
    VkDeviceAddress index_buffer;
    VkDeviceAddress vertex_buffer;
    VkDeviceAddress geometry_index_and_flags_buffer;
    VkDeviceAddress opacity_micromap_array;
    VkDeviceAddress opacity_micromap_index_buffer;
    
    VkClusterAccelerationStructureBuildTriangleClusterInfoNV raw() {
        return VkClusterAccelerationStructureBuildTriangleClusterInfoNV {
            .clusterID = cluster_id,
            .clusterFlags = cluster_flags,
            .triangleCount = triangle_count,
            .vertexCount = vertex_count,
            .positionTruncateBitCount = position_truncate_bit_count,
            .indexType = index_type,
            .opacityMicromapIndexType = opacity_micromap_index_type,
            .baseGeometryIndexAndGeometryFlags = base_geometry_index_and_geometry_flags.raw(),
            .indexBufferStride = index_buffer_stride,
            .vertexBufferStride = vertex_buffer_stride,
            .geometryIndexAndFlagsBufferStride = geometry_index_and_flags_buffer_stride,
            .opacityMicromapIndexBufferStride = opacity_micromap_index_buffer_stride,
            .indexBuffer = index_buffer,
            .vertexBuffer = vertex_buffer,
            .geometryIndexAndFlagsBuffer = geometry_index_and_flags_buffer,
            .opacityMicromapArray = opacity_micromap_array,
            .opacityMicromapIndexBuffer = opacity_micromap_index_buffer
        };
    }
};

struct ClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV {
    u32 cluster_id;
    VkClusterAccelerationStructureClusterFlagsNV cluster_flags;
    u32 triangle_count;
    u32 vertex_count;
    u32 position_truncate_bit_count;
    u32 index_type;
    u32 opacity_micromap_index_type;
    ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV base_geometry_index_and_geometry_flags;
    u16 index_buffer_stride;
    u16 vertex_buffer_stride;
    u16 geometry_index_and_flags_buffer_stride;
    u16 opacity_micromap_index_buffer_stride;
    VkDeviceAddress index_buffer;
    VkDeviceAddress vertex_buffer;
    VkDeviceAddress geometry_index_and_flags_buffer;
    VkDeviceAddress opacity_micromap_array;
    VkDeviceAddress opacity_micromap_index_buffer;
    VkDeviceAddress instantiation_bounding_box_limit;
    
    VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV raw() {
        return VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV {
            .clusterID = cluster_id,
            .clusterFlags = cluster_flags,
            .triangleCount = triangle_count,
            .vertexCount = vertex_count,
            .positionTruncateBitCount = position_truncate_bit_count,
            .indexType = index_type,
            .opacityMicromapIndexType = opacity_micromap_index_type,
            .baseGeometryIndexAndGeometryFlags = base_geometry_index_and_geometry_flags.raw(),
            .indexBufferStride = index_buffer_stride,
            .vertexBufferStride = vertex_buffer_stride,
            .geometryIndexAndFlagsBufferStride = geometry_index_and_flags_buffer_stride,
            .opacityMicromapIndexBufferStride = opacity_micromap_index_buffer_stride,
            .indexBuffer = index_buffer,
            .vertexBuffer = vertex_buffer,
            .geometryIndexAndFlagsBuffer = geometry_index_and_flags_buffer,
            .opacityMicromapArray = opacity_micromap_array,
            .opacityMicromapIndexBuffer = opacity_micromap_index_buffer,
            .instantiationBoundingBoxLimit = instantiation_bounding_box_limit
        };
    }
};

struct ClusterAccelerationStructureClustersBottomLevelInputNV {
    u32 max_total_cluster_count;
    u32 max_cluster_count_per_acceleration_structure;
    
    VkClusterAccelerationStructureClustersBottomLevelInputNV raw() {
        return VkClusterAccelerationStructureClustersBottomLevelInputNV {
            .sType = VK_STRUCT_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV,
            .pNext = nullptr,
            .maxTotalClusterCount = max_total_cluster_count,
            .maxClusterCountPerAccelerationStructure = max_cluster_count_per_acceleration_structure
        };
    }
};

struct ClusterAccelerationStructureCommandsInfoNV {
    ClusterAccelerationStructureInputInfoNV input;
    VkDeviceAddress dst_implicit_data;
    VkDeviceAddress scratch_data;
    StridedDeviceAddressRegionKHR dst_addresses_array;
    StridedDeviceAddressRegionKHR dst_sizes_array;
    StridedDeviceAddressRegionKHR src_infos_array;
    VkDeviceAddress src_infos_count;
    VkClusterAccelerationStructureAddressResolutionFlagsNV address_resolution_flags;
    
    VkClusterAccelerationStructureCommandsInfoNV raw() {
        return VkClusterAccelerationStructureCommandsInfoNV {
            .sType = VK_STRUCT_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV,
            .pNext = nullptr,
            .input = input.raw(),
            .dstImplicitData = dst_implicit_data,
            .scratchData = scratch_data,
            .dstAddressesArray = dst_addresses_array.raw(),
            .dstSizesArray = dst_sizes_array.raw(),
            .srcInfosArray = src_infos_array.raw(),
            .srcInfosCount = src_infos_count,
            .addressResolutionFlags = address_resolution_flags
        };
    }
};

struct ClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV {
    u32 geometry_index;
    u32 reserved;
    u32 geometry_flags;
    
    VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV raw() {
        return VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV {
            .geometryIndex = geometry_index,
            .reserved = reserved,
            .geometryFlags = geometry_flags
        };
    }
};

struct ClusterAccelerationStructureInputInfoNV {
    u32 max_acceleration_structure_count;
    VkBuildAccelerationStructureFlagsKHR flags;
    ClusterAccelerationStructureOpTypeNV op_type;
    ClusterAccelerationStructureOpModeNV op_mode;
    VkClusterAccelerationStructureOpInputNV op_input;
    
    VkClusterAccelerationStructureInputInfoNV raw() {
        return VkClusterAccelerationStructureInputInfoNV {
            .sType = VK_STRUCT_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV,
            .pNext = nullptr,
            .maxAccelerationStructureCount = max_acceleration_structure_count,
            .flags = flags,
            .opType = static_cast<VkClusterAccelerationStructureOpTypeNV>(op_type),
            .opMode = static_cast<VkClusterAccelerationStructureOpModeNV>(op_mode),
            .opInput = op_input
        };
    }
};

struct ClusterAccelerationStructureInstantiateClusterInfoNV {
    u32 cluster_id_offset;
    u32 geometry_index_offset;
    u32 reserved;
    VkDeviceAddress cluster_template_address;
    StridedDeviceAddressNV vertex_buffer;
    
    VkClusterAccelerationStructureInstantiateClusterInfoNV raw() {
        return VkClusterAccelerationStructureInstantiateClusterInfoNV {
            .clusterIdOffset = cluster_id_offset,
            .geometryIndexOffset = geometry_index_offset,
            .reserved = reserved,
            .clusterTemplateAddress = cluster_template_address,
            .vertexBuffer = vertex_buffer.raw()
        };
    }
};

struct ClusterAccelerationStructureMoveObjectsInfoNV {
    VkDeviceAddress src_acceleration_structure;
    
    VkClusterAccelerationStructureMoveObjectsInfoNV raw() {
        return VkClusterAccelerationStructureMoveObjectsInfoNV {
            .srcAccelerationStructure = src_acceleration_structure
        };
    }
};

struct ClusterAccelerationStructureMoveObjectsInputNV {
    ClusterAccelerationStructureTypeNV type;
    bool no_move_overlap;
    VkDeviceSize max_moved_bytes;
    
    VkClusterAccelerationStructureMoveObjectsInputNV raw() {
        return VkClusterAccelerationStructureMoveObjectsInputNV {
            .sType = VK_STRUCT_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV,
            .pNext = nullptr,
            .type = static_cast<VkClusterAccelerationStructureTypeNV>(type),
            .noMoveOverlap = static_cast<VkBool32>(no_move_overlap),
            .maxMovedBytes = max_moved_bytes
        };
    }
};

struct ClusterAccelerationStructureTriangleClusterInputNV {
    Format vertex_format;
    u32 max_geometry_index_value;
    u32 max_cluster_unique_geometry_count;
    u32 max_cluster_triangle_count;
    u32 max_cluster_vertex_count;
    u32 max_total_triangle_count;
    u32 max_total_vertex_count;
    u32 min_position_truncate_bit_count;
    
    VkClusterAccelerationStructureTriangleClusterInputNV raw() {
        return VkClusterAccelerationStructureTriangleClusterInputNV {
            .sType = VK_STRUCT_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV,
            .pNext = nullptr,
            .vertexFormat = static_cast<VkFormat>(vertex_format),
            .maxGeometryIndexValue = max_geometry_index_value,
            .maxClusterUniqueGeometryCount = max_cluster_unique_geometry_count,
            .maxClusterTriangleCount = max_cluster_triangle_count,
            .maxClusterVertexCount = max_cluster_vertex_count,
            .maxTotalTriangleCount = max_total_triangle_count,
            .maxTotalVertexCount = max_total_vertex_count,
            .minPositionTruncateBitCount = min_position_truncate_bit_count
        };
    }
};

struct CoarseSampleLocationNV {
    u32 pixel_x;
    u32 pixel_y;
    u32 sample;
    
    VkCoarseSampleLocationNV raw() {
        return VkCoarseSampleLocationNV {
            .pixelX = pixel_x,
            .pixelY = pixel_y,
            .sample = sample
        };
    }
};

struct CoarseSampleOrderCustomNV {
    ShadingRatePaletteEntryNV shading_rate;
    u32 sample_count;
    u32 sample_location_count;
    VkCoarseSampleLocationNV* sample_locations;
    
    VkCoarseSampleOrderCustomNV raw() {
        return VkCoarseSampleOrderCustomNV {
            .shadingRate = static_cast<VkShadingRatePaletteEntryNV>(shading_rate),
            .sampleCount = sample_count,
            .sampleLocationCount = sample_location_count,
            .pSampleLocations = sample_locations
        };
    }
};

struct ColorBlendAdvancedEXT {
    BlendOp advanced_blend_op;
    bool src_premultiplied;
    bool dst_premultiplied;
    BlendOverlapEXT blend_overlap;
    bool clamp_results;
    
    VkColorBlendAdvancedEXT raw() {
        return VkColorBlendAdvancedEXT {
            .advancedBlendOp = static_cast<VkBlendOp>(advanced_blend_op),
            .srcPremultiplied = static_cast<VkBool32>(src_premultiplied),
            .dstPremultiplied = static_cast<VkBool32>(dst_premultiplied),
            .blendOverlap = static_cast<VkBlendOverlapEXT>(blend_overlap),
            .clampResults = static_cast<VkBool32>(clamp_results)
        };
    }
};

struct ColorBlendEquationEXT {
    BlendFactor src_color_blend_factor;
    BlendFactor dst_color_blend_factor;
    BlendOp color_blend_op;
    BlendFactor src_alpha_blend_factor;
    BlendFactor dst_alpha_blend_factor;
    BlendOp alpha_blend_op;
    
    VkColorBlendEquationEXT raw() {
        return VkColorBlendEquationEXT {
            .srcColorBlendFactor = static_cast<VkBlendFactor>(src_color_blend_factor),
            .dstColorBlendFactor = static_cast<VkBlendFactor>(dst_color_blend_factor),
            .colorBlendOp = static_cast<VkBlendOp>(color_blend_op),
            .srcAlphaBlendFactor = static_cast<VkBlendFactor>(src_alpha_blend_factor),
            .dstAlphaBlendFactor = static_cast<VkBlendFactor>(dst_alpha_blend_factor),
            .alphaBlendOp = static_cast<VkBlendOp>(alpha_blend_op)
        };
    }
};

struct CommandBufferAllocateInfo {
    VkCommandPool command_pool;
    CommandBufferLevel level;
    u32 command_buffer_count;
    
    VkCommandBufferAllocateInfo raw() {
        return VkCommandBufferAllocateInfo {
            .sType = VK_STRUCT_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
            .pNext = nullptr,
            .commandPool = command_pool,
            .level = static_cast<VkCommandBufferLevel>(level),
            .commandBufferCount = command_buffer_count
        };
    }
};

struct CommandBufferBeginInfo {
    VkCommandBufferUsageFlags flags;
    VkCommandBufferInheritanceInfo* inheritance_info;
    
    VkCommandBufferBeginInfo raw() {
        return VkCommandBufferBeginInfo {
            .sType = VK_STRUCT_TYPE_COMMAND_BUFFER_BEGIN_INFO,
            .pNext = nullptr,
            .flags = flags,
            .pInheritanceInfo = inheritance_info
        };
    }
};

struct CommandBufferInheritanceConditionalRenderingInfoEXT {
    bool conditional_rendering_enable;
    
    VkCommandBufferInheritanceConditionalRenderingInfoEXT raw() {
        return VkCommandBufferInheritanceConditionalRenderingInfoEXT {
            .sType = VK_STRUCT_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT,
            .pNext = nullptr,
            .conditionalRenderingEnable = static_cast<VkBool32>(conditional_rendering_enable)
        };
    }
};

struct CommandBufferInheritanceInfo {
    VkRenderPass render_pass;
    u32 subpass;
    VkFramebuffer framebuffer;
    bool occlusion_query_enable;
    VkQueryControlFlags query_flags;
    VkQueryPipelineStatisticFlags pipeline_statistics;
    
    VkCommandBufferInheritanceInfo raw() {
        return VkCommandBufferInheritanceInfo {
            .sType = VK_STRUCT_TYPE_COMMAND_BUFFER_INHERITANCE_INFO,
            .pNext = nullptr,
            .renderPass = render_pass,
            .subpass = subpass,
            .framebuffer = framebuffer,
            .occlusionQueryEnable = static_cast<VkBool32>(occlusion_query_enable),
            .queryFlags = query_flags,
            .pipelineStatistics = pipeline_statistics
        };
    }
};

struct CommandBufferInheritanceRenderPassTransformInfoQCOM {
    SurfaceTransformFlagsKHR transform;
    Rect2D render_area;
    
    VkCommandBufferInheritanceRenderPassTransformInfoQCOM raw() {
        return VkCommandBufferInheritanceRenderPassTransformInfoQCOM {
            .sType = VK_STRUCT_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM,
            .pNext = nullptr,
            .transform = static_cast<VkSurfaceTransformFlagBitsKHR>(transform),
            .renderArea = render_area.raw()
        };
    }
};

struct CommandBufferInheritanceRenderingInfo {
    VkRenderingFlags flags;
    u32 view_mask;
    u32 color_attachment_count;
    VkFormat* color_attachment_formats;
    Format depth_attachment_format;
    Format stencil_attachment_format;
    SampleCountFlags rasterization_samples;
    
    VkCommandBufferInheritanceRenderingInfo raw() {
        return VkCommandBufferInheritanceRenderingInfo {
            .sType = VK_STRUCT_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO,
            .pNext = nullptr,
            .flags = flags,
            .viewMask = view_mask,
            .colorAttachmentCount = color_attachment_count,
            .pColorAttachmentFormats = color_attachment_formats,
            .depthAttachmentFormat = static_cast<VkFormat>(depth_attachment_format),
            .stencilAttachmentFormat = static_cast<VkFormat>(stencil_attachment_format),
            .rasterizationSamples = static_cast<VkSampleCountFlagBits>(rasterization_samples)
        };
    }
};

struct CommandBufferInheritanceViewportScissorInfoNV {
    bool viewport_scissor2d;
    u32 viewport_depth_count;
    VkViewport* viewport_depths;
    
    VkCommandBufferInheritanceViewportScissorInfoNV raw() {
        return VkCommandBufferInheritanceViewportScissorInfoNV {
            .sType = VK_STRUCT_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV,
            .pNext = nullptr,
            .viewportScissor2D = static_cast<VkBool32>(viewport_scissor2d),
            .viewportDepthCount = viewport_depth_count,
            .pViewportDepths = viewport_depths
        };
    }
};

struct CommandBufferSubmitInfo {
    VkCommandBuffer command_buffer;
    u32 device_mask;
    
    VkCommandBufferSubmitInfo raw() {
        return VkCommandBufferSubmitInfo {
            .sType = VK_STRUCT_TYPE_COMMAND_BUFFER_SUBMIT_INFO,
            .pNext = nullptr,
            .commandBuffer = command_buffer,
            .deviceMask = device_mask
        };
    }
};

struct CommandPoolCreateInfo {
    VkCommandPoolCreateFlags flags;
    u32 queue_family_index;
    
    VkCommandPoolCreateInfo raw() {
        return VkCommandPoolCreateInfo {
            .sType = VK_STRUCT_TYPE_COMMAND_POOL_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .queueFamilyIndex = queue_family_index
        };
    }
};

struct ComponentMapping {
    ComponentSwizzle r;
    ComponentSwizzle g;
    ComponentSwizzle b;
    ComponentSwizzle a;
    
    VkComponentMapping raw() {
        return VkComponentMapping {
            .r = static_cast<VkComponentSwizzle>(r),
            .g = static_cast<VkComponentSwizzle>(g),
            .b = static_cast<VkComponentSwizzle>(b),
            .a = static_cast<VkComponentSwizzle>(a)
        };
    }
};

struct ComputePipelineCreateInfo {
    VkPipelineCreateFlags flags;
    PipelineShaderStageCreateInfo stage;
    VkPipelineLayout layout;
    VkPipeline base_pipeline_handle;
    i32 base_pipeline_index;
    
    VkComputePipelineCreateInfo raw() {
        return VkComputePipelineCreateInfo {
            .sType = VK_STRUCT_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .stage = stage.raw(),
            .layout = layout,
            .basePipelineHandle = base_pipeline_handle,
            .basePipelineIndex = base_pipeline_index
        };
    }
};

struct ComputePipelineIndirectBufferInfoNV {
    VkDeviceAddress device_address;
    VkDeviceSize size;
    VkDeviceAddress pipeline_device_address_capture_replay;
    
    VkComputePipelineIndirectBufferInfoNV raw() {
        return VkComputePipelineIndirectBufferInfoNV {
            .sType = VK_STRUCT_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV,
            .pNext = nullptr,
            .deviceAddress = device_address,
            .size = size,
            .pipelineDeviceAddressCaptureReplay = pipeline_device_address_capture_replay
        };
    }
};

struct ConditionalRenderingBeginInfoEXT {
    VkBuffer buffer;
    VkDeviceSize offset;
    VkConditionalRenderingFlagsEXT flags;
    
    VkConditionalRenderingBeginInfoEXT raw() {
        return VkConditionalRenderingBeginInfoEXT {
            .sType = VK_STRUCT_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT,
            .pNext = nullptr,
            .buffer = buffer,
            .offset = offset,
            .flags = flags
        };
    }
};

struct ConformanceVersion {
    uint8_t major;
    uint8_t minor;
    uint8_t subminor;
    uint8_t patch;
    
    VkConformanceVersion raw() {
        return VkConformanceVersion {
            .major = major,
            .minor = minor,
            .subminor = subminor,
            .patch = patch
        };
    }
};

struct ConvertCooperativeVectorMatrixInfoNV {
    size_t src_size;
    VkDeviceOrHostAddressConstKHR src_data;
    size_t* dst_size;
    VkDeviceOrHostAddressKHR dst_data;
    ComponentTypeKHR src_component_type;
    ComponentTypeKHR dst_component_type;
    u32 num_rows;
    u32 num_columns;
    CooperativeVectorMatrixLayoutNV src_layout;
    size_t src_stride;
    CooperativeVectorMatrixLayoutNV dst_layout;
    size_t dst_stride;
    
    VkConvertCooperativeVectorMatrixInfoNV raw() {
        return VkConvertCooperativeVectorMatrixInfoNV {
            .sType = VK_STRUCT_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV,
            .pNext = nullptr,
            .srcSize = src_size,
            .srcData = src_data,
            .pDstSize = dst_size,
            .dstData = dst_data,
            .srcComponentType = static_cast<VkComponentTypeKHR>(src_component_type),
            .dstComponentType = static_cast<VkComponentTypeKHR>(dst_component_type),
            .numRows = num_rows,
            .numColumns = num_columns,
            .srcLayout = static_cast<VkCooperativeVectorMatrixLayoutNV>(src_layout),
            .srcStride = src_stride,
            .dstLayout = static_cast<VkCooperativeVectorMatrixLayoutNV>(dst_layout),
            .dstStride = dst_stride
        };
    }
};

struct CooperativeMatrixFlexibleDimensionsPropertiesNV {
    u32 mgranularity;
    u32 ngranularity;
    u32 kgranularity;
    ComponentTypeKHR atype;
    ComponentTypeKHR btype;
    ComponentTypeKHR ctype;
    ComponentTypeKHR result_type;
    bool saturating_accumulation;
    ScopeKHR scope;
    u32 workgroup_invocations;
    
    VkCooperativeMatrixFlexibleDimensionsPropertiesNV raw() {
        return VkCooperativeMatrixFlexibleDimensionsPropertiesNV {
            .sType = VK_STRUCT_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV,
            .pNext = nullptr,
            .MGranularity = mgranularity,
            .NGranularity = ngranularity,
            .KGranularity = kgranularity,
            .AType = static_cast<VkComponentTypeKHR>(atype),
            .BType = static_cast<VkComponentTypeKHR>(btype),
            .CType = static_cast<VkComponentTypeKHR>(ctype),
            .ResultType = static_cast<VkComponentTypeKHR>(result_type),
            .saturatingAccumulation = static_cast<VkBool32>(saturating_accumulation),
            .scope = static_cast<VkScopeKHR>(scope),
            .workgroupInvocations = workgroup_invocations
        };
    }
};

struct CooperativeMatrixPropertiesKHR {
    u32 msize;
    u32 nsize;
    u32 ksize;
    ComponentTypeKHR atype;
    ComponentTypeKHR btype;
    ComponentTypeKHR ctype;
    ComponentTypeKHR result_type;
    bool saturating_accumulation;
    ScopeKHR scope;
    
    VkCooperativeMatrixPropertiesKHR raw() {
        return VkCooperativeMatrixPropertiesKHR {
            .sType = VK_STRUCT_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
            .pNext = nullptr,
            .MSize = msize,
            .NSize = nsize,
            .KSize = ksize,
            .AType = static_cast<VkComponentTypeKHR>(atype),
            .BType = static_cast<VkComponentTypeKHR>(btype),
            .CType = static_cast<VkComponentTypeKHR>(ctype),
            .ResultType = static_cast<VkComponentTypeKHR>(result_type),
            .saturatingAccumulation = static_cast<VkBool32>(saturating_accumulation),
            .scope = static_cast<VkScopeKHR>(scope)
        };
    }
};

struct CooperativeMatrixPropertiesNV {
    u32 msize;
    u32 nsize;
    u32 ksize;
    VkComponentTypeNV atype;
    VkComponentTypeNV btype;
    VkComponentTypeNV ctype;
    VkComponentTypeNV dtype;
    VkScopeNV scope;
    
    VkCooperativeMatrixPropertiesNV raw() {
        return VkCooperativeMatrixPropertiesNV {
            .sType = VK_STRUCT_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV,
            .pNext = nullptr,
            .MSize = msize,
            .NSize = nsize,
            .KSize = ksize,
            .AType = atype,
            .BType = btype,
            .CType = ctype,
            .DType = dtype,
            .scope = scope
        };
    }
};

struct CooperativeVectorPropertiesNV {
    ComponentTypeKHR input_type;
    ComponentTypeKHR input_interpretation;
    ComponentTypeKHR matrix_interpretation;
    ComponentTypeKHR bias_interpretation;
    ComponentTypeKHR result_type;
    bool transpose;
    
    VkCooperativeVectorPropertiesNV raw() {
        return VkCooperativeVectorPropertiesNV {
            .sType = VK_STRUCT_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV,
            .pNext = nullptr,
            .inputType = static_cast<VkComponentTypeKHR>(input_type),
            .inputInterpretation = static_cast<VkComponentTypeKHR>(input_interpretation),
            .matrixInterpretation = static_cast<VkComponentTypeKHR>(matrix_interpretation),
            .biasInterpretation = static_cast<VkComponentTypeKHR>(bias_interpretation),
            .resultType = static_cast<VkComponentTypeKHR>(result_type),
            .transpose = static_cast<VkBool32>(transpose)
        };
    }
};

struct CopyAccelerationStructureInfoKHR {
    VkAccelerationStructureKHR src;
    VkAccelerationStructureKHR dst;
    CopyAccelerationStructureModeKHR mode;
    
    VkCopyAccelerationStructureInfoKHR raw() {
        return VkCopyAccelerationStructureInfoKHR {
            .sType = VK_STRUCT_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR,
            .pNext = nullptr,
            .src = src,
            .dst = dst,
            .mode = static_cast<VkCopyAccelerationStructureModeKHR>(mode)
        };
    }
};

struct CopyAccelerationStructureToMemoryInfoKHR {
    VkAccelerationStructureKHR src;
    VkDeviceOrHostAddressKHR dst;
    CopyAccelerationStructureModeKHR mode;
    
    VkCopyAccelerationStructureToMemoryInfoKHR raw() {
        return VkCopyAccelerationStructureToMemoryInfoKHR {
            .sType = VK_STRUCT_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,
            .pNext = nullptr,
            .src = src,
            .dst = dst,
            .mode = static_cast<VkCopyAccelerationStructureModeKHR>(mode)
        };
    }
};

struct CopyBufferInfo2 {
    VkBuffer src_buffer;
    VkBuffer dst_buffer;
    u32 region_count;
    VkBufferCopy2* regions;
    
    VkCopyBufferInfo2 raw() {
        return VkCopyBufferInfo2 {
            .sType = VK_STRUCT_TYPE_COPY_BUFFER_INFO2,
            .pNext = nullptr,
            .srcBuffer = src_buffer,
            .dstBuffer = dst_buffer,
            .regionCount = region_count,
            .pRegions = regions
        };
    }
};

struct CopyBufferToImageInfo2 {
    VkBuffer src_buffer;
    VkImage dst_image;
    ImageLayout dst_image_layout;
    u32 region_count;
    VkBufferImageCopy2* regions;
    
    VkCopyBufferToImageInfo2 raw() {
        return VkCopyBufferToImageInfo2 {
            .sType = VK_STRUCT_TYPE_COPY_BUFFER_TO_IMAGE_INFO2,
            .pNext = nullptr,
            .srcBuffer = src_buffer,
            .dstImage = dst_image,
            .dstImageLayout = static_cast<VkImageLayout>(dst_image_layout),
            .regionCount = region_count,
            .pRegions = regions
        };
    }
};

struct CopyCommandTransformInfoQCOM {
    SurfaceTransformFlagsKHR transform;
    
    VkCopyCommandTransformInfoQCOM raw() {
        return VkCopyCommandTransformInfoQCOM {
            .sType = VK_STRUCT_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM,
            .pNext = nullptr,
            .transform = static_cast<VkSurfaceTransformFlagBitsKHR>(transform)
        };
    }
};

struct CopyDescriptorSet {
    VkDescriptorSet src_set;
    u32 src_binding;
    u32 src_array_element;
    VkDescriptorSet dst_set;
    u32 dst_binding;
    u32 dst_array_element;
    u32 descriptor_count;
    
    VkCopyDescriptorSet raw() {
        return VkCopyDescriptorSet {
            .sType = VK_STRUCT_TYPE_COPY_DESCRIPTOR_SET,
            .pNext = nullptr,
            .srcSet = src_set,
            .srcBinding = src_binding,
            .srcArrayElement = src_array_element,
            .dstSet = dst_set,
            .dstBinding = dst_binding,
            .dstArrayElement = dst_array_element,
            .descriptorCount = descriptor_count
        };
    }
};

struct CopyImageInfo2 {
    VkImage src_image;
    ImageLayout src_image_layout;
    VkImage dst_image;
    ImageLayout dst_image_layout;
    u32 region_count;
    VkImageCopy2* regions;
    
    VkCopyImageInfo2 raw() {
        return VkCopyImageInfo2 {
            .sType = VK_STRUCT_TYPE_COPY_IMAGE_INFO2,
            .pNext = nullptr,
            .srcImage = src_image,
            .srcImageLayout = static_cast<VkImageLayout>(src_image_layout),
            .dstImage = dst_image,
            .dstImageLayout = static_cast<VkImageLayout>(dst_image_layout),
            .regionCount = region_count,
            .pRegions = regions
        };
    }
};

struct CopyImageToBufferInfo2 {
    VkImage src_image;
    ImageLayout src_image_layout;
    VkBuffer dst_buffer;
    u32 region_count;
    VkBufferImageCopy2* regions;
    
    VkCopyImageToBufferInfo2 raw() {
        return VkCopyImageToBufferInfo2 {
            .sType = VK_STRUCT_TYPE_COPY_IMAGE_TO_BUFFER_INFO2,
            .pNext = nullptr,
            .srcImage = src_image,
            .srcImageLayout = static_cast<VkImageLayout>(src_image_layout),
            .dstBuffer = dst_buffer,
            .regionCount = region_count,
            .pRegions = regions
        };
    }
};

struct CopyImageToImageInfo {
    VkHostImageCopyFlags flags;
    VkImage src_image;
    ImageLayout src_image_layout;
    VkImage dst_image;
    ImageLayout dst_image_layout;
    u32 region_count;
    VkImageCopy2* regions;
    
    VkCopyImageToImageInfo raw() {
        return VkCopyImageToImageInfo {
            .sType = VK_STRUCT_TYPE_COPY_IMAGE_TO_IMAGE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .srcImage = src_image,
            .srcImageLayout = static_cast<VkImageLayout>(src_image_layout),
            .dstImage = dst_image,
            .dstImageLayout = static_cast<VkImageLayout>(dst_image_layout),
            .regionCount = region_count,
            .pRegions = regions
        };
    }
};

struct CopyImageToMemoryInfo {
    VkHostImageCopyFlags flags;
    VkImage src_image;
    ImageLayout src_image_layout;
    u32 region_count;
    VkImageToMemoryCopy* regions;
    
    VkCopyImageToMemoryInfo raw() {
        return VkCopyImageToMemoryInfo {
            .sType = VK_STRUCT_TYPE_COPY_IMAGE_TO_MEMORY_INFO,
            .pNext = nullptr,
            .flags = flags,
            .srcImage = src_image,
            .srcImageLayout = static_cast<VkImageLayout>(src_image_layout),
            .regionCount = region_count,
            .pRegions = regions
        };
    }
};

struct CopyMemoryIndirectCommandNV {
    VkDeviceAddress src_address;
    VkDeviceAddress dst_address;
    VkDeviceSize size;
    
    VkCopyMemoryIndirectCommandNV raw() {
        return VkCopyMemoryIndirectCommandNV {
            .srcAddress = src_address,
            .dstAddress = dst_address,
            .size = size
        };
    }
};

struct CopyMemoryToAccelerationStructureInfoKHR {
    VkDeviceOrHostAddressConstKHR src;
    VkAccelerationStructureKHR dst;
    CopyAccelerationStructureModeKHR mode;
    
    VkCopyMemoryToAccelerationStructureInfoKHR raw() {
        return VkCopyMemoryToAccelerationStructureInfoKHR {
            .sType = VK_STRUCT_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,
            .pNext = nullptr,
            .src = src,
            .dst = dst,
            .mode = static_cast<VkCopyAccelerationStructureModeKHR>(mode)
        };
    }
};

struct CopyMemoryToImageIndirectCommandNV {
    VkDeviceAddress src_address;
    u32 buffer_row_length;
    u32 buffer_image_height;
    ImageSubresourceLayers image_subresource;
    Offset3D image_offset;
    Extent3D image_extent;
    
    VkCopyMemoryToImageIndirectCommandNV raw() {
        return VkCopyMemoryToImageIndirectCommandNV {
            .srcAddress = src_address,
            .bufferRowLength = buffer_row_length,
            .bufferImageHeight = buffer_image_height,
            .imageSubresource = image_subresource.raw(),
            .imageOffset = image_offset.raw(),
            .imageExtent = image_extent.raw()
        };
    }
};

struct CopyMemoryToImageInfo {
    VkHostImageCopyFlags flags;
    VkImage dst_image;
    ImageLayout dst_image_layout;
    u32 region_count;
    VkMemoryToImageCopy* regions;
    
    VkCopyMemoryToImageInfo raw() {
        return VkCopyMemoryToImageInfo {
            .sType = VK_STRUCT_TYPE_COPY_MEMORY_TO_IMAGE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .dstImage = dst_image,
            .dstImageLayout = static_cast<VkImageLayout>(dst_image_layout),
            .regionCount = region_count,
            .pRegions = regions
        };
    }
};

struct CopyMemoryToMicromapInfoEXT {
    VkDeviceOrHostAddressConstKHR src;
    VkMicromapEXT dst;
    CopyMicromapModeEXT mode;
    
    VkCopyMemoryToMicromapInfoEXT raw() {
        return VkCopyMemoryToMicromapInfoEXT {
            .sType = VK_STRUCT_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT,
            .pNext = nullptr,
            .src = src,
            .dst = dst,
            .mode = static_cast<VkCopyMicromapModeEXT>(mode)
        };
    }
};

struct CopyMicromapInfoEXT {
    VkMicromapEXT src;
    VkMicromapEXT dst;
    CopyMicromapModeEXT mode;
    
    VkCopyMicromapInfoEXT raw() {
        return VkCopyMicromapInfoEXT {
            .sType = VK_STRUCT_TYPE_COPY_MICROMAP_INFO_EXT,
            .pNext = nullptr,
            .src = src,
            .dst = dst,
            .mode = static_cast<VkCopyMicromapModeEXT>(mode)
        };
    }
};

struct CopyMicromapToMemoryInfoEXT {
    VkMicromapEXT src;
    VkDeviceOrHostAddressKHR dst;
    CopyMicromapModeEXT mode;
    
    VkCopyMicromapToMemoryInfoEXT raw() {
        return VkCopyMicromapToMemoryInfoEXT {
            .sType = VK_STRUCT_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT,
            .pNext = nullptr,
            .src = src,
            .dst = dst,
            .mode = static_cast<VkCopyMicromapModeEXT>(mode)
        };
    }
};

struct CuFunctionCreateInfoNVX {
    VkCuModuleNVX module;
    char* name;
    
    VkCuFunctionCreateInfoNVX raw() {
        return VkCuFunctionCreateInfoNVX {
            .sType = VK_STRUCT_TYPE_CU_FUNCTION_CREATE_INFO_NVX,
            .pNext = nullptr,
            .module = module,
            .pName = name
        };
    }
};

struct CuLaunchInfoNVX {
    VkCuFunctionNVX function;
    u32 grid_dim_x;
    u32 grid_dim_y;
    u32 grid_dim_z;
    u32 block_dim_x;
    u32 block_dim_y;
    u32 block_dim_z;
    u32 shared_mem_bytes;
    size_t param_count;
    void** params;
    size_t extra_count;
    void** extras;
    
    VkCuLaunchInfoNVX raw() {
        return VkCuLaunchInfoNVX {
            .sType = VK_STRUCT_TYPE_CU_LAUNCH_INFO_NVX,
            .pNext = nullptr,
            .function = function,
            .gridDimX = grid_dim_x,
            .gridDimY = grid_dim_y,
            .gridDimZ = grid_dim_z,
            .blockDimX = block_dim_x,
            .blockDimY = block_dim_y,
            .blockDimZ = block_dim_z,
            .sharedMemBytes = shared_mem_bytes,
            .paramCount = param_count,
            .pParams = params,
            .extraCount = extra_count,
            .pExtras = extras
        };
    }
};

struct CuModuleCreateInfoNVX {
    size_t data_size;
    void* data;
    
    VkCuModuleCreateInfoNVX raw() {
        return VkCuModuleCreateInfoNVX {
            .sType = VK_STRUCT_TYPE_CU_MODULE_CREATE_INFO_NVX,
            .pNext = nullptr,
            .dataSize = data_size,
            .pData = data
        };
    }
};

struct CuModuleTexturingModeCreateInfoNVX {
    bool use64bit_texturing;
    
    VkCuModuleTexturingModeCreateInfoNVX raw() {
        return VkCuModuleTexturingModeCreateInfoNVX {
            .sType = VK_STRUCT_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX,
            .pNext = nullptr,
            .use64bitTexturing = static_cast<VkBool32>(use64bit_texturing)
        };
    }
};

struct CudaFunctionCreateInfoNV {
    VkCudaModuleNV module;
    char* name;
    
    VkCudaFunctionCreateInfoNV raw() {
        return VkCudaFunctionCreateInfoNV {
            .sType = VK_STRUCT_TYPE_CUDA_FUNCTION_CREATE_INFO_NV,
            .pNext = nullptr,
            .module = module,
            .pName = name
        };
    }
};

struct CudaLaunchInfoNV {
    VkCudaFunctionNV function;
    u32 grid_dim_x;
    u32 grid_dim_y;
    u32 grid_dim_z;
    u32 block_dim_x;
    u32 block_dim_y;
    u32 block_dim_z;
    u32 shared_mem_bytes;
    size_t param_count;
    void** params;
    size_t extra_count;
    void** extras;
    
    VkCudaLaunchInfoNV raw() {
        return VkCudaLaunchInfoNV {
            .sType = VK_STRUCT_TYPE_CUDA_LAUNCH_INFO_NV,
            .pNext = nullptr,
            .function = function,
            .gridDimX = grid_dim_x,
            .gridDimY = grid_dim_y,
            .gridDimZ = grid_dim_z,
            .blockDimX = block_dim_x,
            .blockDimY = block_dim_y,
            .blockDimZ = block_dim_z,
            .sharedMemBytes = shared_mem_bytes,
            .paramCount = param_count,
            .pParams = params,
            .extraCount = extra_count,
            .pExtras = extras
        };
    }
};

struct CudaModuleCreateInfoNV {
    size_t data_size;
    void* data;
    
    VkCudaModuleCreateInfoNV raw() {
        return VkCudaModuleCreateInfoNV {
            .sType = VK_STRUCT_TYPE_CUDA_MODULE_CREATE_INFO_NV,
            .pNext = nullptr,
            .dataSize = data_size,
            .pData = data
        };
    }
};

struct DebugMarkerMarkerInfoEXT {
    char* marker_name;
    float[4] color;
    
    VkDebugMarkerMarkerInfoEXT raw() {
        return VkDebugMarkerMarkerInfoEXT {
            .sType = VK_STRUCT_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
            .pNext = nullptr,
            .pMarkerName = marker_name,
            .color = color
        };
    }
};

struct DebugMarkerObjectNameInfoEXT {
    DebugReportObjectTypeEXT object_type;
    uint64_t object;
    char* object_name;
    
    VkDebugMarkerObjectNameInfoEXT raw() {
        return VkDebugMarkerObjectNameInfoEXT {
            .sType = VK_STRUCT_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
            .pNext = nullptr,
            .objectType = static_cast<VkDebugReportObjectTypeEXT>(object_type),
            .object = object,
            .pObjectName = object_name
        };
    }
};

struct DebugMarkerObjectTagInfoEXT {
    DebugReportObjectTypeEXT object_type;
    uint64_t object;
    uint64_t tag_name;
    size_t tag_size;
    void* tag;
    
    VkDebugMarkerObjectTagInfoEXT raw() {
        return VkDebugMarkerObjectTagInfoEXT {
            .sType = VK_STRUCT_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT,
            .pNext = nullptr,
            .objectType = static_cast<VkDebugReportObjectTypeEXT>(object_type),
            .object = object,
            .tagName = tag_name,
            .tagSize = tag_size,
            .pTag = tag
        };
    }
};

struct DebugReportCallbackCreateInfoEXT {
    VkDebugReportFlagsEXT flags;
    PFN_vkDebugReportCallbackEXT pfn_callback;
    void* user_data;
    
    VkDebugReportCallbackCreateInfoEXT raw() {
        return VkDebugReportCallbackCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags,
            .pfnCallback = pfn_callback,
            .pUserData = user_data
        };
    }
};

struct DebugUtilsLabelEXT {
    char* label_name;
    float[4] color;
    
    VkDebugUtilsLabelEXT raw() {
        return VkDebugUtilsLabelEXT {
            .sType = VK_STRUCT_TYPE_DEBUG_UTILS_LABEL_EXT,
            .pNext = nullptr,
            .pLabelName = label_name,
            .color = color
        };
    }
};

struct DebugUtilsMessengerCallbackDataEXT {
    VkDebugUtilsMessengerCallbackDataFlagsEXT flags;
    char* message_id_name;
    i32 message_id_number;
    char* message;
    u32 queue_label_count;
    VkDebugUtilsLabelEXT* queue_labels;
    u32 cmd_buf_label_count;
    VkDebugUtilsLabelEXT* cmd_buf_labels;
    u32 object_count;
    VkDebugUtilsObjectNameInfoEXT* objects;
    
    VkDebugUtilsMessengerCallbackDataEXT raw() {
        return VkDebugUtilsMessengerCallbackDataEXT {
            .sType = VK_STRUCT_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT,
            .pNext = nullptr,
            .flags = flags,
            .pMessageIdName = message_id_name,
            .messageIdNumber = message_id_number,
            .pMessage = message,
            .queueLabelCount = queue_label_count,
            .pQueueLabels = queue_labels,
            .cmdBufLabelCount = cmd_buf_label_count,
            .pCmdBufLabels = cmd_buf_labels,
            .objectCount = object_count,
            .pObjects = objects
        };
    }
};

struct DebugUtilsMessengerCreateInfoEXT {
    VkDebugUtilsMessengerCreateFlagsEXT flags;
    VkDebugUtilsMessageSeverityFlagsEXT message_severity;
    VkDebugUtilsMessageTypeFlagsEXT message_type;
    PFN_vkDebugUtilsMessengerCallbackEXT pfn_user_callback;
    void* user_data;
    
    VkDebugUtilsMessengerCreateInfoEXT raw() {
        return VkDebugUtilsMessengerCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags,
            .messageSeverity = message_severity,
            .messageType = message_type,
            .pfnUserCallback = pfn_user_callback,
            .pUserData = user_data
        };
    }
};

struct DebugUtilsObjectNameInfoEXT {
    ObjectType object_type;
    uint64_t object_handle;
    char* object_name;
    
    VkDebugUtilsObjectNameInfoEXT raw() {
        return VkDebugUtilsObjectNameInfoEXT {
            .sType = VK_STRUCT_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
            .pNext = nullptr,
            .objectType = static_cast<VkObjectType>(object_type),
            .objectHandle = object_handle,
            .pObjectName = object_name
        };
    }
};

struct DebugUtilsObjectTagInfoEXT {
    ObjectType object_type;
    uint64_t object_handle;
    uint64_t tag_name;
    size_t tag_size;
    void* tag;
    
    VkDebugUtilsObjectTagInfoEXT raw() {
        return VkDebugUtilsObjectTagInfoEXT {
            .sType = VK_STRUCT_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT,
            .pNext = nullptr,
            .objectType = static_cast<VkObjectType>(object_type),
            .objectHandle = object_handle,
            .tagName = tag_name,
            .tagSize = tag_size,
            .pTag = tag
        };
    }
};

struct DecompressMemoryRegionNV {
    VkDeviceAddress src_address;
    VkDeviceAddress dst_address;
    VkDeviceSize compressed_size;
    VkDeviceSize decompressed_size;
    VkMemoryDecompressionMethodFlagsNV decompression_method;
    
    VkDecompressMemoryRegionNV raw() {
        return VkDecompressMemoryRegionNV {
            .srcAddress = src_address,
            .dstAddress = dst_address,
            .compressedSize = compressed_size,
            .decompressedSize = decompressed_size,
            .decompressionMethod = decompression_method
        };
    }
};

struct DedicatedAllocationBufferCreateInfoNV {
    bool dedicated_allocation;
    
    VkDedicatedAllocationBufferCreateInfoNV raw() {
        return VkDedicatedAllocationBufferCreateInfoNV {
            .sType = VK_STRUCT_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV,
            .pNext = nullptr,
            .dedicatedAllocation = static_cast<VkBool32>(dedicated_allocation)
        };
    }
};

struct DedicatedAllocationImageCreateInfoNV {
    bool dedicated_allocation;
    
    VkDedicatedAllocationImageCreateInfoNV raw() {
        return VkDedicatedAllocationImageCreateInfoNV {
            .sType = VK_STRUCT_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
            .pNext = nullptr,
            .dedicatedAllocation = static_cast<VkBool32>(dedicated_allocation)
        };
    }
};

struct DedicatedAllocationMemoryAllocateInfoNV {
    VkImage image;
    VkBuffer buffer;
    
    VkDedicatedAllocationMemoryAllocateInfoNV raw() {
        return VkDedicatedAllocationMemoryAllocateInfoNV {
            .sType = VK_STRUCT_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
            .pNext = nullptr,
            .image = image,
            .buffer = buffer
        };
    }
};

struct DependencyInfo {
    VkDependencyFlags dependency_flags;
    u32 memory_barrier_count;
    VkMemoryBarrier2* memory_barriers;
    u32 buffer_memory_barrier_count;
    VkBufferMemoryBarrier2* buffer_memory_barriers;
    u32 image_memory_barrier_count;
    VkImageMemoryBarrier2* image_memory_barriers;
    
    VkDependencyInfo raw() {
        return VkDependencyInfo {
            .sType = VK_STRUCT_TYPE_DEPENDENCY_INFO,
            .pNext = nullptr,
            .dependencyFlags = dependency_flags,
            .memoryBarrierCount = memory_barrier_count,
            .pMemoryBarriers = memory_barriers,
            .bufferMemoryBarrierCount = buffer_memory_barrier_count,
            .pBufferMemoryBarriers = buffer_memory_barriers,
            .imageMemoryBarrierCount = image_memory_barrier_count,
            .pImageMemoryBarriers = image_memory_barriers
        };
    }
};

struct DepthBiasInfoEXT {
    f32 depth_bias_constant_factor;
    f32 depth_bias_clamp;
    f32 depth_bias_slope_factor;
    
    VkDepthBiasInfoEXT raw() {
        return VkDepthBiasInfoEXT {
            .sType = VK_STRUCT_TYPE_DEPTH_BIAS_INFO_EXT,
            .pNext = nullptr,
            .depthBiasConstantFactor = depth_bias_constant_factor,
            .depthBiasClamp = depth_bias_clamp,
            .depthBiasSlopeFactor = depth_bias_slope_factor
        };
    }
};

struct DepthBiasRepresentationInfoEXT {
    DepthBiasRepresentationEXT depth_bias_representation;
    bool depth_bias_exact;
    
    VkDepthBiasRepresentationInfoEXT raw() {
        return VkDepthBiasRepresentationInfoEXT {
            .sType = VK_STRUCT_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT,
            .pNext = nullptr,
            .depthBiasRepresentation = static_cast<VkDepthBiasRepresentationEXT>(depth_bias_representation),
            .depthBiasExact = static_cast<VkBool32>(depth_bias_exact)
        };
    }
};

struct DepthClampRangeEXT {
    f32 min_depth_clamp;
    f32 max_depth_clamp;
    
    VkDepthClampRangeEXT raw() {
        return VkDepthClampRangeEXT {
            .minDepthClamp = min_depth_clamp,
            .maxDepthClamp = max_depth_clamp
        };
    }
};

struct DescriptorAddressInfoEXT {
    VkDeviceAddress address;
    VkDeviceSize range;
    Format format;
    
    VkDescriptorAddressInfoEXT raw() {
        return VkDescriptorAddressInfoEXT {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT,
            .pNext = nullptr,
            .address = address,
            .range = range,
            .format = static_cast<VkFormat>(format)
        };
    }
};

struct DescriptorBufferBindingInfoEXT {
    VkDeviceAddress address;
    VkBufferUsageFlags usage;
    
    VkDescriptorBufferBindingInfoEXT raw() {
        return VkDescriptorBufferBindingInfoEXT {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT,
            .pNext = nullptr,
            .address = address,
            .usage = usage
        };
    }
};

struct DescriptorBufferBindingPushDescriptorBufferHandleEXT {
    VkBuffer buffer;
    
    VkDescriptorBufferBindingPushDescriptorBufferHandleEXT raw() {
        return VkDescriptorBufferBindingPushDescriptorBufferHandleEXT {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT,
            .pNext = nullptr,
            .buffer = buffer
        };
    }
};

struct DescriptorBufferInfo {
    VkBuffer buffer;
    VkDeviceSize offset;
    VkDeviceSize range;
    
    VkDescriptorBufferInfo raw() {
        return VkDescriptorBufferInfo {
            .buffer = buffer,
            .offset = offset,
            .range = range
        };
    }
};

struct DescriptorGetInfoEXT {
    DescriptorType type;
    VkDescriptorDataEXT data;
    
    VkDescriptorGetInfoEXT raw() {
        return VkDescriptorGetInfoEXT {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_GET_INFO_EXT,
            .pNext = nullptr,
            .type = static_cast<VkDescriptorType>(type),
            .data = data
        };
    }
};

struct DescriptorImageInfo {
    VkSampler sampler;
    VkImageView image_view;
    ImageLayout image_layout;
    
    VkDescriptorImageInfo raw() {
        return VkDescriptorImageInfo {
            .sampler = sampler,
            .imageView = image_view,
            .imageLayout = static_cast<VkImageLayout>(image_layout)
        };
    }
};

struct DescriptorPoolCreateInfo {
    VkDescriptorPoolCreateFlags flags;
    u32 max_sets;
    u32 pool_size_count;
    VkDescriptorPoolSize* pool_sizes;
    
    VkDescriptorPoolCreateInfo raw() {
        return VkDescriptorPoolCreateInfo {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_POOL_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .maxSets = max_sets,
            .poolSizeCount = pool_size_count,
            .pPoolSizes = pool_sizes
        };
    }
};

struct DescriptorPoolInlineUniformBlockCreateInfo {
    u32 max_inline_uniform_block_bindings;
    
    VkDescriptorPoolInlineUniformBlockCreateInfo raw() {
        return VkDescriptorPoolInlineUniformBlockCreateInfo {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO,
            .pNext = nullptr,
            .maxInlineUniformBlockBindings = max_inline_uniform_block_bindings
        };
    }
};

struct DescriptorPoolSize {
    DescriptorType type;
    u32 descriptor_count;
    
    VkDescriptorPoolSize raw() {
        return VkDescriptorPoolSize {
            .type = static_cast<VkDescriptorType>(type),
            .descriptorCount = descriptor_count
        };
    }
};

struct DescriptorSetAllocateInfo {
    VkDescriptorPool descriptor_pool;
    u32 descriptor_set_count;
    VkDescriptorSetLayout* set_layouts;
    
    VkDescriptorSetAllocateInfo raw() {
        return VkDescriptorSetAllocateInfo {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
            .pNext = nullptr,
            .descriptorPool = descriptor_pool,
            .descriptorSetCount = descriptor_set_count,
            .pSetLayouts = set_layouts
        };
    }
};

struct DescriptorSetBindingReferenceVALVE {
    VkDescriptorSetLayout descriptor_set_layout;
    u32 binding;
    
    VkDescriptorSetBindingReferenceVALVE raw() {
        return VkDescriptorSetBindingReferenceVALVE {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE,
            .pNext = nullptr,
            .descriptorSetLayout = descriptor_set_layout,
            .binding = binding
        };
    }
};

struct DescriptorSetLayoutBinding {
    u32 binding;
    DescriptorType descriptor_type;
    u32 descriptor_count;
    VkShaderStageFlags stage_flags;
    VkSampler* immutable_samplers;
    
    VkDescriptorSetLayoutBinding raw() {
        return VkDescriptorSetLayoutBinding {
            .binding = binding,
            .descriptorType = static_cast<VkDescriptorType>(descriptor_type),
            .descriptorCount = descriptor_count,
            .stageFlags = stage_flags,
            .pImmutableSamplers = immutable_samplers
        };
    }
};

struct DescriptorSetLayoutBindingFlagsCreateInfo {
    u32 binding_count;
    VkDescriptorBindingFlags* binding_flags;
    
    VkDescriptorSetLayoutBindingFlagsCreateInfo raw() {
        return VkDescriptorSetLayoutBindingFlagsCreateInfo {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO,
            .pNext = nullptr,
            .bindingCount = binding_count,
            .pBindingFlags = binding_flags
        };
    }
};

struct DescriptorSetLayoutCreateInfo {
    VkDescriptorSetLayoutCreateFlags flags;
    u32 binding_count;
    VkDescriptorSetLayoutBinding* bindings;
    
    VkDescriptorSetLayoutCreateInfo raw() {
        return VkDescriptorSetLayoutCreateInfo {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .bindingCount = binding_count,
            .pBindings = bindings
        };
    }
};

struct DescriptorSetLayoutHostMappingInfoVALVE {
    size_t descriptor_offset;
    u32 descriptor_size;
    
    VkDescriptorSetLayoutHostMappingInfoVALVE raw() {
        return VkDescriptorSetLayoutHostMappingInfoVALVE {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE,
            .pNext = nullptr,
            .descriptorOffset = descriptor_offset,
            .descriptorSize = descriptor_size
        };
    }
};

struct DescriptorSetLayoutSupport {
    bool supported;
    
    VkDescriptorSetLayoutSupport raw() {
        return VkDescriptorSetLayoutSupport {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
            .pNext = nullptr,
            .supported = static_cast<VkBool32>(supported)
        };
    }
};

struct DescriptorSetVariableDescriptorCountAllocateInfo {
    u32 descriptor_set_count;
    uint32_t* descriptor_counts;
    
    VkDescriptorSetVariableDescriptorCountAllocateInfo raw() {
        return VkDescriptorSetVariableDescriptorCountAllocateInfo {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO,
            .pNext = nullptr,
            .descriptorSetCount = descriptor_set_count,
            .pDescriptorCounts = descriptor_counts
        };
    }
};

struct DescriptorSetVariableDescriptorCountLayoutSupport {
    u32 max_variable_descriptor_count;
    
    VkDescriptorSetVariableDescriptorCountLayoutSupport raw() {
        return VkDescriptorSetVariableDescriptorCountLayoutSupport {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT,
            .pNext = nullptr,
            .maxVariableDescriptorCount = max_variable_descriptor_count
        };
    }
};

struct DescriptorUpdateTemplateCreateInfo {
    VkDescriptorUpdateTemplateCreateFlags flags;
    u32 descriptor_update_entry_count;
    VkDescriptorUpdateTemplateEntry* descriptor_update_entries;
    DescriptorUpdateTemplateType template_type;
    VkDescriptorSetLayout descriptor_set_layout;
    PipelineBindPoint pipeline_bind_point;
    VkPipelineLayout pipeline_layout;
    u32 set;
    
    VkDescriptorUpdateTemplateCreateInfo raw() {
        return VkDescriptorUpdateTemplateCreateInfo {
            .sType = VK_STRUCT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .descriptorUpdateEntryCount = descriptor_update_entry_count,
            .pDescriptorUpdateEntries = descriptor_update_entries,
            .templateType = static_cast<VkDescriptorUpdateTemplateType>(template_type),
            .descriptorSetLayout = descriptor_set_layout,
            .pipelineBindPoint = static_cast<VkPipelineBindPoint>(pipeline_bind_point),
            .pipelineLayout = pipeline_layout,
            .set = set
        };
    }
};

struct DescriptorUpdateTemplateEntry {
    u32 dst_binding;
    u32 dst_array_element;
    u32 descriptor_count;
    DescriptorType descriptor_type;
    size_t offset;
    size_t stride;
    
    VkDescriptorUpdateTemplateEntry raw() {
        return VkDescriptorUpdateTemplateEntry {
            .dstBinding = dst_binding,
            .dstArrayElement = dst_array_element,
            .descriptorCount = descriptor_count,
            .descriptorType = static_cast<VkDescriptorType>(descriptor_type),
            .offset = offset,
            .stride = stride
        };
    }
};

struct DeviceAddressBindingCallbackDataEXT {
    VkDeviceAddressBindingFlagsEXT flags;
    VkDeviceAddress base_address;
    VkDeviceSize size;
    DeviceAddressBindingTypeEXT binding_type;
    
    VkDeviceAddressBindingCallbackDataEXT raw() {
        return VkDeviceAddressBindingCallbackDataEXT {
            .sType = VK_STRUCT_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT,
            .pNext = nullptr,
            .flags = flags,
            .baseAddress = base_address,
            .size = size,
            .bindingType = static_cast<VkDeviceAddressBindingTypeEXT>(binding_type)
        };
    }
};

struct DeviceBufferMemoryRequirements {
    VkBufferCreateInfo* create_info;
    
    VkDeviceBufferMemoryRequirements raw() {
        return VkDeviceBufferMemoryRequirements {
            .sType = VK_STRUCT_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS,
            .pNext = nullptr,
            .pCreateInfo = create_info
        };
    }
};

struct DeviceCreateInfo {
    VkDeviceCreateFlags flags;
    u32 queue_create_info_count;
    VkDeviceQueueCreateInfo* queue_create_infos;
    u32 enabled_layer_count;
    char** pp_enabled_layer_names;
    u32 enabled_extension_count;
    char** pp_enabled_extension_names;
    VkPhysicalDeviceFeatures* enabled_features;
    
    VkDeviceCreateInfo raw() {
        return VkDeviceCreateInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .queueCreateInfoCount = queue_create_info_count,
            .pQueueCreateInfos = queue_create_infos,
            .enabledLayerCount = enabled_layer_count,
            .ppEnabledLayerNames = pp_enabled_layer_names,
            .enabledExtensionCount = enabled_extension_count,
            .ppEnabledExtensionNames = pp_enabled_extension_names,
            .pEnabledFeatures = enabled_features
        };
    }
};

struct DeviceDeviceMemoryReportCreateInfoEXT {
    VkDeviceMemoryReportFlagsEXT flags;
    PFN_vkDeviceMemoryReportCallbackEXT pfn_user_callback;
    void* user_data;
    
    VkDeviceDeviceMemoryReportCreateInfoEXT raw() {
        return VkDeviceDeviceMemoryReportCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags,
            .pfnUserCallback = pfn_user_callback,
            .pUserData = user_data
        };
    }
};

struct DeviceDiagnosticsConfigCreateInfoNV {
    VkDeviceDiagnosticsConfigFlagsNV flags;
    
    VkDeviceDiagnosticsConfigCreateInfoNV raw() {
        return VkDeviceDiagnosticsConfigCreateInfoNV {
            .sType = VK_STRUCT_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct DeviceEventInfoEXT {
    DeviceEventTypeEXT device_event;
    
    VkDeviceEventInfoEXT raw() {
        return VkDeviceEventInfoEXT {
            .sType = VK_STRUCT_TYPE_DEVICE_EVENT_INFO_EXT,
            .pNext = nullptr,
            .deviceEvent = static_cast<VkDeviceEventTypeEXT>(device_event)
        };
    }
};

struct DeviceFaultAddressInfoEXT {
    DeviceFaultAddressTypeEXT address_type;
    VkDeviceAddress reported_address;
    VkDeviceSize address_precision;
    
    VkDeviceFaultAddressInfoEXT raw() {
        return VkDeviceFaultAddressInfoEXT {
            .addressType = static_cast<VkDeviceFaultAddressTypeEXT>(address_type),
            .reportedAddress = reported_address,
            .addressPrecision = address_precision
        };
    }
};

struct DeviceFaultCountsEXT {
    u32 address_info_count;
    u32 vendor_info_count;
    VkDeviceSize vendor_binary_size;
    
    VkDeviceFaultCountsEXT raw() {
        return VkDeviceFaultCountsEXT {
            .sType = VK_STRUCT_TYPE_DEVICE_FAULT_COUNTS_EXT,
            .pNext = nullptr,
            .addressInfoCount = address_info_count,
            .vendorInfoCount = vendor_info_count,
            .vendorBinarySize = vendor_binary_size
        };
    }
};

struct DeviceFaultInfoEXT {
    char[] vk_max_description_size;
    VkDeviceFaultAddressInfoEXT* address_infos;
    VkDeviceFaultVendorInfoEXT* vendor_infos;
    void* vendor_binary_data;
    
    VkDeviceFaultInfoEXT raw() {
        return VkDeviceFaultInfoEXT {
            .sType = VK_STRUCT_TYPE_DEVICE_FAULT_INFO_EXT,
            .pNext = nullptr,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .pAddressInfos = address_infos,
            .pVendorInfos = vendor_infos,
            .pVendorBinaryData = vendor_binary_data
        };
    }
};

struct DeviceFaultVendorBinaryHeaderVersionOneEXT {
    u32 header_size;
    DeviceFaultVendorBinaryHeaderVersionEXT header_version;
    u32 vendor_id;
    u32 device_id;
    u32 driver_version;
    uint8_t[] vk_uuid_size;
    u32 application_name_offset;
    u32 application_version;
    u32 engine_name_offset;
    u32 engine_version;
    u32 api_version;
    
    VkDeviceFaultVendorBinaryHeaderVersionOneEXT raw() {
        return VkDeviceFaultVendorBinaryHeaderVersionOneEXT {
            .headerSize = header_size,
            .headerVersion = static_cast<VkDeviceFaultVendorBinaryHeaderVersionEXT>(header_version),
            .vendorID = vendor_id,
            .deviceID = device_id,
            .driverVersion = driver_version,
            .VK_UUID_SIZE = vk_uuid_size,
            .applicationNameOffset = application_name_offset,
            .applicationVersion = application_version,
            .engineNameOffset = engine_name_offset,
            .engineVersion = engine_version,
            .apiVersion = api_version
        };
    }
};

struct DeviceFaultVendorInfoEXT {
    char[] vk_max_description_size;
    uint64_t vendor_fault_code;
    uint64_t vendor_fault_data;
    
    VkDeviceFaultVendorInfoEXT raw() {
        return VkDeviceFaultVendorInfoEXT {
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .vendorFaultCode = vendor_fault_code,
            .vendorFaultData = vendor_fault_data
        };
    }
};

struct DeviceGroupBindSparseInfo {
    u32 resource_device_index;
    u32 memory_device_index;
    
    VkDeviceGroupBindSparseInfo raw() {
        return VkDeviceGroupBindSparseInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
            .pNext = nullptr,
            .resourceDeviceIndex = resource_device_index,
            .memoryDeviceIndex = memory_device_index
        };
    }
};

struct DeviceGroupCommandBufferBeginInfo {
    u32 device_mask;
    
    VkDeviceGroupCommandBufferBeginInfo raw() {
        return VkDeviceGroupCommandBufferBeginInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
            .pNext = nullptr,
            .deviceMask = device_mask
        };
    }
};

struct DeviceGroupDeviceCreateInfo {
    u32 physical_device_count;
    VkPhysicalDevice* physical_devices;
    
    VkDeviceGroupDeviceCreateInfo raw() {
        return VkDeviceGroupDeviceCreateInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
            .pNext = nullptr,
            .physicalDeviceCount = physical_device_count,
            .pPhysicalDevices = physical_devices
        };
    }
};

struct DeviceGroupPresentCapabilitiesKHR {
    uint32_t[] vk_max_device_group_size;
    VkDeviceGroupPresentModeFlagsKHR modes;
    
    VkDeviceGroupPresentCapabilitiesKHR raw() {
        return VkDeviceGroupPresentCapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR,
            .pNext = nullptr,
            .VK_MAX_DEVICE_GROUP_SIZE = vk_max_device_group_size,
            .modes = modes
        };
    }
};

struct DeviceGroupPresentInfoKHR {
    u32 swapchain_count;
    uint32_t* device_masks;
    DeviceGroupPresentModeFlagsKHR mode;
    
    VkDeviceGroupPresentInfoKHR raw() {
        return VkDeviceGroupPresentInfoKHR {
            .sType = VK_STRUCT_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR,
            .pNext = nullptr,
            .swapchainCount = swapchain_count,
            .pDeviceMasks = device_masks,
            .mode = static_cast<VkDeviceGroupPresentModeFlagBitsKHR>(mode)
        };
    }
};

struct DeviceGroupRenderPassBeginInfo {
    u32 device_mask;
    u32 device_render_area_count;
    VkRect2D* device_render_areas;
    
    VkDeviceGroupRenderPassBeginInfo raw() {
        return VkDeviceGroupRenderPassBeginInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
            .pNext = nullptr,
            .deviceMask = device_mask,
            .deviceRenderAreaCount = device_render_area_count,
            .pDeviceRenderAreas = device_render_areas
        };
    }
};

struct DeviceGroupSubmitInfo {
    u32 wait_semaphore_count;
    uint32_t* wait_semaphore_device_indices;
    u32 command_buffer_count;
    uint32_t* command_buffer_device_masks;
    u32 signal_semaphore_count;
    uint32_t* signal_semaphore_device_indices;
    
    VkDeviceGroupSubmitInfo raw() {
        return VkDeviceGroupSubmitInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_GROUP_SUBMIT_INFO,
            .pNext = nullptr,
            .waitSemaphoreCount = wait_semaphore_count,
            .pWaitSemaphoreDeviceIndices = wait_semaphore_device_indices,
            .commandBufferCount = command_buffer_count,
            .pCommandBufferDeviceMasks = command_buffer_device_masks,
            .signalSemaphoreCount = signal_semaphore_count,
            .pSignalSemaphoreDeviceIndices = signal_semaphore_device_indices
        };
    }
};

struct DeviceGroupSwapchainCreateInfoKHR {
    VkDeviceGroupPresentModeFlagsKHR modes;
    
    VkDeviceGroupSwapchainCreateInfoKHR raw() {
        return VkDeviceGroupSwapchainCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR,
            .pNext = nullptr,
            .modes = modes
        };
    }
};

struct DeviceImageMemoryRequirements {
    VkImageCreateInfo* create_info;
    ImageAspectFlags plane_aspect;
    
    VkDeviceImageMemoryRequirements raw() {
        return VkDeviceImageMemoryRequirements {
            .sType = VK_STRUCT_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS,
            .pNext = nullptr,
            .pCreateInfo = create_info,
            .planeAspect = static_cast<VkImageAspectFlagBits>(plane_aspect)
        };
    }
};

struct DeviceImageSubresourceInfo {
    VkImageCreateInfo* create_info;
    VkImageSubresource2* subresource;
    
    VkDeviceImageSubresourceInfo raw() {
        return VkDeviceImageSubresourceInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO,
            .pNext = nullptr,
            .pCreateInfo = create_info,
            .pSubresource = subresource
        };
    }
};

struct DeviceMemoryOpaqueCaptureAddressInfo {
    VkDeviceMemory memory;
    
    VkDeviceMemoryOpaqueCaptureAddressInfo raw() {
        return VkDeviceMemoryOpaqueCaptureAddressInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO,
            .pNext = nullptr,
            .memory = memory
        };
    }
};

struct DeviceMemoryOverallocationCreateInfoAMD {
    MemoryOverallocationBehaviorAMD overallocation_behavior;
    
    VkDeviceMemoryOverallocationCreateInfoAMD raw() {
        return VkDeviceMemoryOverallocationCreateInfoAMD {
            .sType = VK_STRUCT_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD,
            .pNext = nullptr,
            .overallocationBehavior = static_cast<VkMemoryOverallocationBehaviorAMD>(overallocation_behavior)
        };
    }
};

struct DeviceMemoryReportCallbackDataEXT {
    VkDeviceMemoryReportFlagsEXT flags;
    DeviceMemoryReportEventTypeEXT type;
    uint64_t memory_object_id;
    VkDeviceSize size;
    ObjectType object_type;
    uint64_t object_handle;
    u32 heap_index;
    
    VkDeviceMemoryReportCallbackDataEXT raw() {
        return VkDeviceMemoryReportCallbackDataEXT {
            .sType = VK_STRUCT_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT,
            .pNext = nullptr,
            .flags = flags,
            .type = static_cast<VkDeviceMemoryReportEventTypeEXT>(type),
            .memoryObjectId = memory_object_id,
            .size = size,
            .objectType = static_cast<VkObjectType>(object_type),
            .objectHandle = object_handle,
            .heapIndex = heap_index
        };
    }
};

struct DevicePipelineBinaryInternalCacheControlKHR {
    bool disable_internal_cache;
    
    VkDevicePipelineBinaryInternalCacheControlKHR raw() {
        return VkDevicePipelineBinaryInternalCacheControlKHR {
            .sType = VK_STRUCT_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR,
            .pNext = nullptr,
            .disableInternalCache = static_cast<VkBool32>(disable_internal_cache)
        };
    }
};

struct DevicePrivateDataCreateInfo {
    u32 private_data_slot_request_count;
    
    VkDevicePrivateDataCreateInfo raw() {
        return VkDevicePrivateDataCreateInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO,
            .pNext = nullptr,
            .privateDataSlotRequestCount = private_data_slot_request_count
        };
    }
};

struct DeviceQueueCreateInfo {
    VkDeviceQueueCreateFlags flags;
    u32 queue_family_index;
    u32 queue_count;
    float* queue_priorities;
    
    VkDeviceQueueCreateInfo raw() {
        return VkDeviceQueueCreateInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_QUEUE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .queueFamilyIndex = queue_family_index,
            .queueCount = queue_count,
            .pQueuePriorities = queue_priorities
        };
    }
};

struct DeviceQueueGlobalPriorityCreateInfo {
    QueueGlobalPriority global_priority;
    
    VkDeviceQueueGlobalPriorityCreateInfo raw() {
        return VkDeviceQueueGlobalPriorityCreateInfo {
            .sType = VK_STRUCT_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO,
            .pNext = nullptr,
            .globalPriority = static_cast<VkQueueGlobalPriority>(global_priority)
        };
    }
};

struct DeviceQueueInfo2 {
    VkDeviceQueueCreateFlags flags;
    u32 queue_family_index;
    u32 queue_index;
    
    VkDeviceQueueInfo2 raw() {
        return VkDeviceQueueInfo2 {
            .sType = VK_STRUCT_TYPE_DEVICE_QUEUE_INFO2,
            .pNext = nullptr,
            .flags = flags,
            .queueFamilyIndex = queue_family_index,
            .queueIndex = queue_index
        };
    }
};

struct DeviceQueueShaderCoreControlCreateInfoARM {
    u32 shader_core_count;
    
    VkDeviceQueueShaderCoreControlCreateInfoARM raw() {
        return VkDeviceQueueShaderCoreControlCreateInfoARM {
            .sType = VK_STRUCT_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM,
            .pNext = nullptr,
            .shaderCoreCount = shader_core_count
        };
    }
};

struct DirectDriverLoadingInfoLUNARG {
    VkDirectDriverLoadingFlagsLUNARG flags;
    PFN_vkGetInstanceProcAddrLUNARG pfn_get_instance_proc_addr;
    
    VkDirectDriverLoadingInfoLUNARG raw() {
        return VkDirectDriverLoadingInfoLUNARG {
            .sType = VK_STRUCT_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG,
            .pNext = nullptr,
            .flags = flags,
            .pfnGetInstanceProcAddr = pfn_get_instance_proc_addr
        };
    }
};

struct DirectDriverLoadingListLUNARG {
    DirectDriverLoadingModeLUNARG mode;
    u32 driver_count;
    VkDirectDriverLoadingInfoLUNARG* drivers;
    
    VkDirectDriverLoadingListLUNARG raw() {
        return VkDirectDriverLoadingListLUNARG {
            .sType = VK_STRUCT_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG,
            .pNext = nullptr,
            .mode = static_cast<VkDirectDriverLoadingModeLUNARG>(mode),
            .driverCount = driver_count,
            .pDrivers = drivers
        };
    }
};

struct DispatchIndirectCommand {
    u32 x;
    u32 y;
    u32 z;
    
    VkDispatchIndirectCommand raw() {
        return VkDispatchIndirectCommand {
            .x = x,
            .y = y,
            .z = z
        };
    }
};

struct DispatchTileInfoQCOM {
    
    VkDispatchTileInfoQCOM raw() {
        return VkDispatchTileInfoQCOM {
            .sType = VK_STRUCT_TYPE_DISPATCH_TILE_INFO_QCOM,
            .pNext = nullptr,
        };
    }
};

struct DisplayEventInfoEXT {
    DisplayEventTypeEXT display_event;
    
    VkDisplayEventInfoEXT raw() {
        return VkDisplayEventInfoEXT {
            .sType = VK_STRUCT_TYPE_DISPLAY_EVENT_INFO_EXT,
            .pNext = nullptr,
            .displayEvent = static_cast<VkDisplayEventTypeEXT>(display_event)
        };
    }
};

struct DisplayModeCreateInfoKHR {
    VkDisplayModeCreateFlagsKHR flags;
    DisplayModeParametersKHR parameters;
    
    VkDisplayModeCreateInfoKHR raw() {
        return VkDisplayModeCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_DISPLAY_MODE_CREATE_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .parameters = parameters.raw()
        };
    }
};

struct DisplayModeParametersKHR {
    Extent2D visible_region;
    u32 refresh_rate;
    
    VkDisplayModeParametersKHR raw() {
        return VkDisplayModeParametersKHR {
            .visibleRegion = visible_region.raw(),
            .refreshRate = refresh_rate
        };
    }
};

struct DisplayModeProperties2KHR {
    DisplayModePropertiesKHR display_mode_properties;
    
    VkDisplayModeProperties2KHR raw() {
        return VkDisplayModeProperties2KHR {
            .sType = VK_STRUCT_TYPE_DISPLAY_MODE_PROPERTIES2KHR,
            .pNext = nullptr,
            .displayModeProperties = display_mode_properties.raw()
        };
    }
};

struct DisplayModePropertiesKHR {
    VkDisplayModeKHR display_mode;
    DisplayModeParametersKHR parameters;
    
    VkDisplayModePropertiesKHR raw() {
        return VkDisplayModePropertiesKHR {
            .displayMode = display_mode,
            .parameters = parameters.raw()
        };
    }
};

struct DisplayModeStereoPropertiesNV {
    bool hdmi3dsupported;
    
    VkDisplayModeStereoPropertiesNV raw() {
        return VkDisplayModeStereoPropertiesNV {
            .sType = VK_STRUCT_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV,
            .pNext = nullptr,
            .hdmi3DSupported = static_cast<VkBool32>(hdmi3dsupported)
        };
    }
};

struct DisplayNativeHdrSurfaceCapabilitiesAMD {
    bool local_dimming_support;
    
    VkDisplayNativeHdrSurfaceCapabilitiesAMD raw() {
        return VkDisplayNativeHdrSurfaceCapabilitiesAMD {
            .sType = VK_STRUCT_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD,
            .pNext = nullptr,
            .localDimmingSupport = static_cast<VkBool32>(local_dimming_support)
        };
    }
};

struct DisplayPlaneCapabilities2KHR {
    DisplayPlaneCapabilitiesKHR capabilities;
    
    VkDisplayPlaneCapabilities2KHR raw() {
        return VkDisplayPlaneCapabilities2KHR {
            .sType = VK_STRUCT_TYPE_DISPLAY_PLANE_CAPABILITIES2KHR,
            .pNext = nullptr,
            .capabilities = capabilities.raw()
        };
    }
};

struct DisplayPlaneCapabilitiesKHR {
    VkDisplayPlaneAlphaFlagsKHR supported_alpha;
    Offset2D min_src_position;
    Offset2D max_src_position;
    Extent2D min_src_extent;
    Extent2D max_src_extent;
    Offset2D min_dst_position;
    Offset2D max_dst_position;
    Extent2D min_dst_extent;
    Extent2D max_dst_extent;
    
    VkDisplayPlaneCapabilitiesKHR raw() {
        return VkDisplayPlaneCapabilitiesKHR {
            .supportedAlpha = supported_alpha,
            .minSrcPosition = min_src_position.raw(),
            .maxSrcPosition = max_src_position.raw(),
            .minSrcExtent = min_src_extent.raw(),
            .maxSrcExtent = max_src_extent.raw(),
            .minDstPosition = min_dst_position.raw(),
            .maxDstPosition = max_dst_position.raw(),
            .minDstExtent = min_dst_extent.raw(),
            .maxDstExtent = max_dst_extent.raw()
        };
    }
};

struct DisplayPlaneInfo2KHR {
    VkDisplayModeKHR mode;
    u32 plane_index;
    
    VkDisplayPlaneInfo2KHR raw() {
        return VkDisplayPlaneInfo2KHR {
            .sType = VK_STRUCT_TYPE_DISPLAY_PLANE_INFO2KHR,
            .pNext = nullptr,
            .mode = mode,
            .planeIndex = plane_index
        };
    }
};

struct DisplayPlaneProperties2KHR {
    DisplayPlanePropertiesKHR display_plane_properties;
    
    VkDisplayPlaneProperties2KHR raw() {
        return VkDisplayPlaneProperties2KHR {
            .sType = VK_STRUCT_TYPE_DISPLAY_PLANE_PROPERTIES2KHR,
            .pNext = nullptr,
            .displayPlaneProperties = display_plane_properties.raw()
        };
    }
};

struct DisplayPlanePropertiesKHR {
    VkDisplayKHR current_display;
    u32 current_stack_index;
    
    VkDisplayPlanePropertiesKHR raw() {
        return VkDisplayPlanePropertiesKHR {
            .currentDisplay = current_display,
            .currentStackIndex = current_stack_index
        };
    }
};

struct DisplayPowerInfoEXT {
    DisplayPowerStateEXT power_state;
    
    VkDisplayPowerInfoEXT raw() {
        return VkDisplayPowerInfoEXT {
            .sType = VK_STRUCT_TYPE_DISPLAY_POWER_INFO_EXT,
            .pNext = nullptr,
            .powerState = static_cast<VkDisplayPowerStateEXT>(power_state)
        };
    }
};

struct DisplayPresentInfoKHR {
    Rect2D src_rect;
    Rect2D dst_rect;
    bool persistent;
    
    VkDisplayPresentInfoKHR raw() {
        return VkDisplayPresentInfoKHR {
            .sType = VK_STRUCT_TYPE_DISPLAY_PRESENT_INFO_KHR,
            .pNext = nullptr,
            .srcRect = src_rect.raw(),
            .dstRect = dst_rect.raw(),
            .persistent = static_cast<VkBool32>(persistent)
        };
    }
};

struct DisplayProperties2KHR {
    DisplayPropertiesKHR display_properties;
    
    VkDisplayProperties2KHR raw() {
        return VkDisplayProperties2KHR {
            .sType = VK_STRUCT_TYPE_DISPLAY_PROPERTIES2KHR,
            .pNext = nullptr,
            .displayProperties = display_properties.raw()
        };
    }
};

struct DisplayPropertiesKHR {
    VkDisplayKHR display;
    char* display_name;
    Extent2D physical_dimensions;
    Extent2D physical_resolution;
    VkSurfaceTransformFlagsKHR supported_transforms;
    bool plane_reorder_possible;
    bool persistent_content;
    
    VkDisplayPropertiesKHR raw() {
        return VkDisplayPropertiesKHR {
            .display = display,
            .displayName = display_name,
            .physicalDimensions = physical_dimensions.raw(),
            .physicalResolution = physical_resolution.raw(),
            .supportedTransforms = supported_transforms,
            .planeReorderPossible = static_cast<VkBool32>(plane_reorder_possible),
            .persistentContent = static_cast<VkBool32>(persistent_content)
        };
    }
};

struct DisplaySurfaceCreateInfoKHR {
    VkDisplaySurfaceCreateFlagsKHR flags;
    VkDisplayModeKHR display_mode;
    u32 plane_index;
    u32 plane_stack_index;
    SurfaceTransformFlagsKHR transform;
    f32 global_alpha;
    DisplayPlaneAlphaFlagsKHR alpha_mode;
    Extent2D image_extent;
    
    VkDisplaySurfaceCreateInfoKHR raw() {
        return VkDisplaySurfaceCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .displayMode = display_mode,
            .planeIndex = plane_index,
            .planeStackIndex = plane_stack_index,
            .transform = static_cast<VkSurfaceTransformFlagBitsKHR>(transform),
            .globalAlpha = global_alpha,
            .alphaMode = static_cast<VkDisplayPlaneAlphaFlagBitsKHR>(alpha_mode),
            .imageExtent = image_extent.raw()
        };
    }
};

struct DisplaySurfaceStereoCreateInfoNV {
    DisplaySurfaceStereoTypeNV stereo_type;
    
    VkDisplaySurfaceStereoCreateInfoNV raw() {
        return VkDisplaySurfaceStereoCreateInfoNV {
            .sType = VK_STRUCT_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV,
            .pNext = nullptr,
            .stereoType = static_cast<VkDisplaySurfaceStereoTypeNV>(stereo_type)
        };
    }
};

struct DrawIndexedIndirectCommand {
    u32 index_count;
    u32 instance_count;
    u32 first_index;
    i32 vertex_offset;
    u32 first_instance;
    
    VkDrawIndexedIndirectCommand raw() {
        return VkDrawIndexedIndirectCommand {
            .indexCount = index_count,
            .instanceCount = instance_count,
            .firstIndex = first_index,
            .vertexOffset = vertex_offset,
            .firstInstance = first_instance
        };
    }
};

struct DrawIndirectCommand {
    u32 vertex_count;
    u32 instance_count;
    u32 first_vertex;
    u32 first_instance;
    
    VkDrawIndirectCommand raw() {
        return VkDrawIndirectCommand {
            .vertexCount = vertex_count,
            .instanceCount = instance_count,
            .firstVertex = first_vertex,
            .firstInstance = first_instance
        };
    }
};

struct DrawIndirectCountIndirectCommandEXT {
    VkDeviceAddress buffer_address;
    u32 stride;
    u32 command_count;
    
    VkDrawIndirectCountIndirectCommandEXT raw() {
        return VkDrawIndirectCountIndirectCommandEXT {
            .bufferAddress = buffer_address,
            .stride = stride,
            .commandCount = command_count
        };
    }
};

struct DrawMeshTasksIndirectCommandEXT {
    u32 group_count_x;
    u32 group_count_y;
    u32 group_count_z;
    
    VkDrawMeshTasksIndirectCommandEXT raw() {
        return VkDrawMeshTasksIndirectCommandEXT {
            .groupCountX = group_count_x,
            .groupCountY = group_count_y,
            .groupCountZ = group_count_z
        };
    }
};

struct DrawMeshTasksIndirectCommandNV {
    u32 task_count;
    u32 first_task;
    
    VkDrawMeshTasksIndirectCommandNV raw() {
        return VkDrawMeshTasksIndirectCommandNV {
            .taskCount = task_count,
            .firstTask = first_task
        };
    }
};

struct DrmFormatModifierProperties2EXT {
    uint64_t drm_format_modifier;
    u32 drm_format_modifier_plane_count;
    VkFormatFeatureFlags2 drm_format_modifier_tiling_features;
    
    VkDrmFormatModifierProperties2EXT raw() {
        return VkDrmFormatModifierProperties2EXT {
            .drmFormatModifier = drm_format_modifier,
            .drmFormatModifierPlaneCount = drm_format_modifier_plane_count,
            .drmFormatModifierTilingFeatures = drm_format_modifier_tiling_features
        };
    }
};

struct DrmFormatModifierPropertiesEXT {
    uint64_t drm_format_modifier;
    u32 drm_format_modifier_plane_count;
    VkFormatFeatureFlags drm_format_modifier_tiling_features;
    
    VkDrmFormatModifierPropertiesEXT raw() {
        return VkDrmFormatModifierPropertiesEXT {
            .drmFormatModifier = drm_format_modifier,
            .drmFormatModifierPlaneCount = drm_format_modifier_plane_count,
            .drmFormatModifierTilingFeatures = drm_format_modifier_tiling_features
        };
    }
};

struct DrmFormatModifierPropertiesList2EXT {
    u32 drm_format_modifier_count;
    VkDrmFormatModifierProperties2EXT* drm_format_modifier_properties;
    
    VkDrmFormatModifierPropertiesList2EXT raw() {
        return VkDrmFormatModifierPropertiesList2EXT {
            .sType = VK_STRUCT_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST2EXT,
            .pNext = nullptr,
            .drmFormatModifierCount = drm_format_modifier_count,
            .pDrmFormatModifierProperties = drm_format_modifier_properties
        };
    }
};

struct DrmFormatModifierPropertiesListEXT {
    u32 drm_format_modifier_count;
    VkDrmFormatModifierPropertiesEXT* drm_format_modifier_properties;
    
    VkDrmFormatModifierPropertiesListEXT raw() {
        return VkDrmFormatModifierPropertiesListEXT {
            .sType = VK_STRUCT_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT,
            .pNext = nullptr,
            .drmFormatModifierCount = drm_format_modifier_count,
            .pDrmFormatModifierProperties = drm_format_modifier_properties
        };
    }
};

struct EventCreateInfo {
    VkEventCreateFlags flags;
    
    VkEventCreateInfo raw() {
        return VkEventCreateInfo {
            .sType = VK_STRUCT_TYPE_EVENT_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct ExportFenceCreateInfo {
    VkExternalFenceHandleTypeFlags handle_types;
    
    VkExportFenceCreateInfo raw() {
        return VkExportFenceCreateInfo {
            .sType = VK_STRUCT_TYPE_EXPORT_FENCE_CREATE_INFO,
            .pNext = nullptr,
            .handleTypes = handle_types
        };
    }
};

struct ExportMemoryAllocateInfo {
    VkExternalMemoryHandleTypeFlags handle_types;
    
    VkExportMemoryAllocateInfo raw() {
        return VkExportMemoryAllocateInfo {
            .sType = VK_STRUCT_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
            .pNext = nullptr,
            .handleTypes = handle_types
        };
    }
};

struct ExportMemoryAllocateInfoNV {
    VkExternalMemoryHandleTypeFlagsNV handle_types;
    
    VkExportMemoryAllocateInfoNV raw() {
        return VkExportMemoryAllocateInfoNV {
            .sType = VK_STRUCT_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV,
            .pNext = nullptr,
            .handleTypes = handle_types
        };
    }
};

struct ExportSemaphoreCreateInfo {
    VkExternalSemaphoreHandleTypeFlags handle_types;
    
    VkExportSemaphoreCreateInfo raw() {
        return VkExportSemaphoreCreateInfo {
            .sType = VK_STRUCT_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
            .pNext = nullptr,
            .handleTypes = handle_types
        };
    }
};

struct ExtensionProperties {
    char[] vk_max_extension_name_size;
    u32 spec_version;
    
    VkExtensionProperties raw() {
        return VkExtensionProperties {
            .VK_MAX_EXTENSION_NAME_SIZE = vk_max_extension_name_size,
            .specVersion = spec_version
        };
    }
};

struct Extent2D {
    u32 width;
    u32 height;
    
    VkExtent2D raw() {
        return VkExtent2D {
            .width = width,
            .height = height
        };
    }
};

struct Extent3D {
    u32 width;
    u32 height;
    u32 depth;
    
    VkExtent3D raw() {
        return VkExtent3D {
            .width = width,
            .height = height,
            .depth = depth
        };
    }
};

struct ExternalBufferProperties {
    ExternalMemoryProperties external_memory_properties;
    
    VkExternalBufferProperties raw() {
        return VkExternalBufferProperties {
            .sType = VK_STRUCT_TYPE_EXTERNAL_BUFFER_PROPERTIES,
            .pNext = nullptr,
            .externalMemoryProperties = external_memory_properties.raw()
        };
    }
};

struct ExternalComputeQueueCreateInfoNV {
    VkQueue preferred_queue;
    
    VkExternalComputeQueueCreateInfoNV raw() {
        return VkExternalComputeQueueCreateInfoNV {
            .sType = VK_STRUCT_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV,
            .pNext = nullptr,
            .preferredQueue = preferred_queue
        };
    }
};

struct ExternalComputeQueueDataParamsNV {
    u32 device_index;
    
    VkExternalComputeQueueDataParamsNV raw() {
        return VkExternalComputeQueueDataParamsNV {
            .sType = VK_STRUCT_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV,
            .pNext = nullptr,
            .deviceIndex = device_index
        };
    }
};

struct ExternalComputeQueueDeviceCreateInfoNV {
    u32 reserved_external_queues;
    
    VkExternalComputeQueueDeviceCreateInfoNV raw() {
        return VkExternalComputeQueueDeviceCreateInfoNV {
            .sType = VK_STRUCT_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV,
            .pNext = nullptr,
            .reservedExternalQueues = reserved_external_queues
        };
    }
};

struct ExternalFenceProperties {
    VkExternalFenceHandleTypeFlags export_from_imported_handle_types;
    VkExternalFenceHandleTypeFlags compatible_handle_types;
    VkExternalFenceFeatureFlags external_fence_features;
    
    VkExternalFenceProperties raw() {
        return VkExternalFenceProperties {
            .sType = VK_STRUCT_TYPE_EXTERNAL_FENCE_PROPERTIES,
            .pNext = nullptr,
            .exportFromImportedHandleTypes = export_from_imported_handle_types,
            .compatibleHandleTypes = compatible_handle_types,
            .externalFenceFeatures = external_fence_features
        };
    }
};

struct ExternalImageFormatProperties {
    ExternalMemoryProperties external_memory_properties;
    
    VkExternalImageFormatProperties raw() {
        return VkExternalImageFormatProperties {
            .sType = VK_STRUCT_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
            .pNext = nullptr,
            .externalMemoryProperties = external_memory_properties.raw()
        };
    }
};

struct ExternalImageFormatPropertiesNV {
    ImageFormatProperties image_format_properties;
    VkExternalMemoryFeatureFlagsNV external_memory_features;
    VkExternalMemoryHandleTypeFlagsNV export_from_imported_handle_types;
    VkExternalMemoryHandleTypeFlagsNV compatible_handle_types;
    
    VkExternalImageFormatPropertiesNV raw() {
        return VkExternalImageFormatPropertiesNV {
            .imageFormatProperties = image_format_properties.raw(),
            .externalMemoryFeatures = external_memory_features,
            .exportFromImportedHandleTypes = export_from_imported_handle_types,
            .compatibleHandleTypes = compatible_handle_types
        };
    }
};

struct ExternalMemoryAcquireUnmodifiedEXT {
    bool acquire_unmodified_memory;
    
    VkExternalMemoryAcquireUnmodifiedEXT raw() {
        return VkExternalMemoryAcquireUnmodifiedEXT {
            .sType = VK_STRUCT_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT,
            .pNext = nullptr,
            .acquireUnmodifiedMemory = static_cast<VkBool32>(acquire_unmodified_memory)
        };
    }
};

struct ExternalMemoryBufferCreateInfo {
    VkExternalMemoryHandleTypeFlags handle_types;
    
    VkExternalMemoryBufferCreateInfo raw() {
        return VkExternalMemoryBufferCreateInfo {
            .sType = VK_STRUCT_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
            .pNext = nullptr,
            .handleTypes = handle_types
        };
    }
};

struct ExternalMemoryImageCreateInfo {
    VkExternalMemoryHandleTypeFlags handle_types;
    
    VkExternalMemoryImageCreateInfo raw() {
        return VkExternalMemoryImageCreateInfo {
            .sType = VK_STRUCT_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
            .pNext = nullptr,
            .handleTypes = handle_types
        };
    }
};

struct ExternalMemoryImageCreateInfoNV {
    VkExternalMemoryHandleTypeFlagsNV handle_types;
    
    VkExternalMemoryImageCreateInfoNV raw() {
        return VkExternalMemoryImageCreateInfoNV {
            .sType = VK_STRUCT_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV,
            .pNext = nullptr,
            .handleTypes = handle_types
        };
    }
};

struct ExternalMemoryProperties {
    VkExternalMemoryFeatureFlags external_memory_features;
    VkExternalMemoryHandleTypeFlags export_from_imported_handle_types;
    VkExternalMemoryHandleTypeFlags compatible_handle_types;
    
    VkExternalMemoryProperties raw() {
        return VkExternalMemoryProperties {
            .externalMemoryFeatures = external_memory_features,
            .exportFromImportedHandleTypes = export_from_imported_handle_types,
            .compatibleHandleTypes = compatible_handle_types
        };
    }
};

struct ExternalSemaphoreProperties {
    VkExternalSemaphoreHandleTypeFlags export_from_imported_handle_types;
    VkExternalSemaphoreHandleTypeFlags compatible_handle_types;
    VkExternalSemaphoreFeatureFlags external_semaphore_features;
    
    VkExternalSemaphoreProperties raw() {
        return VkExternalSemaphoreProperties {
            .sType = VK_STRUCT_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
            .pNext = nullptr,
            .exportFromImportedHandleTypes = export_from_imported_handle_types,
            .compatibleHandleTypes = compatible_handle_types,
            .externalSemaphoreFeatures = external_semaphore_features
        };
    }
};

struct FenceCreateInfo {
    VkFenceCreateFlags flags;
    
    VkFenceCreateInfo raw() {
        return VkFenceCreateInfo {
            .sType = VK_STRUCT_TYPE_FENCE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct FenceGetFdInfoKHR {
    VkFence fence;
    ExternalFenceHandleTypeFlags handle_type;
    
    VkFenceGetFdInfoKHR raw() {
        return VkFenceGetFdInfoKHR {
            .sType = VK_STRUCT_TYPE_FENCE_GET_FD_INFO_KHR,
            .pNext = nullptr,
            .fence = fence,
            .handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(handle_type)
        };
    }
};

struct FilterCubicImageViewImageFormatPropertiesEXT {
    bool filter_cubic;
    bool filter_cubic_minmax;
    
    VkFilterCubicImageViewImageFormatPropertiesEXT raw() {
        return VkFilterCubicImageViewImageFormatPropertiesEXT {
            .sType = VK_STRUCT_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT,
            .pNext = nullptr,
            .filterCubic = static_cast<VkBool32>(filter_cubic),
            .filterCubicMinmax = static_cast<VkBool32>(filter_cubic_minmax)
        };
    }
};

struct FormatProperties {
    VkFormatFeatureFlags linear_tiling_features;
    VkFormatFeatureFlags optimal_tiling_features;
    VkFormatFeatureFlags buffer_features;
    
    VkFormatProperties raw() {
        return VkFormatProperties {
            .linearTilingFeatures = linear_tiling_features,
            .optimalTilingFeatures = optimal_tiling_features,
            .bufferFeatures = buffer_features
        };
    }
};

struct FormatProperties2 {
    FormatProperties format_properties;
    
    VkFormatProperties2 raw() {
        return VkFormatProperties2 {
            .sType = VK_STRUCT_TYPE_FORMAT_PROPERTIES2,
            .pNext = nullptr,
            .formatProperties = format_properties.raw()
        };
    }
};

struct FormatProperties3 {
    VkFormatFeatureFlags2 linear_tiling_features;
    VkFormatFeatureFlags2 optimal_tiling_features;
    VkFormatFeatureFlags2 buffer_features;
    
    VkFormatProperties3 raw() {
        return VkFormatProperties3 {
            .sType = VK_STRUCT_TYPE_FORMAT_PROPERTIES3,
            .pNext = nullptr,
            .linearTilingFeatures = linear_tiling_features,
            .optimalTilingFeatures = optimal_tiling_features,
            .bufferFeatures = buffer_features
        };
    }
};

struct FragmentShadingRateAttachmentInfoKHR {
    VkAttachmentReference2* fragment_shading_rate_attachment;
    Extent2D shading_rate_attachment_texel_size;
    
    VkFragmentShadingRateAttachmentInfoKHR raw() {
        return VkFragmentShadingRateAttachmentInfoKHR {
            .sType = VK_STRUCT_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            .pNext = nullptr,
            .pFragmentShadingRateAttachment = fragment_shading_rate_attachment,
            .shadingRateAttachmentTexelSize = shading_rate_attachment_texel_size.raw()
        };
    }
};

struct FrameBoundaryEXT {
    VkFrameBoundaryFlagsEXT flags;
    uint64_t frame_id;
    u32 image_count;
    VkImage* images;
    u32 buffer_count;
    VkBuffer* buffers;
    uint64_t tag_name;
    size_t tag_size;
    void* tag;
    
    VkFrameBoundaryEXT raw() {
        return VkFrameBoundaryEXT {
            .sType = VK_STRUCT_TYPE_FRAME_BOUNDARY_EXT,
            .pNext = nullptr,
            .flags = flags,
            .frameID = frame_id,
            .imageCount = image_count,
            .pImages = images,
            .bufferCount = buffer_count,
            .pBuffers = buffers,
            .tagName = tag_name,
            .tagSize = tag_size,
            .pTag = tag
        };
    }
};

struct FramebufferAttachmentImageInfo {
    VkImageCreateFlags flags;
    VkImageUsageFlags usage;
    u32 width;
    u32 height;
    u32 layer_count;
    u32 view_format_count;
    VkFormat* view_formats;
    
    VkFramebufferAttachmentImageInfo raw() {
        return VkFramebufferAttachmentImageInfo {
            .sType = VK_STRUCT_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .usage = usage,
            .width = width,
            .height = height,
            .layerCount = layer_count,
            .viewFormatCount = view_format_count,
            .pViewFormats = view_formats
        };
    }
};

struct FramebufferAttachmentsCreateInfo {
    u32 attachment_image_info_count;
    VkFramebufferAttachmentImageInfo* attachment_image_infos;
    
    VkFramebufferAttachmentsCreateInfo raw() {
        return VkFramebufferAttachmentsCreateInfo {
            .sType = VK_STRUCT_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO,
            .pNext = nullptr,
            .attachmentImageInfoCount = attachment_image_info_count,
            .pAttachmentImageInfos = attachment_image_infos
        };
    }
};

struct FramebufferCreateInfo {
    VkFramebufferCreateFlags flags;
    VkRenderPass render_pass;
    u32 attachment_count;
    VkImageView* attachments;
    u32 width;
    u32 height;
    u32 layers;
    
    VkFramebufferCreateInfo raw() {
        return VkFramebufferCreateInfo {
            .sType = VK_STRUCT_TYPE_FRAMEBUFFER_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .renderPass = render_pass,
            .attachmentCount = attachment_count,
            .pAttachments = attachments,
            .width = width,
            .height = height,
            .layers = layers
        };
    }
};

struct FramebufferMixedSamplesCombinationNV {
    CoverageReductionModeNV coverage_reduction_mode;
    SampleCountFlags rasterization_samples;
    VkSampleCountFlags depth_stencil_samples;
    VkSampleCountFlags color_samples;
    
    VkFramebufferMixedSamplesCombinationNV raw() {
        return VkFramebufferMixedSamplesCombinationNV {
            .sType = VK_STRUCT_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV,
            .pNext = nullptr,
            .coverageReductionMode = static_cast<VkCoverageReductionModeNV>(coverage_reduction_mode),
            .rasterizationSamples = static_cast<VkSampleCountFlagBits>(rasterization_samples),
            .depthStencilSamples = depth_stencil_samples,
            .colorSamples = color_samples
        };
    }
};

struct GeneratedCommandsInfoEXT {
    VkShaderStageFlags shader_stages;
    VkIndirectExecutionSetEXT indirect_execution_set;
    VkIndirectCommandsLayoutEXT indirect_commands_layout;
    VkDeviceAddress indirect_address;
    VkDeviceSize indirect_address_size;
    VkDeviceAddress preprocess_address;
    VkDeviceSize preprocess_size;
    u32 max_sequence_count;
    VkDeviceAddress sequence_count_address;
    u32 max_draw_count;
    
    VkGeneratedCommandsInfoEXT raw() {
        return VkGeneratedCommandsInfoEXT {
            .sType = VK_STRUCT_TYPE_GENERATED_COMMANDS_INFO_EXT,
            .pNext = nullptr,
            .shaderStages = shader_stages,
            .indirectExecutionSet = indirect_execution_set,
            .indirectCommandsLayout = indirect_commands_layout,
            .indirectAddress = indirect_address,
            .indirectAddressSize = indirect_address_size,
            .preprocessAddress = preprocess_address,
            .preprocessSize = preprocess_size,
            .maxSequenceCount = max_sequence_count,
            .sequenceCountAddress = sequence_count_address,
            .maxDrawCount = max_draw_count
        };
    }
};

struct GeneratedCommandsInfoNV {
    PipelineBindPoint pipeline_bind_point;
    VkPipeline pipeline;
    VkIndirectCommandsLayoutNV indirect_commands_layout;
    u32 stream_count;
    VkIndirectCommandsStreamNV* streams;
    u32 sequences_count;
    VkBuffer preprocess_buffer;
    VkDeviceSize preprocess_offset;
    VkDeviceSize preprocess_size;
    VkBuffer sequences_count_buffer;
    VkDeviceSize sequences_count_offset;
    VkBuffer sequences_index_buffer;
    VkDeviceSize sequences_index_offset;
    
    VkGeneratedCommandsInfoNV raw() {
        return VkGeneratedCommandsInfoNV {
            .sType = VK_STRUCT_TYPE_GENERATED_COMMANDS_INFO_NV,
            .pNext = nullptr,
            .pipelineBindPoint = static_cast<VkPipelineBindPoint>(pipeline_bind_point),
            .pipeline = pipeline,
            .indirectCommandsLayout = indirect_commands_layout,
            .streamCount = stream_count,
            .pStreams = streams,
            .sequencesCount = sequences_count,
            .preprocessBuffer = preprocess_buffer,
            .preprocessOffset = preprocess_offset,
            .preprocessSize = preprocess_size,
            .sequencesCountBuffer = sequences_count_buffer,
            .sequencesCountOffset = sequences_count_offset,
            .sequencesIndexBuffer = sequences_index_buffer,
            .sequencesIndexOffset = sequences_index_offset
        };
    }
};

struct GeneratedCommandsMemoryRequirementsInfoEXT {
    VkIndirectExecutionSetEXT indirect_execution_set;
    VkIndirectCommandsLayoutEXT indirect_commands_layout;
    u32 max_sequence_count;
    u32 max_draw_count;
    
    VkGeneratedCommandsMemoryRequirementsInfoEXT raw() {
        return VkGeneratedCommandsMemoryRequirementsInfoEXT {
            .sType = VK_STRUCT_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT,
            .pNext = nullptr,
            .indirectExecutionSet = indirect_execution_set,
            .indirectCommandsLayout = indirect_commands_layout,
            .maxSequenceCount = max_sequence_count,
            .maxDrawCount = max_draw_count
        };
    }
};

struct GeneratedCommandsMemoryRequirementsInfoNV {
    PipelineBindPoint pipeline_bind_point;
    VkPipeline pipeline;
    VkIndirectCommandsLayoutNV indirect_commands_layout;
    u32 max_sequences_count;
    
    VkGeneratedCommandsMemoryRequirementsInfoNV raw() {
        return VkGeneratedCommandsMemoryRequirementsInfoNV {
            .sType = VK_STRUCT_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV,
            .pNext = nullptr,
            .pipelineBindPoint = static_cast<VkPipelineBindPoint>(pipeline_bind_point),
            .pipeline = pipeline,
            .indirectCommandsLayout = indirect_commands_layout,
            .maxSequencesCount = max_sequences_count
        };
    }
};

struct GeneratedCommandsPipelineInfoEXT {
    VkPipeline pipeline;
    
    VkGeneratedCommandsPipelineInfoEXT raw() {
        return VkGeneratedCommandsPipelineInfoEXT {
            .sType = VK_STRUCT_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT,
            .pNext = nullptr,
            .pipeline = pipeline
        };
    }
};

struct GeneratedCommandsShaderInfoEXT {
    u32 shader_count;
    VkShaderEXT* shaders;
    
    VkGeneratedCommandsShaderInfoEXT raw() {
        return VkGeneratedCommandsShaderInfoEXT {
            .sType = VK_STRUCT_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT,
            .pNext = nullptr,
            .shaderCount = shader_count,
            .pShaders = shaders
        };
    }
};

struct GeometryAABBNV {
    VkBuffer aabb_data;
    u32 num_aabbs;
    u32 stride;
    VkDeviceSize offset;
    
    VkGeometryAABBNV raw() {
        return VkGeometryAABBNV {
            .sType = VK_STRUCT_TYPE_GEOMETRY_AABBNV,
            .pNext = nullptr,
            .aabbData = aabb_data,
            .numAABBs = num_aabbs,
            .stride = stride,
            .offset = offset
        };
    }
};

struct GeometryDataNV {
    GeometryTrianglesNV triangles;
    GeometryAABBNV aabbs;
    
    VkGeometryDataNV raw() {
        return VkGeometryDataNV {
            .triangles = triangles.raw(),
            .aabbs = aabbs.raw()
        };
    }
};

struct GeometryNV {
    GeometryTypeKHR geometry_type;
    GeometryDataNV geometry;
    VkGeometryFlagsKHR flags;
    
    VkGeometryNV raw() {
        return VkGeometryNV {
            .sType = VK_STRUCT_TYPE_GEOMETRY_NV,
            .pNext = nullptr,
            .geometryType = static_cast<VkGeometryTypeKHR>(geometry_type),
            .geometry = geometry.raw(),
            .flags = flags
        };
    }
};

struct GeometryTrianglesNV {
    VkBuffer vertex_data;
    VkDeviceSize vertex_offset;
    u32 vertex_count;
    VkDeviceSize vertex_stride;
    Format vertex_format;
    VkBuffer index_data;
    VkDeviceSize index_offset;
    u32 index_count;
    IndexType index_type;
    VkBuffer transform_data;
    VkDeviceSize transform_offset;
    
    VkGeometryTrianglesNV raw() {
        return VkGeometryTrianglesNV {
            .sType = VK_STRUCT_TYPE_GEOMETRY_TRIANGLES_NV,
            .pNext = nullptr,
            .vertexData = vertex_data,
            .vertexOffset = vertex_offset,
            .vertexCount = vertex_count,
            .vertexStride = vertex_stride,
            .vertexFormat = static_cast<VkFormat>(vertex_format),
            .indexData = index_data,
            .indexOffset = index_offset,
            .indexCount = index_count,
            .indexType = static_cast<VkIndexType>(index_type),
            .transformData = transform_data,
            .transformOffset = transform_offset
        };
    }
};

struct GetLatencyMarkerInfoNV {
    u32 timing_count;
    VkLatencyTimingsFrameReportNV* timings;
    
    VkGetLatencyMarkerInfoNV raw() {
        return VkGetLatencyMarkerInfoNV {
            .sType = VK_STRUCT_TYPE_GET_LATENCY_MARKER_INFO_NV,
            .pNext = nullptr,
            .timingCount = timing_count,
            .pTimings = timings
        };
    }
};

struct GraphicsPipelineCreateInfo {
    VkPipelineCreateFlags flags;
    u32 stage_count;
    VkPipelineShaderStageCreateInfo* stages;
    VkPipelineVertexInputStateCreateInfo* vertex_input_state;
    VkPipelineInputAssemblyStateCreateInfo* input_assembly_state;
    VkPipelineTessellationStateCreateInfo* tessellation_state;
    VkPipelineViewportStateCreateInfo* viewport_state;
    VkPipelineRasterizationStateCreateInfo* rasterization_state;
    VkPipelineMultisampleStateCreateInfo* multisample_state;
    VkPipelineDepthStencilStateCreateInfo* depth_stencil_state;
    VkPipelineColorBlendStateCreateInfo* color_blend_state;
    VkPipelineDynamicStateCreateInfo* dynamic_state;
    VkPipelineLayout layout;
    VkRenderPass render_pass;
    u32 subpass;
    VkPipeline base_pipeline_handle;
    i32 base_pipeline_index;
    
    VkGraphicsPipelineCreateInfo raw() {
        return VkGraphicsPipelineCreateInfo {
            .sType = VK_STRUCT_TYPE_GRAPHICS_PIPELINE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .stageCount = stage_count,
            .pStages = stages,
            .pVertexInputState = vertex_input_state,
            .pInputAssemblyState = input_assembly_state,
            .pTessellationState = tessellation_state,
            .pViewportState = viewport_state,
            .pRasterizationState = rasterization_state,
            .pMultisampleState = multisample_state,
            .pDepthStencilState = depth_stencil_state,
            .pColorBlendState = color_blend_state,
            .pDynamicState = dynamic_state,
            .layout = layout,
            .renderPass = render_pass,
            .subpass = subpass,
            .basePipelineHandle = base_pipeline_handle,
            .basePipelineIndex = base_pipeline_index
        };
    }
};

struct GraphicsPipelineLibraryCreateInfoEXT {
    VkGraphicsPipelineLibraryFlagsEXT flags;
    
    VkGraphicsPipelineLibraryCreateInfoEXT raw() {
        return VkGraphicsPipelineLibraryCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct GraphicsPipelineShaderGroupsCreateInfoNV {
    u32 group_count;
    VkGraphicsShaderGroupCreateInfoNV* groups;
    u32 pipeline_count;
    VkPipeline* pipelines;
    
    VkGraphicsPipelineShaderGroupsCreateInfoNV raw() {
        return VkGraphicsPipelineShaderGroupsCreateInfoNV {
            .sType = VK_STRUCT_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV,
            .pNext = nullptr,
            .groupCount = group_count,
            .pGroups = groups,
            .pipelineCount = pipeline_count,
            .pPipelines = pipelines
        };
    }
};

struct GraphicsShaderGroupCreateInfoNV {
    u32 stage_count;
    VkPipelineShaderStageCreateInfo* stages;
    VkPipelineVertexInputStateCreateInfo* vertex_input_state;
    VkPipelineTessellationStateCreateInfo* tessellation_state;
    
    VkGraphicsShaderGroupCreateInfoNV raw() {
        return VkGraphicsShaderGroupCreateInfoNV {
            .sType = VK_STRUCT_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV,
            .pNext = nullptr,
            .stageCount = stage_count,
            .pStages = stages,
            .pVertexInputState = vertex_input_state,
            .pTessellationState = tessellation_state
        };
    }
};

struct HdrMetadataEXT {
    XYColorEXT display_primary_red;
    XYColorEXT display_primary_green;
    XYColorEXT display_primary_blue;
    XYColorEXT white_point;
    f32 max_luminance;
    f32 min_luminance;
    f32 max_content_light_level;
    f32 max_frame_average_light_level;
    
    VkHdrMetadataEXT raw() {
        return VkHdrMetadataEXT {
            .sType = VK_STRUCT_TYPE_HDR_METADATA_EXT,
            .pNext = nullptr,
            .displayPrimaryRed = display_primary_red.raw(),
            .displayPrimaryGreen = display_primary_green.raw(),
            .displayPrimaryBlue = display_primary_blue.raw(),
            .whitePoint = white_point.raw(),
            .maxLuminance = max_luminance,
            .minLuminance = min_luminance,
            .maxContentLightLevel = max_content_light_level,
            .maxFrameAverageLightLevel = max_frame_average_light_level
        };
    }
};

struct HdrVividDynamicMetadataHUAWEI {
    size_t dynamic_metadata_size;
    void* dynamic_metadata;
    
    VkHdrVividDynamicMetadataHUAWEI raw() {
        return VkHdrVividDynamicMetadataHUAWEI {
            .sType = VK_STRUCT_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI,
            .pNext = nullptr,
            .dynamicMetadataSize = dynamic_metadata_size,
            .pDynamicMetadata = dynamic_metadata
        };
    }
};

struct HeadlessSurfaceCreateInfoEXT {
    VkHeadlessSurfaceCreateFlagsEXT flags;
    
    VkHeadlessSurfaceCreateInfoEXT raw() {
        return VkHeadlessSurfaceCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct HostImageCopyDevicePerformanceQuery {
    bool optimal_device_access;
    bool identical_memory_layout;
    
    VkHostImageCopyDevicePerformanceQuery raw() {
        return VkHostImageCopyDevicePerformanceQuery {
            .sType = VK_STRUCT_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY,
            .pNext = nullptr,
            .optimalDeviceAccess = static_cast<VkBool32>(optimal_device_access),
            .identicalMemoryLayout = static_cast<VkBool32>(identical_memory_layout)
        };
    }
};

struct HostImageLayoutTransitionInfo {
    VkImage image;
    ImageLayout old_layout;
    ImageLayout new_layout;
    ImageSubresourceRange subresource_range;
    
    VkHostImageLayoutTransitionInfo raw() {
        return VkHostImageLayoutTransitionInfo {
            .sType = VK_STRUCT_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO,
            .pNext = nullptr,
            .image = image,
            .oldLayout = static_cast<VkImageLayout>(old_layout),
            .newLayout = static_cast<VkImageLayout>(new_layout),
            .subresourceRange = subresource_range.raw()
        };
    }
};

struct ImageAlignmentControlCreateInfoMESA {
    u32 maximum_requested_alignment;
    
    VkImageAlignmentControlCreateInfoMESA raw() {
        return VkImageAlignmentControlCreateInfoMESA {
            .sType = VK_STRUCT_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA,
            .pNext = nullptr,
            .maximumRequestedAlignment = maximum_requested_alignment
        };
    }
};

struct ImageBlit {
    ImageSubresourceLayers src_subresource;
    VkOffset3D[2] src_offsets;
    ImageSubresourceLayers dst_subresource;
    VkOffset3D[2] dst_offsets;
    
    VkImageBlit raw() {
        return VkImageBlit {
            .srcSubresource = src_subresource.raw(),
            .srcOffsets = src_offsets,
            .dstSubresource = dst_subresource.raw(),
            .dstOffsets = dst_offsets
        };
    }
};

struct ImageBlit2 {
    ImageSubresourceLayers src_subresource;
    VkOffset3D[2] src_offsets;
    ImageSubresourceLayers dst_subresource;
    VkOffset3D[2] dst_offsets;
    
    VkImageBlit2 raw() {
        return VkImageBlit2 {
            .sType = VK_STRUCT_TYPE_IMAGE_BLIT2,
            .pNext = nullptr,
            .srcSubresource = src_subresource.raw(),
            .srcOffsets = src_offsets,
            .dstSubresource = dst_subresource.raw(),
            .dstOffsets = dst_offsets
        };
    }
};

struct ImageCaptureDescriptorDataInfoEXT {
    VkImage image;
    
    VkImageCaptureDescriptorDataInfoEXT raw() {
        return VkImageCaptureDescriptorDataInfoEXT {
            .sType = VK_STRUCT_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
            .pNext = nullptr,
            .image = image
        };
    }
};

struct ImageCompressionControlEXT {
    VkImageCompressionFlagsEXT flags;
    u32 compression_control_plane_count;
    VkImageCompressionFixedRateFlagsEXT* fixed_rate_flags;
    
    VkImageCompressionControlEXT raw() {
        return VkImageCompressionControlEXT {
            .sType = VK_STRUCT_TYPE_IMAGE_COMPRESSION_CONTROL_EXT,
            .pNext = nullptr,
            .flags = flags,
            .compressionControlPlaneCount = compression_control_plane_count,
            .pFixedRateFlags = fixed_rate_flags
        };
    }
};

struct ImageCompressionPropertiesEXT {
    VkImageCompressionFlagsEXT image_compression_flags;
    VkImageCompressionFixedRateFlagsEXT image_compression_fixed_rate_flags;
    
    VkImageCompressionPropertiesEXT raw() {
        return VkImageCompressionPropertiesEXT {
            .sType = VK_STRUCT_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT,
            .pNext = nullptr,
            .imageCompressionFlags = image_compression_flags,
            .imageCompressionFixedRateFlags = image_compression_fixed_rate_flags
        };
    }
};

struct ImageCopy {
    ImageSubresourceLayers src_subresource;
    Offset3D src_offset;
    ImageSubresourceLayers dst_subresource;
    Offset3D dst_offset;
    Extent3D extent;
    
    VkImageCopy raw() {
        return VkImageCopy {
            .srcSubresource = src_subresource.raw(),
            .srcOffset = src_offset.raw(),
            .dstSubresource = dst_subresource.raw(),
            .dstOffset = dst_offset.raw(),
            .extent = extent.raw()
        };
    }
};

struct ImageCopy2 {
    ImageSubresourceLayers src_subresource;
    Offset3D src_offset;
    ImageSubresourceLayers dst_subresource;
    Offset3D dst_offset;
    Extent3D extent;
    
    VkImageCopy2 raw() {
        return VkImageCopy2 {
            .sType = VK_STRUCT_TYPE_IMAGE_COPY2,
            .pNext = nullptr,
            .srcSubresource = src_subresource.raw(),
            .srcOffset = src_offset.raw(),
            .dstSubresource = dst_subresource.raw(),
            .dstOffset = dst_offset.raw(),
            .extent = extent.raw()
        };
    }
};

struct ImageCreateInfo {
    VkImageCreateFlags flags;
    ImageType image_type;
    Format format;
    Extent3D extent;
    u32 mip_levels;
    u32 array_layers;
    SampleCountFlags samples;
    ImageTiling tiling;
    VkImageUsageFlags usage;
    SharingMode sharing_mode;
    u32 queue_family_index_count;
    uint32_t* queue_family_indices;
    ImageLayout initial_layout;
    
    VkImageCreateInfo raw() {
        return VkImageCreateInfo {
            .sType = VK_STRUCT_TYPE_IMAGE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .imageType = static_cast<VkImageType>(image_type),
            .format = static_cast<VkFormat>(format),
            .extent = extent.raw(),
            .mipLevels = mip_levels,
            .arrayLayers = array_layers,
            .samples = static_cast<VkSampleCountFlagBits>(samples),
            .tiling = static_cast<VkImageTiling>(tiling),
            .usage = usage,
            .sharingMode = static_cast<VkSharingMode>(sharing_mode),
            .queueFamilyIndexCount = queue_family_index_count,
            .pQueueFamilyIndices = queue_family_indices,
            .initialLayout = static_cast<VkImageLayout>(initial_layout)
        };
    }
};

struct ImageDrmFormatModifierExplicitCreateInfoEXT {
    uint64_t drm_format_modifier;
    u32 drm_format_modifier_plane_count;
    VkSubresourceLayout* plane_layouts;
    
    VkImageDrmFormatModifierExplicitCreateInfoEXT raw() {
        return VkImageDrmFormatModifierExplicitCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT,
            .pNext = nullptr,
            .drmFormatModifier = drm_format_modifier,
            .drmFormatModifierPlaneCount = drm_format_modifier_plane_count,
            .pPlaneLayouts = plane_layouts
        };
    }
};

struct ImageDrmFormatModifierListCreateInfoEXT {
    u32 drm_format_modifier_count;
    uint64_t* drm_format_modifiers;
    
    VkImageDrmFormatModifierListCreateInfoEXT raw() {
        return VkImageDrmFormatModifierListCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT,
            .pNext = nullptr,
            .drmFormatModifierCount = drm_format_modifier_count,
            .pDrmFormatModifiers = drm_format_modifiers
        };
    }
};

struct ImageDrmFormatModifierPropertiesEXT {
    uint64_t drm_format_modifier;
    
    VkImageDrmFormatModifierPropertiesEXT raw() {
        return VkImageDrmFormatModifierPropertiesEXT {
            .sType = VK_STRUCT_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
            .pNext = nullptr,
            .drmFormatModifier = drm_format_modifier
        };
    }
};

struct ImageFormatListCreateInfo {
    u32 view_format_count;
    VkFormat* view_formats;
    
    VkImageFormatListCreateInfo raw() {
        return VkImageFormatListCreateInfo {
            .sType = VK_STRUCT_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO,
            .pNext = nullptr,
            .viewFormatCount = view_format_count,
            .pViewFormats = view_formats
        };
    }
};

struct ImageFormatProperties {
    Extent3D max_extent;
    u32 max_mip_levels;
    u32 max_array_layers;
    VkSampleCountFlags sample_counts;
    VkDeviceSize max_resource_size;
    
    VkImageFormatProperties raw() {
        return VkImageFormatProperties {
            .maxExtent = max_extent.raw(),
            .maxMipLevels = max_mip_levels,
            .maxArrayLayers = max_array_layers,
            .sampleCounts = sample_counts,
            .maxResourceSize = max_resource_size
        };
    }
};

struct ImageFormatProperties2 {
    ImageFormatProperties image_format_properties;
    
    VkImageFormatProperties2 raw() {
        return VkImageFormatProperties2 {
            .sType = VK_STRUCT_TYPE_IMAGE_FORMAT_PROPERTIES2,
            .pNext = nullptr,
            .imageFormatProperties = image_format_properties.raw()
        };
    }
};

struct ImageMemoryBarrier {
    VkAccessFlags src_access_mask;
    VkAccessFlags dst_access_mask;
    ImageLayout old_layout;
    ImageLayout new_layout;
    u32 src_queue_family_index;
    u32 dst_queue_family_index;
    VkImage image;
    ImageSubresourceRange subresource_range;
    
    VkImageMemoryBarrier raw() {
        return VkImageMemoryBarrier {
            .sType = VK_STRUCT_TYPE_IMAGE_MEMORY_BARRIER,
            .pNext = nullptr,
            .srcAccessMask = src_access_mask,
            .dstAccessMask = dst_access_mask,
            .oldLayout = static_cast<VkImageLayout>(old_layout),
            .newLayout = static_cast<VkImageLayout>(new_layout),
            .srcQueueFamilyIndex = src_queue_family_index,
            .dstQueueFamilyIndex = dst_queue_family_index,
            .image = image,
            .subresourceRange = subresource_range.raw()
        };
    }
};

struct ImageMemoryBarrier2 {
    VkPipelineStageFlags2 src_stage_mask;
    VkAccessFlags2 src_access_mask;
    VkPipelineStageFlags2 dst_stage_mask;
    VkAccessFlags2 dst_access_mask;
    ImageLayout old_layout;
    ImageLayout new_layout;
    u32 src_queue_family_index;
    u32 dst_queue_family_index;
    VkImage image;
    ImageSubresourceRange subresource_range;
    
    VkImageMemoryBarrier2 raw() {
        return VkImageMemoryBarrier2 {
            .sType = VK_STRUCT_TYPE_IMAGE_MEMORY_BARRIER2,
            .pNext = nullptr,
            .srcStageMask = src_stage_mask,
            .srcAccessMask = src_access_mask,
            .dstStageMask = dst_stage_mask,
            .dstAccessMask = dst_access_mask,
            .oldLayout = static_cast<VkImageLayout>(old_layout),
            .newLayout = static_cast<VkImageLayout>(new_layout),
            .srcQueueFamilyIndex = src_queue_family_index,
            .dstQueueFamilyIndex = dst_queue_family_index,
            .image = image,
            .subresourceRange = subresource_range.raw()
        };
    }
};

struct ImageMemoryRequirementsInfo2 {
    VkImage image;
    
    VkImageMemoryRequirementsInfo2 raw() {
        return VkImageMemoryRequirementsInfo2 {
            .sType = VK_STRUCT_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO2,
            .pNext = nullptr,
            .image = image
        };
    }
};

struct ImagePlaneMemoryRequirementsInfo {
    ImageAspectFlags plane_aspect;
    
    VkImagePlaneMemoryRequirementsInfo raw() {
        return VkImagePlaneMemoryRequirementsInfo {
            .sType = VK_STRUCT_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
            .pNext = nullptr,
            .planeAspect = static_cast<VkImageAspectFlagBits>(plane_aspect)
        };
    }
};

struct ImageResolve {
    ImageSubresourceLayers src_subresource;
    Offset3D src_offset;
    ImageSubresourceLayers dst_subresource;
    Offset3D dst_offset;
    Extent3D extent;
    
    VkImageResolve raw() {
        return VkImageResolve {
            .srcSubresource = src_subresource.raw(),
            .srcOffset = src_offset.raw(),
            .dstSubresource = dst_subresource.raw(),
            .dstOffset = dst_offset.raw(),
            .extent = extent.raw()
        };
    }
};

struct ImageResolve2 {
    ImageSubresourceLayers src_subresource;
    Offset3D src_offset;
    ImageSubresourceLayers dst_subresource;
    Offset3D dst_offset;
    Extent3D extent;
    
    VkImageResolve2 raw() {
        return VkImageResolve2 {
            .sType = VK_STRUCT_TYPE_IMAGE_RESOLVE2,
            .pNext = nullptr,
            .srcSubresource = src_subresource.raw(),
            .srcOffset = src_offset.raw(),
            .dstSubresource = dst_subresource.raw(),
            .dstOffset = dst_offset.raw(),
            .extent = extent.raw()
        };
    }
};

struct ImageSparseMemoryRequirementsInfo2 {
    VkImage image;
    
    VkImageSparseMemoryRequirementsInfo2 raw() {
        return VkImageSparseMemoryRequirementsInfo2 {
            .sType = VK_STRUCT_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO2,
            .pNext = nullptr,
            .image = image
        };
    }
};

struct ImageStencilUsageCreateInfo {
    VkImageUsageFlags stencil_usage;
    
    VkImageStencilUsageCreateInfo raw() {
        return VkImageStencilUsageCreateInfo {
            .sType = VK_STRUCT_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO,
            .pNext = nullptr,
            .stencilUsage = stencil_usage
        };
    }
};

struct ImageSubresource {
    VkImageAspectFlags aspect_mask;
    u32 mip_level;
    u32 array_layer;
    
    VkImageSubresource raw() {
        return VkImageSubresource {
            .aspectMask = aspect_mask,
            .mipLevel = mip_level,
            .arrayLayer = array_layer
        };
    }
};

struct ImageSubresource2 {
    ImageSubresource image_subresource;
    
    VkImageSubresource2 raw() {
        return VkImageSubresource2 {
            .sType = VK_STRUCT_TYPE_IMAGE_SUBRESOURCE2,
            .pNext = nullptr,
            .imageSubresource = image_subresource.raw()
        };
    }
};

struct ImageSubresourceLayers {
    VkImageAspectFlags aspect_mask;
    u32 mip_level;
    u32 base_array_layer;
    u32 layer_count;
    
    VkImageSubresourceLayers raw() {
        return VkImageSubresourceLayers {
            .aspectMask = aspect_mask,
            .mipLevel = mip_level,
            .baseArrayLayer = base_array_layer,
            .layerCount = layer_count
        };
    }
};

struct ImageSubresourceRange {
    VkImageAspectFlags aspect_mask;
    u32 base_mip_level;
    u32 level_count;
    u32 base_array_layer;
    u32 layer_count;
    
    VkImageSubresourceRange raw() {
        return VkImageSubresourceRange {
            .aspectMask = aspect_mask,
            .baseMipLevel = base_mip_level,
            .levelCount = level_count,
            .baseArrayLayer = base_array_layer,
            .layerCount = layer_count
        };
    }
};

struct ImageSwapchainCreateInfoKHR {
    VkSwapchainKHR swapchain;
    
    VkImageSwapchainCreateInfoKHR raw() {
        return VkImageSwapchainCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR,
            .pNext = nullptr,
            .swapchain = swapchain
        };
    }
};

struct ImageToMemoryCopy {
    void* host_pointer;
    u32 memory_row_length;
    u32 memory_image_height;
    ImageSubresourceLayers image_subresource;
    Offset3D image_offset;
    Extent3D image_extent;
    
    VkImageToMemoryCopy raw() {
        return VkImageToMemoryCopy {
            .sType = VK_STRUCT_TYPE_IMAGE_TO_MEMORY_COPY,
            .pNext = nullptr,
            .pHostPointer = host_pointer,
            .memoryRowLength = memory_row_length,
            .memoryImageHeight = memory_image_height,
            .imageSubresource = image_subresource.raw(),
            .imageOffset = image_offset.raw(),
            .imageExtent = image_extent.raw()
        };
    }
};

struct ImageViewASTCDecodeModeEXT {
    Format decode_mode;
    
    VkImageViewASTCDecodeModeEXT raw() {
        return VkImageViewASTCDecodeModeEXT {
            .sType = VK_STRUCT_TYPE_IMAGE_VIEW_ASTCDECODE_MODE_EXT,
            .pNext = nullptr,
            .decodeMode = static_cast<VkFormat>(decode_mode)
        };
    }
};

struct ImageViewAddressPropertiesNVX {
    VkDeviceAddress device_address;
    VkDeviceSize size;
    
    VkImageViewAddressPropertiesNVX raw() {
        return VkImageViewAddressPropertiesNVX {
            .sType = VK_STRUCT_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX,
            .pNext = nullptr,
            .deviceAddress = device_address,
            .size = size
        };
    }
};

struct ImageViewCaptureDescriptorDataInfoEXT {
    VkImageView image_view;
    
    VkImageViewCaptureDescriptorDataInfoEXT raw() {
        return VkImageViewCaptureDescriptorDataInfoEXT {
            .sType = VK_STRUCT_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
            .pNext = nullptr,
            .imageView = image_view
        };
    }
};

struct ImageViewCreateInfo {
    VkImageViewCreateFlags flags;
    VkImage image;
    ImageViewType view_type;
    Format format;
    ComponentMapping components;
    ImageSubresourceRange subresource_range;
    
    VkImageViewCreateInfo raw() {
        return VkImageViewCreateInfo {
            .sType = VK_STRUCT_TYPE_IMAGE_VIEW_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .image = image,
            .viewType = static_cast<VkImageViewType>(view_type),
            .format = static_cast<VkFormat>(format),
            .components = components.raw(),
            .subresourceRange = subresource_range.raw()
        };
    }
};

struct ImageViewHandleInfoNVX {
    VkImageView image_view;
    DescriptorType descriptor_type;
    VkSampler sampler;
    
    VkImageViewHandleInfoNVX raw() {
        return VkImageViewHandleInfoNVX {
            .sType = VK_STRUCT_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX,
            .pNext = nullptr,
            .imageView = image_view,
            .descriptorType = static_cast<VkDescriptorType>(descriptor_type),
            .sampler = sampler
        };
    }
};

struct ImageViewMinLodCreateInfoEXT {
    f32 min_lod;
    
    VkImageViewMinLodCreateInfoEXT raw() {
        return VkImageViewMinLodCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT,
            .pNext = nullptr,
            .minLod = min_lod
        };
    }
};

struct ImageViewSampleWeightCreateInfoQCOM {
    Offset2D filter_center;
    Extent2D filter_size;
    u32 num_phases;
    
    VkImageViewSampleWeightCreateInfoQCOM raw() {
        return VkImageViewSampleWeightCreateInfoQCOM {
            .sType = VK_STRUCT_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM,
            .pNext = nullptr,
            .filterCenter = filter_center.raw(),
            .filterSize = filter_size.raw(),
            .numPhases = num_phases
        };
    }
};

struct ImageViewSlicedCreateInfoEXT {
    u32 slice_offset;
    u32 slice_count;
    
    VkImageViewSlicedCreateInfoEXT raw() {
        return VkImageViewSlicedCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT,
            .pNext = nullptr,
            .sliceOffset = slice_offset,
            .sliceCount = slice_count
        };
    }
};

struct ImageViewUsageCreateInfo {
    VkImageUsageFlags usage;
    
    VkImageViewUsageCreateInfo raw() {
        return VkImageViewUsageCreateInfo {
            .sType = VK_STRUCT_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
            .pNext = nullptr,
            .usage = usage
        };
    }
};

struct ImportFenceFdInfoKHR {
    VkFence fence;
    VkFenceImportFlags flags;
    ExternalFenceHandleTypeFlags handle_type;
    i32 fd;
    
    VkImportFenceFdInfoKHR raw() {
        return VkImportFenceFdInfoKHR {
            .sType = VK_STRUCT_TYPE_IMPORT_FENCE_FD_INFO_KHR,
            .pNext = nullptr,
            .fence = fence,
            .flags = flags,
            .handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(handle_type),
            .fd = fd
        };
    }
};

struct ImportMemoryFdInfoKHR {
    ExternalMemoryHandleTypeFlags handle_type;
    i32 fd;
    
    VkImportMemoryFdInfoKHR raw() {
        return VkImportMemoryFdInfoKHR {
            .sType = VK_STRUCT_TYPE_IMPORT_MEMORY_FD_INFO_KHR,
            .pNext = nullptr,
            .handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(handle_type),
            .fd = fd
        };
    }
};

struct ImportMemoryHostPointerInfoEXT {
    ExternalMemoryHandleTypeFlags handle_type;
    void* host_pointer;
    
    VkImportMemoryHostPointerInfoEXT raw() {
        return VkImportMemoryHostPointerInfoEXT {
            .sType = VK_STRUCT_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT,
            .pNext = nullptr,
            .handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(handle_type),
            .pHostPointer = host_pointer
        };
    }
};

struct ImportSemaphoreFdInfoKHR {
    VkSemaphore semaphore;
    VkSemaphoreImportFlags flags;
    ExternalSemaphoreHandleTypeFlags handle_type;
    i32 fd;
    
    VkImportSemaphoreFdInfoKHR raw() {
        return VkImportSemaphoreFdInfoKHR {
            .sType = VK_STRUCT_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR,
            .pNext = nullptr,
            .semaphore = semaphore,
            .flags = flags,
            .handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(handle_type),
            .fd = fd
        };
    }
};

struct IndirectCommandsExecutionSetTokenEXT {
    IndirectExecutionSetInfoTypeEXT type;
    VkShaderStageFlags shader_stages;
    
    VkIndirectCommandsExecutionSetTokenEXT raw() {
        return VkIndirectCommandsExecutionSetTokenEXT {
            .type = static_cast<VkIndirectExecutionSetInfoTypeEXT>(type),
            .shaderStages = shader_stages
        };
    }
};

struct IndirectCommandsIndexBufferTokenEXT {
    IndirectCommandsInputModeFlagsEXT mode;
    
    VkIndirectCommandsIndexBufferTokenEXT raw() {
        return VkIndirectCommandsIndexBufferTokenEXT {
            .mode = static_cast<VkIndirectCommandsInputModeFlagBitsEXT>(mode)
        };
    }
};

struct IndirectCommandsLayoutCreateInfoEXT {
    VkIndirectCommandsLayoutUsageFlagsEXT flags;
    VkShaderStageFlags shader_stages;
    u32 indirect_stride;
    VkPipelineLayout pipeline_layout;
    u32 token_count;
    VkIndirectCommandsLayoutTokenEXT* tokens;
    
    VkIndirectCommandsLayoutCreateInfoEXT raw() {
        return VkIndirectCommandsLayoutCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags,
            .shaderStages = shader_stages,
            .indirectStride = indirect_stride,
            .pipelineLayout = pipeline_layout,
            .tokenCount = token_count,
            .pTokens = tokens
        };
    }
};

struct IndirectCommandsLayoutCreateInfoNV {
    VkIndirectCommandsLayoutUsageFlagsNV flags;
    PipelineBindPoint pipeline_bind_point;
    u32 token_count;
    VkIndirectCommandsLayoutTokenNV* tokens;
    u32 stream_count;
    uint32_t* stream_strides;
    
    VkIndirectCommandsLayoutCreateInfoNV raw() {
        return VkIndirectCommandsLayoutCreateInfoNV {
            .sType = VK_STRUCT_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV,
            .pNext = nullptr,
            .flags = flags,
            .pipelineBindPoint = static_cast<VkPipelineBindPoint>(pipeline_bind_point),
            .tokenCount = token_count,
            .pTokens = tokens,
            .streamCount = stream_count,
            .pStreamStrides = stream_strides
        };
    }
};

struct IndirectCommandsLayoutTokenEXT {
    IndirectCommandsTokenTypeEXT type;
    VkIndirectCommandsTokenDataEXT data;
    u32 offset;
    
    VkIndirectCommandsLayoutTokenEXT raw() {
        return VkIndirectCommandsLayoutTokenEXT {
            .sType = VK_STRUCT_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT,
            .pNext = nullptr,
            .type = static_cast<VkIndirectCommandsTokenTypeEXT>(type),
            .data = data,
            .offset = offset
        };
    }
};

struct IndirectCommandsLayoutTokenNV {
    IndirectCommandsTokenTypeNV token_type;
    u32 stream;
    u32 offset;
    u32 vertex_binding_unit;
    bool vertex_dynamic_stride;
    VkPipelineLayout pushconstant_pipeline_layout;
    VkShaderStageFlags pushconstant_shader_stage_flags;
    u32 pushconstant_offset;
    u32 pushconstant_size;
    VkIndirectStateFlagsNV indirect_state_flags;
    u32 index_type_count;
    VkIndexType* index_types;
    uint32_t* index_type_values;
    
    VkIndirectCommandsLayoutTokenNV raw() {
        return VkIndirectCommandsLayoutTokenNV {
            .sType = VK_STRUCT_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV,
            .pNext = nullptr,
            .tokenType = static_cast<VkIndirectCommandsTokenTypeNV>(token_type),
            .stream = stream,
            .offset = offset,
            .vertexBindingUnit = vertex_binding_unit,
            .vertexDynamicStride = static_cast<VkBool32>(vertex_dynamic_stride),
            .pushconstantPipelineLayout = pushconstant_pipeline_layout,
            .pushconstantShaderStageFlags = pushconstant_shader_stage_flags,
            .pushconstantOffset = pushconstant_offset,
            .pushconstantSize = pushconstant_size,
            .indirectStateFlags = indirect_state_flags,
            .indexTypeCount = index_type_count,
            .pIndexTypes = index_types,
            .pIndexTypeValues = index_type_values
        };
    }
};

struct IndirectCommandsPushConstantTokenEXT {
    PushConstantRange update_range;
    
    VkIndirectCommandsPushConstantTokenEXT raw() {
        return VkIndirectCommandsPushConstantTokenEXT {
            .updateRange = update_range.raw()
        };
    }
};

struct IndirectCommandsStreamNV {
    VkBuffer buffer;
    VkDeviceSize offset;
    
    VkIndirectCommandsStreamNV raw() {
        return VkIndirectCommandsStreamNV {
            .buffer = buffer,
            .offset = offset
        };
    }
};

struct IndirectCommandsVertexBufferTokenEXT {
    u32 vertex_binding_unit;
    
    VkIndirectCommandsVertexBufferTokenEXT raw() {
        return VkIndirectCommandsVertexBufferTokenEXT {
            .vertexBindingUnit = vertex_binding_unit
        };
    }
};

struct IndirectExecutionSetCreateInfoEXT {
    IndirectExecutionSetInfoTypeEXT type;
    VkIndirectExecutionSetInfoEXT info;
    
    VkIndirectExecutionSetCreateInfoEXT raw() {
        return VkIndirectExecutionSetCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT,
            .pNext = nullptr,
            .type = static_cast<VkIndirectExecutionSetInfoTypeEXT>(type),
            .info = info
        };
    }
};

struct IndirectExecutionSetPipelineInfoEXT {
    VkPipeline initial_pipeline;
    u32 max_pipeline_count;
    
    VkIndirectExecutionSetPipelineInfoEXT raw() {
        return VkIndirectExecutionSetPipelineInfoEXT {
            .sType = VK_STRUCT_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT,
            .pNext = nullptr,
            .initialPipeline = initial_pipeline,
            .maxPipelineCount = max_pipeline_count
        };
    }
};

struct IndirectExecutionSetShaderInfoEXT {
    u32 shader_count;
    VkShaderEXT* initial_shaders;
    VkIndirectExecutionSetShaderLayoutInfoEXT* set_layout_infos;
    u32 max_shader_count;
    u32 push_constant_range_count;
    VkPushConstantRange* push_constant_ranges;
    
    VkIndirectExecutionSetShaderInfoEXT raw() {
        return VkIndirectExecutionSetShaderInfoEXT {
            .sType = VK_STRUCT_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT,
            .pNext = nullptr,
            .shaderCount = shader_count,
            .pInitialShaders = initial_shaders,
            .pSetLayoutInfos = set_layout_infos,
            .maxShaderCount = max_shader_count,
            .pushConstantRangeCount = push_constant_range_count,
            .pPushConstantRanges = push_constant_ranges
        };
    }
};

struct IndirectExecutionSetShaderLayoutInfoEXT {
    u32 set_layout_count;
    VkDescriptorSetLayout* set_layouts;
    
    VkIndirectExecutionSetShaderLayoutInfoEXT raw() {
        return VkIndirectExecutionSetShaderLayoutInfoEXT {
            .sType = VK_STRUCT_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT,
            .pNext = nullptr,
            .setLayoutCount = set_layout_count,
            .pSetLayouts = set_layouts
        };
    }
};

struct InitializePerformanceApiInfoINTEL {
    void* user_data;
    
    VkInitializePerformanceApiInfoINTEL raw() {
        return VkInitializePerformanceApiInfoINTEL {
            .sType = VK_STRUCT_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL,
            .pNext = nullptr,
            .pUserData = user_data
        };
    }
};

struct InputAttachmentAspectReference {
    u32 subpass;
    u32 input_attachment_index;
    VkImageAspectFlags aspect_mask;
    
    VkInputAttachmentAspectReference raw() {
        return VkInputAttachmentAspectReference {
            .subpass = subpass,
            .inputAttachmentIndex = input_attachment_index,
            .aspectMask = aspect_mask
        };
    }
};

struct InstanceCreateInfo {
    VkInstanceCreateFlags flags;
    VkApplicationInfo* application_info;
    u32 enabled_layer_count;
    char** pp_enabled_layer_names;
    u32 enabled_extension_count;
    char** pp_enabled_extension_names;
    
    VkInstanceCreateInfo raw() {
        return VkInstanceCreateInfo {
            .sType = VK_STRUCT_TYPE_INSTANCE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .pApplicationInfo = application_info,
            .enabledLayerCount = enabled_layer_count,
            .ppEnabledLayerNames = pp_enabled_layer_names,
            .enabledExtensionCount = enabled_extension_count,
            .ppEnabledExtensionNames = pp_enabled_extension_names
        };
    }
};

struct LatencySleepInfoNV {
    VkSemaphore signal_semaphore;
    uint64_t value;
    
    VkLatencySleepInfoNV raw() {
        return VkLatencySleepInfoNV {
            .sType = VK_STRUCT_TYPE_LATENCY_SLEEP_INFO_NV,
            .pNext = nullptr,
            .signalSemaphore = signal_semaphore,
            .value = value
        };
    }
};

struct LatencySleepModeInfoNV {
    bool low_latency_mode;
    bool low_latency_boost;
    u32 minimum_interval_us;
    
    VkLatencySleepModeInfoNV raw() {
        return VkLatencySleepModeInfoNV {
            .sType = VK_STRUCT_TYPE_LATENCY_SLEEP_MODE_INFO_NV,
            .pNext = nullptr,
            .lowLatencyMode = static_cast<VkBool32>(low_latency_mode),
            .lowLatencyBoost = static_cast<VkBool32>(low_latency_boost),
            .minimumIntervalUs = minimum_interval_us
        };
    }
};

struct LatencySubmissionPresentIdNV {
    uint64_t present_id;
    
    VkLatencySubmissionPresentIdNV raw() {
        return VkLatencySubmissionPresentIdNV {
            .sType = VK_STRUCT_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV,
            .pNext = nullptr,
            .presentID = present_id
        };
    }
};

struct LatencySurfaceCapabilitiesNV {
    u32 present_mode_count;
    VkPresentModeKHR* present_modes;
    
    VkLatencySurfaceCapabilitiesNV raw() {
        return VkLatencySurfaceCapabilitiesNV {
            .sType = VK_STRUCT_TYPE_LATENCY_SURFACE_CAPABILITIES_NV,
            .pNext = nullptr,
            .presentModeCount = present_mode_count,
            .pPresentModes = present_modes
        };
    }
};

struct LatencyTimingsFrameReportNV {
    uint64_t present_id;
    uint64_t input_sample_time_us;
    uint64_t sim_start_time_us;
    uint64_t sim_end_time_us;
    uint64_t render_submit_start_time_us;
    uint64_t render_submit_end_time_us;
    uint64_t present_start_time_us;
    uint64_t present_end_time_us;
    uint64_t driver_start_time_us;
    uint64_t driver_end_time_us;
    uint64_t os_render_queue_start_time_us;
    uint64_t os_render_queue_end_time_us;
    uint64_t gpu_render_start_time_us;
    uint64_t gpu_render_end_time_us;
    
    VkLatencyTimingsFrameReportNV raw() {
        return VkLatencyTimingsFrameReportNV {
            .sType = VK_STRUCT_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV,
            .pNext = nullptr,
            .presentID = present_id,
            .inputSampleTimeUs = input_sample_time_us,
            .simStartTimeUs = sim_start_time_us,
            .simEndTimeUs = sim_end_time_us,
            .renderSubmitStartTimeUs = render_submit_start_time_us,
            .renderSubmitEndTimeUs = render_submit_end_time_us,
            .presentStartTimeUs = present_start_time_us,
            .presentEndTimeUs = present_end_time_us,
            .driverStartTimeUs = driver_start_time_us,
            .driverEndTimeUs = driver_end_time_us,
            .osRenderQueueStartTimeUs = os_render_queue_start_time_us,
            .osRenderQueueEndTimeUs = os_render_queue_end_time_us,
            .gpuRenderStartTimeUs = gpu_render_start_time_us,
            .gpuRenderEndTimeUs = gpu_render_end_time_us
        };
    }
};

struct LayerProperties {
    char[] vk_max_extension_name_size;
    u32 spec_version;
    u32 implementation_version;
    char[] vk_max_description_size;
    
    VkLayerProperties raw() {
        return VkLayerProperties {
            .VK_MAX_EXTENSION_NAME_SIZE = vk_max_extension_name_size,
            .specVersion = spec_version,
            .implementationVersion = implementation_version,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size
        };
    }
};

struct LayerSettingEXT {
    char* layer_name;
    char* setting_name;
    LayerSettingTypeEXT type;
    u32 value_count;
    void* values;
    
    VkLayerSettingEXT raw() {
        return VkLayerSettingEXT {
            .pLayerName = layer_name,
            .pSettingName = setting_name,
            .type = static_cast<VkLayerSettingTypeEXT>(type),
            .valueCount = value_count,
            .pValues = values
        };
    }
};

struct LayerSettingsCreateInfoEXT {
    u32 setting_count;
    VkLayerSettingEXT* settings;
    
    VkLayerSettingsCreateInfoEXT raw() {
        return VkLayerSettingsCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT,
            .pNext = nullptr,
            .settingCount = setting_count,
            .pSettings = settings
        };
    }
};

struct MappedMemoryRange {
    VkDeviceMemory memory;
    VkDeviceSize offset;
    VkDeviceSize size;
    
    VkMappedMemoryRange raw() {
        return VkMappedMemoryRange {
            .sType = VK_STRUCT_TYPE_MAPPED_MEMORY_RANGE,
            .pNext = nullptr,
            .memory = memory,
            .offset = offset,
            .size = size
        };
    }
};

struct MemoryAllocateFlagsInfo {
    VkMemoryAllocateFlags flags;
    u32 device_mask;
    
    VkMemoryAllocateFlagsInfo raw() {
        return VkMemoryAllocateFlagsInfo {
            .sType = VK_STRUCT_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
            .pNext = nullptr,
            .flags = flags,
            .deviceMask = device_mask
        };
    }
};

struct MemoryAllocateInfo {
    VkDeviceSize allocation_size;
    u32 memory_type_index;
    
    VkMemoryAllocateInfo raw() {
        return VkMemoryAllocateInfo {
            .sType = VK_STRUCT_TYPE_MEMORY_ALLOCATE_INFO,
            .pNext = nullptr,
            .allocationSize = allocation_size,
            .memoryTypeIndex = memory_type_index
        };
    }
};

struct MemoryBarrier {
    VkAccessFlags src_access_mask;
    VkAccessFlags dst_access_mask;
    
    VkMemoryBarrier raw() {
        return VkMemoryBarrier {
            .sType = VK_STRUCT_TYPE_MEMORY_BARRIER,
            .pNext = nullptr,
            .srcAccessMask = src_access_mask,
            .dstAccessMask = dst_access_mask
        };
    }
};

struct MemoryBarrier2 {
    VkPipelineStageFlags2 src_stage_mask;
    VkAccessFlags2 src_access_mask;
    VkPipelineStageFlags2 dst_stage_mask;
    VkAccessFlags2 dst_access_mask;
    
    VkMemoryBarrier2 raw() {
        return VkMemoryBarrier2 {
            .sType = VK_STRUCT_TYPE_MEMORY_BARRIER2,
            .pNext = nullptr,
            .srcStageMask = src_stage_mask,
            .srcAccessMask = src_access_mask,
            .dstStageMask = dst_stage_mask,
            .dstAccessMask = dst_access_mask
        };
    }
};

struct MemoryBarrierAccessFlags3KHR {
    VkAccessFlags3KHR src_access_mask3;
    VkAccessFlags3KHR dst_access_mask3;
    
    VkMemoryBarrierAccessFlags3KHR raw() {
        return VkMemoryBarrierAccessFlags3KHR {
            .sType = VK_STRUCT_TYPE_MEMORY_BARRIER_ACCESS_FLAGS3KHR,
            .pNext = nullptr,
            .srcAccessMask3 = src_access_mask3,
            .dstAccessMask3 = dst_access_mask3
        };
    }
};

struct MemoryDedicatedAllocateInfo {
    VkImage image;
    VkBuffer buffer;
    
    VkMemoryDedicatedAllocateInfo raw() {
        return VkMemoryDedicatedAllocateInfo {
            .sType = VK_STRUCT_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
            .pNext = nullptr,
            .image = image,
            .buffer = buffer
        };
    }
};

struct MemoryDedicatedRequirements {
    bool prefers_dedicated_allocation;
    bool requires_dedicated_allocation;
    
    VkMemoryDedicatedRequirements raw() {
        return VkMemoryDedicatedRequirements {
            .sType = VK_STRUCT_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
            .pNext = nullptr,
            .prefersDedicatedAllocation = static_cast<VkBool32>(prefers_dedicated_allocation),
            .requiresDedicatedAllocation = static_cast<VkBool32>(requires_dedicated_allocation)
        };
    }
};

struct MemoryFdPropertiesKHR {
    u32 memory_type_bits;
    
    VkMemoryFdPropertiesKHR raw() {
        return VkMemoryFdPropertiesKHR {
            .sType = VK_STRUCT_TYPE_MEMORY_FD_PROPERTIES_KHR,
            .pNext = nullptr,
            .memoryTypeBits = memory_type_bits
        };
    }
};

struct MemoryGetFdInfoKHR {
    VkDeviceMemory memory;
    ExternalMemoryHandleTypeFlags handle_type;
    
    VkMemoryGetFdInfoKHR raw() {
        return VkMemoryGetFdInfoKHR {
            .sType = VK_STRUCT_TYPE_MEMORY_GET_FD_INFO_KHR,
            .pNext = nullptr,
            .memory = memory,
            .handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(handle_type)
        };
    }
};

struct MemoryGetRemoteAddressInfoNV {
    VkDeviceMemory memory;
    ExternalMemoryHandleTypeFlags handle_type;
    
    VkMemoryGetRemoteAddressInfoNV raw() {
        return VkMemoryGetRemoteAddressInfoNV {
            .sType = VK_STRUCT_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV,
            .pNext = nullptr,
            .memory = memory,
            .handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(handle_type)
        };
    }
};

struct MemoryHeap {
    VkDeviceSize size;
    VkMemoryHeapFlags flags;
    
    VkMemoryHeap raw() {
        return VkMemoryHeap {
            .size = size,
            .flags = flags
        };
    }
};

struct MemoryHostPointerPropertiesEXT {
    u32 memory_type_bits;
    
    VkMemoryHostPointerPropertiesEXT raw() {
        return VkMemoryHostPointerPropertiesEXT {
            .sType = VK_STRUCT_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT,
            .pNext = nullptr,
            .memoryTypeBits = memory_type_bits
        };
    }
};

struct MemoryMapInfo {
    VkMemoryMapFlags flags;
    VkDeviceMemory memory;
    VkDeviceSize offset;
    VkDeviceSize size;
    
    VkMemoryMapInfo raw() {
        return VkMemoryMapInfo {
            .sType = VK_STRUCT_TYPE_MEMORY_MAP_INFO,
            .pNext = nullptr,
            .flags = flags,
            .memory = memory,
            .offset = offset,
            .size = size
        };
    }
};

struct MemoryMapPlacedInfoEXT {
    void* placed_address;
    
    VkMemoryMapPlacedInfoEXT raw() {
        return VkMemoryMapPlacedInfoEXT {
            .sType = VK_STRUCT_TYPE_MEMORY_MAP_PLACED_INFO_EXT,
            .pNext = nullptr,
            .pPlacedAddress = placed_address
        };
    }
};

struct MemoryOpaqueCaptureAddressAllocateInfo {
    uint64_t opaque_capture_address;
    
    VkMemoryOpaqueCaptureAddressAllocateInfo raw() {
        return VkMemoryOpaqueCaptureAddressAllocateInfo {
            .sType = VK_STRUCT_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO,
            .pNext = nullptr,
            .opaqueCaptureAddress = opaque_capture_address
        };
    }
};

struct MemoryPriorityAllocateInfoEXT {
    f32 priority;
    
    VkMemoryPriorityAllocateInfoEXT raw() {
        return VkMemoryPriorityAllocateInfoEXT {
            .sType = VK_STRUCT_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT,
            .pNext = nullptr,
            .priority = priority
        };
    }
};

struct MemoryRequirements {
    VkDeviceSize size;
    VkDeviceSize alignment;
    u32 memory_type_bits;
    
    VkMemoryRequirements raw() {
        return VkMemoryRequirements {
            .size = size,
            .alignment = alignment,
            .memoryTypeBits = memory_type_bits
        };
    }
};

struct MemoryRequirements2 {
    MemoryRequirements memory_requirements;
    
    VkMemoryRequirements2 raw() {
        return VkMemoryRequirements2 {
            .sType = VK_STRUCT_TYPE_MEMORY_REQUIREMENTS2,
            .pNext = nullptr,
            .memoryRequirements = memory_requirements.raw()
        };
    }
};

struct MemoryToImageCopy {
    void* host_pointer;
    u32 memory_row_length;
    u32 memory_image_height;
    ImageSubresourceLayers image_subresource;
    Offset3D image_offset;
    Extent3D image_extent;
    
    VkMemoryToImageCopy raw() {
        return VkMemoryToImageCopy {
            .sType = VK_STRUCT_TYPE_MEMORY_TO_IMAGE_COPY,
            .pNext = nullptr,
            .pHostPointer = host_pointer,
            .memoryRowLength = memory_row_length,
            .memoryImageHeight = memory_image_height,
            .imageSubresource = image_subresource.raw(),
            .imageOffset = image_offset.raw(),
            .imageExtent = image_extent.raw()
        };
    }
};

struct MemoryType {
    VkMemoryPropertyFlags property_flags;
    u32 heap_index;
    
    VkMemoryType raw() {
        return VkMemoryType {
            .propertyFlags = property_flags,
            .heapIndex = heap_index
        };
    }
};

struct MemoryUnmapInfo {
    VkMemoryUnmapFlags flags;
    VkDeviceMemory memory;
    
    VkMemoryUnmapInfo raw() {
        return VkMemoryUnmapInfo {
            .sType = VK_STRUCT_TYPE_MEMORY_UNMAP_INFO,
            .pNext = nullptr,
            .flags = flags,
            .memory = memory
        };
    }
};

struct MicromapBuildInfoEXT {
    MicromapTypeEXT type;
    VkBuildMicromapFlagsEXT flags;
    BuildMicromapModeEXT mode;
    VkMicromapEXT dst_micromap;
    u32 usage_counts_count;
    VkMicromapUsageEXT* usage_counts;
    VkMicromapUsageEXT** pp_usage_counts;
    VkDeviceOrHostAddressConstKHR data;
    VkDeviceOrHostAddressKHR scratch_data;
    VkDeviceOrHostAddressConstKHR triangle_array;
    VkDeviceSize triangle_array_stride;
    
    VkMicromapBuildInfoEXT raw() {
        return VkMicromapBuildInfoEXT {
            .sType = VK_STRUCT_TYPE_MICROMAP_BUILD_INFO_EXT,
            .pNext = nullptr,
            .type = static_cast<VkMicromapTypeEXT>(type),
            .flags = flags,
            .mode = static_cast<VkBuildMicromapModeEXT>(mode),
            .dstMicromap = dst_micromap,
            .usageCountsCount = usage_counts_count,
            .pUsageCounts = usage_counts,
            .ppUsageCounts = pp_usage_counts,
            .data = data,
            .scratchData = scratch_data,
            .triangleArray = triangle_array,
            .triangleArrayStride = triangle_array_stride
        };
    }
};

struct MicromapBuildSizesInfoEXT {
    VkDeviceSize micromap_size;
    VkDeviceSize build_scratch_size;
    bool discardable;
    
    VkMicromapBuildSizesInfoEXT raw() {
        return VkMicromapBuildSizesInfoEXT {
            .sType = VK_STRUCT_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT,
            .pNext = nullptr,
            .micromapSize = micromap_size,
            .buildScratchSize = build_scratch_size,
            .discardable = static_cast<VkBool32>(discardable)
        };
    }
};

struct MicromapCreateInfoEXT {
    VkMicromapCreateFlagsEXT create_flags;
    VkBuffer buffer;
    VkDeviceSize offset;
    VkDeviceSize size;
    MicromapTypeEXT type;
    VkDeviceAddress device_address;
    
    VkMicromapCreateInfoEXT raw() {
        return VkMicromapCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_MICROMAP_CREATE_INFO_EXT,
            .pNext = nullptr,
            .createFlags = create_flags,
            .buffer = buffer,
            .offset = offset,
            .size = size,
            .type = static_cast<VkMicromapTypeEXT>(type),
            .deviceAddress = device_address
        };
    }
};

struct MicromapTriangleEXT {
    u32 data_offset;
    u16 subdivision_level;
    u16 format;
    
    VkMicromapTriangleEXT raw() {
        return VkMicromapTriangleEXT {
            .dataOffset = data_offset,
            .subdivisionLevel = subdivision_level,
            .format = format
        };
    }
};

struct MicromapUsageEXT {
    u32 count;
    u32 subdivision_level;
    u32 format;
    
    VkMicromapUsageEXT raw() {
        return VkMicromapUsageEXT {
            .count = count,
            .subdivisionLevel = subdivision_level,
            .format = format
        };
    }
};

struct MicromapVersionInfoEXT {
    uint8_t* version_data;
    
    VkMicromapVersionInfoEXT raw() {
        return VkMicromapVersionInfoEXT {
            .sType = VK_STRUCT_TYPE_MICROMAP_VERSION_INFO_EXT,
            .pNext = nullptr,
            .pVersionData = version_data
        };
    }
};

struct MultiDrawIndexedInfoEXT {
    u32 first_index;
    u32 index_count;
    i32 vertex_offset;
    
    VkMultiDrawIndexedInfoEXT raw() {
        return VkMultiDrawIndexedInfoEXT {
            .firstIndex = first_index,
            .indexCount = index_count,
            .vertexOffset = vertex_offset
        };
    }
};

struct MultiDrawInfoEXT {
    u32 first_vertex;
    u32 vertex_count;
    
    VkMultiDrawInfoEXT raw() {
        return VkMultiDrawInfoEXT {
            .firstVertex = first_vertex,
            .vertexCount = vertex_count
        };
    }
};

struct MultisamplePropertiesEXT {
    Extent2D max_sample_location_grid_size;
    
    VkMultisamplePropertiesEXT raw() {
        return VkMultisamplePropertiesEXT {
            .sType = VK_STRUCT_TYPE_MULTISAMPLE_PROPERTIES_EXT,
            .pNext = nullptr,
            .maxSampleLocationGridSize = max_sample_location_grid_size.raw()
        };
    }
};

struct MultisampledRenderToSingleSampledInfoEXT {
    bool multisampled_render_to_single_sampled_enable;
    SampleCountFlags rasterization_samples;
    
    VkMultisampledRenderToSingleSampledInfoEXT raw() {
        return VkMultisampledRenderToSingleSampledInfoEXT {
            .sType = VK_STRUCT_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT,
            .pNext = nullptr,
            .multisampledRenderToSingleSampledEnable = static_cast<VkBool32>(multisampled_render_to_single_sampled_enable),
            .rasterizationSamples = static_cast<VkSampleCountFlagBits>(rasterization_samples)
        };
    }
};

struct MultiviewPerViewAttributesInfoNVX {
    bool per_view_attributes;
    bool per_view_attributes_position_xonly;
    
    VkMultiviewPerViewAttributesInfoNVX raw() {
        return VkMultiviewPerViewAttributesInfoNVX {
            .sType = VK_STRUCT_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX,
            .pNext = nullptr,
            .perViewAttributes = static_cast<VkBool32>(per_view_attributes),
            .perViewAttributesPositionXOnly = static_cast<VkBool32>(per_view_attributes_position_xonly)
        };
    }
};

struct MultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
    u32 per_view_render_area_count;
    VkRect2D* per_view_render_areas;
    
    VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM raw() {
        return VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM {
            .sType = VK_STRUCT_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM,
            .pNext = nullptr,
            .perViewRenderAreaCount = per_view_render_area_count,
            .pPerViewRenderAreas = per_view_render_areas
        };
    }
};

struct MutableDescriptorTypeCreateInfoEXT {
    u32 mutable_descriptor_type_list_count;
    VkMutableDescriptorTypeListEXT* mutable_descriptor_type_lists;
    
    VkMutableDescriptorTypeCreateInfoEXT raw() {
        return VkMutableDescriptorTypeCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .mutableDescriptorTypeListCount = mutable_descriptor_type_list_count,
            .pMutableDescriptorTypeLists = mutable_descriptor_type_lists
        };
    }
};

struct MutableDescriptorTypeListEXT {
    u32 descriptor_type_count;
    VkDescriptorType* descriptor_types;
    
    VkMutableDescriptorTypeListEXT raw() {
        return VkMutableDescriptorTypeListEXT {
            .descriptorTypeCount = descriptor_type_count,
            .pDescriptorTypes = descriptor_types
        };
    }
};

struct Offset2D {
    i32 x;
    i32 y;
    
    VkOffset2D raw() {
        return VkOffset2D {
            .x = x,
            .y = y
        };
    }
};

struct Offset3D {
    i32 x;
    i32 y;
    i32 z;
    
    VkOffset3D raw() {
        return VkOffset3D {
            .x = x,
            .y = y,
            .z = z
        };
    }
};

struct OpaqueCaptureDescriptorDataCreateInfoEXT {
    void* opaque_capture_descriptor_data;
    
    VkOpaqueCaptureDescriptorDataCreateInfoEXT raw() {
        return VkOpaqueCaptureDescriptorDataCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT,
            .pNext = nullptr,
            .opaqueCaptureDescriptorData = opaque_capture_descriptor_data
        };
    }
};

struct OpticalFlowExecuteInfoNV {
    VkOpticalFlowExecuteFlagsNV flags;
    u32 region_count;
    VkRect2D* regions;
    
    VkOpticalFlowExecuteInfoNV raw() {
        return VkOpticalFlowExecuteInfoNV {
            .sType = VK_STRUCT_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV,
            .pNext = nullptr,
            .flags = flags,
            .regionCount = region_count,
            .pRegions = regions
        };
    }
};

struct OpticalFlowImageFormatInfoNV {
    VkOpticalFlowUsageFlagsNV usage;
    
    VkOpticalFlowImageFormatInfoNV raw() {
        return VkOpticalFlowImageFormatInfoNV {
            .sType = VK_STRUCT_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV,
            .pNext = nullptr,
            .usage = usage
        };
    }
};

struct OpticalFlowImageFormatPropertiesNV {
    Format format;
    
    VkOpticalFlowImageFormatPropertiesNV raw() {
        return VkOpticalFlowImageFormatPropertiesNV {
            .sType = VK_STRUCT_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV,
            .pNext = nullptr,
            .format = static_cast<VkFormat>(format)
        };
    }
};

struct OpticalFlowSessionCreateInfoNV {
    u32 width;
    u32 height;
    Format image_format;
    Format flow_vector_format;
    Format cost_format;
    VkOpticalFlowGridSizeFlagsNV output_grid_size;
    VkOpticalFlowGridSizeFlagsNV hint_grid_size;
    OpticalFlowPerformanceLevelNV performance_level;
    VkOpticalFlowSessionCreateFlagsNV flags;
    
    VkOpticalFlowSessionCreateInfoNV raw() {
        return VkOpticalFlowSessionCreateInfoNV {
            .sType = VK_STRUCT_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV,
            .pNext = nullptr,
            .width = width,
            .height = height,
            .imageFormat = static_cast<VkFormat>(image_format),
            .flowVectorFormat = static_cast<VkFormat>(flow_vector_format),
            .costFormat = static_cast<VkFormat>(cost_format),
            .outputGridSize = output_grid_size,
            .hintGridSize = hint_grid_size,
            .performanceLevel = static_cast<VkOpticalFlowPerformanceLevelNV>(performance_level),
            .flags = flags
        };
    }
};

struct OpticalFlowSessionCreatePrivateDataInfoNV {
    u32 id;
    u32 size;
    void* private_data;
    
    VkOpticalFlowSessionCreatePrivateDataInfoNV raw() {
        return VkOpticalFlowSessionCreatePrivateDataInfoNV {
            .sType = VK_STRUCT_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV,
            .pNext = nullptr,
            .id = id,
            .size = size,
            .pPrivateData = private_data
        };
    }
};

struct OutOfBandQueueTypeInfoNV {
    OutOfBandQueueTypeNV queue_type;
    
    VkOutOfBandQueueTypeInfoNV raw() {
        return VkOutOfBandQueueTypeInfoNV {
            .sType = VK_STRUCT_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV,
            .pNext = nullptr,
            .queueType = static_cast<VkOutOfBandQueueTypeNV>(queue_type)
        };
    }
};

struct PartitionedAccelerationStructureFlagsNV {
    bool enable_partition_translation;
    
    VkPartitionedAccelerationStructureFlagsNV raw() {
        return VkPartitionedAccelerationStructureFlagsNV {
            .sType = VK_STRUCT_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV,
            .pNext = nullptr,
            .enablePartitionTranslation = static_cast<VkBool32>(enable_partition_translation)
        };
    }
};

struct PartitionedAccelerationStructureInstancesInputNV {
    VkBuildAccelerationStructureFlagsKHR flags;
    u32 instance_count;
    u32 max_instance_per_partition_count;
    u32 partition_count;
    u32 max_instance_in_global_partition_count;
    
    VkPartitionedAccelerationStructureInstancesInputNV raw() {
        return VkPartitionedAccelerationStructureInstancesInputNV {
            .sType = VK_STRUCT_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV,
            .pNext = nullptr,
            .flags = flags,
            .instanceCount = instance_count,
            .maxInstancePerPartitionCount = max_instance_per_partition_count,
            .partitionCount = partition_count,
            .maxInstanceInGlobalPartitionCount = max_instance_in_global_partition_count
        };
    }
};

struct PartitionedAccelerationStructureUpdateInstanceDataNV {
    u32 instance_index;
    u32 instance_contribution_to_hit_group_index;
    VkDeviceAddress acceleration_structure;
    
    VkPartitionedAccelerationStructureUpdateInstanceDataNV raw() {
        return VkPartitionedAccelerationStructureUpdateInstanceDataNV {
            .instanceIndex = instance_index,
            .instanceContributionToHitGroupIndex = instance_contribution_to_hit_group_index,
            .accelerationStructure = acceleration_structure
        };
    }
};

struct PartitionedAccelerationStructureWriteInstanceDataNV {
    TransformMatrixKHR transform;
    float[6] explicit_aabb;
    u32 instance_id;
    u32 instance_mask;
    u32 instance_contribution_to_hit_group_index;
    VkPartitionedAccelerationStructureInstanceFlagsNV instance_flags;
    u32 instance_index;
    u32 partition_index;
    VkDeviceAddress acceleration_structure;
    
    VkPartitionedAccelerationStructureWriteInstanceDataNV raw() {
        return VkPartitionedAccelerationStructureWriteInstanceDataNV {
            .transform = transform.raw(),
            .explicitAABB = explicit_aabb,
            .instanceID = instance_id,
            .instanceMask = instance_mask,
            .instanceContributionToHitGroupIndex = instance_contribution_to_hit_group_index,
            .instanceFlags = instance_flags,
            .instanceIndex = instance_index,
            .partitionIndex = partition_index,
            .accelerationStructure = acceleration_structure
        };
    }
};

struct PartitionedAccelerationStructureWritePartitionTranslationDataNV {
    u32 partition_index;
    float[3] partition_translation;
    
    VkPartitionedAccelerationStructureWritePartitionTranslationDataNV raw() {
        return VkPartitionedAccelerationStructureWritePartitionTranslationDataNV {
            .partitionIndex = partition_index,
            .partitionTranslation = partition_translation
        };
    }
};

struct PastPresentationTimingGOOGLE {
    u32 present_id;
    uint64_t desired_present_time;
    uint64_t actual_present_time;
    uint64_t earliest_present_time;
    uint64_t present_margin;
    
    VkPastPresentationTimingGOOGLE raw() {
        return VkPastPresentationTimingGOOGLE {
            .presentID = present_id,
            .desiredPresentTime = desired_present_time,
            .actualPresentTime = actual_present_time,
            .earliestPresentTime = earliest_present_time,
            .presentMargin = present_margin
        };
    }
};

struct PerTileBeginInfoQCOM {
    
    VkPerTileBeginInfoQCOM raw() {
        return VkPerTileBeginInfoQCOM {
            .sType = VK_STRUCT_TYPE_PER_TILE_BEGIN_INFO_QCOM,
            .pNext = nullptr,
        };
    }
};

struct PerTileEndInfoQCOM {
    
    VkPerTileEndInfoQCOM raw() {
        return VkPerTileEndInfoQCOM {
            .sType = VK_STRUCT_TYPE_PER_TILE_END_INFO_QCOM,
            .pNext = nullptr,
        };
    }
};

struct PerformanceConfigurationAcquireInfoINTEL {
    PerformanceConfigurationTypeINTEL type;
    
    VkPerformanceConfigurationAcquireInfoINTEL raw() {
        return VkPerformanceConfigurationAcquireInfoINTEL {
            .sType = VK_STRUCT_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
            .pNext = nullptr,
            .type = static_cast<VkPerformanceConfigurationTypeINTEL>(type)
        };
    }
};

struct PerformanceCounterDescriptionKHR {
    VkPerformanceCounterDescriptionFlagsKHR flags;
    char[] vk_max_description_size;
    char[] vk_max_description_size;
    char[] vk_max_description_size;
    
    VkPerformanceCounterDescriptionKHR raw() {
        return VkPerformanceCounterDescriptionKHR {
            .sType = VK_STRUCT_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR,
            .pNext = nullptr,
            .flags = flags,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size
        };
    }
};

struct PerformanceCounterKHR {
    PerformanceCounterUnitKHR unit;
    PerformanceCounterScopeKHR scope;
    PerformanceCounterStorageKHR storage;
    uint8_t[] vk_uuid_size;
    
    VkPerformanceCounterKHR raw() {
        return VkPerformanceCounterKHR {
            .sType = VK_STRUCT_TYPE_PERFORMANCE_COUNTER_KHR,
            .pNext = nullptr,
            .unit = static_cast<VkPerformanceCounterUnitKHR>(unit),
            .scope = static_cast<VkPerformanceCounterScopeKHR>(scope),
            .storage = static_cast<VkPerformanceCounterStorageKHR>(storage),
            .VK_UUID_SIZE = vk_uuid_size
        };
    }
};

struct PerformanceMarkerInfoINTEL {
    uint64_t marker;
    
    VkPerformanceMarkerInfoINTEL raw() {
        return VkPerformanceMarkerInfoINTEL {
            .sType = VK_STRUCT_TYPE_PERFORMANCE_MARKER_INFO_INTEL,
            .pNext = nullptr,
            .marker = marker
        };
    }
};

struct PerformanceOverrideInfoINTEL {
    PerformanceOverrideTypeINTEL type;
    bool enable;
    uint64_t parameter;
    
    VkPerformanceOverrideInfoINTEL raw() {
        return VkPerformanceOverrideInfoINTEL {
            .sType = VK_STRUCT_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL,
            .pNext = nullptr,
            .type = static_cast<VkPerformanceOverrideTypeINTEL>(type),
            .enable = static_cast<VkBool32>(enable),
            .parameter = parameter
        };
    }
};

struct PerformanceQuerySubmitInfoKHR {
    u32 counter_pass_index;
    
    VkPerformanceQuerySubmitInfoKHR raw() {
        return VkPerformanceQuerySubmitInfoKHR {
            .sType = VK_STRUCT_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR,
            .pNext = nullptr,
            .counterPassIndex = counter_pass_index
        };
    }
};

struct PerformanceStreamMarkerInfoINTEL {
    u32 marker;
    
    VkPerformanceStreamMarkerInfoINTEL raw() {
        return VkPerformanceStreamMarkerInfoINTEL {
            .sType = VK_STRUCT_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL,
            .pNext = nullptr,
            .marker = marker
        };
    }
};

struct PerformanceValueINTEL {
    PerformanceValueTypeINTEL type;
    VkPerformanceValueDataINTEL data;
    
    VkPerformanceValueINTEL raw() {
        return VkPerformanceValueINTEL {
            .type = static_cast<VkPerformanceValueTypeINTEL>(type),
            .data = data
        };
    }
};

struct PhysicalDevice16BitStorageFeatures {
    bool storage_buffer16bit_access;
    bool uniform_and_storage_buffer16bit_access;
    bool storage_push_constant16;
    bool storage_input_output16;
    
    VkPhysicalDevice16BitStorageFeatures raw() {
        return VkPhysicalDevice16BitStorageFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE16BIT_STORAGE_FEATURES,
            .pNext = nullptr,
            .storageBuffer16BitAccess = static_cast<VkBool32>(storage_buffer16bit_access),
            .uniformAndStorageBuffer16BitAccess = static_cast<VkBool32>(uniform_and_storage_buffer16bit_access),
            .storagePushConstant16 = static_cast<VkBool32>(storage_push_constant16),
            .storageInputOutput16 = static_cast<VkBool32>(storage_input_output16)
        };
    }
};

struct PhysicalDevice4444FormatsFeaturesEXT {
    bool format_a4r4g4b4;
    bool format_a4b4g4r4;
    
    VkPhysicalDevice4444FormatsFeaturesEXT raw() {
        return VkPhysicalDevice4444FormatsFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE4444FORMATS_FEATURES_EXT,
            .pNext = nullptr,
            .formatA4R4G4B4 = static_cast<VkBool32>(format_a4r4g4b4),
            .formatA4B4G4R4 = static_cast<VkBool32>(format_a4b4g4r4)
        };
    }
};

struct PhysicalDevice8BitStorageFeatures {
    bool storage_buffer8bit_access;
    bool uniform_and_storage_buffer8bit_access;
    bool storage_push_constant8;
    
    VkPhysicalDevice8BitStorageFeatures raw() {
        return VkPhysicalDevice8BitStorageFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE8BIT_STORAGE_FEATURES,
            .pNext = nullptr,
            .storageBuffer8BitAccess = static_cast<VkBool32>(storage_buffer8bit_access),
            .uniformAndStorageBuffer8BitAccess = static_cast<VkBool32>(uniform_and_storage_buffer8bit_access),
            .storagePushConstant8 = static_cast<VkBool32>(storage_push_constant8)
        };
    }
};

struct PhysicalDeviceASTCDecodeFeaturesEXT {
    bool decode_mode_shared_exponent;
    
    VkPhysicalDeviceASTCDecodeFeaturesEXT raw() {
        return VkPhysicalDeviceASTCDecodeFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_ASTCDECODE_FEATURES_EXT,
            .pNext = nullptr,
            .decodeModeSharedExponent = static_cast<VkBool32>(decode_mode_shared_exponent)
        };
    }
};

struct PhysicalDeviceAccelerationStructureFeaturesKHR {
    bool acceleration_structure;
    bool acceleration_structure_capture_replay;
    bool acceleration_structure_indirect_build;
    bool acceleration_structure_host_commands;
    bool descriptor_binding_acceleration_structure_update_after_bind;
    
    VkPhysicalDeviceAccelerationStructureFeaturesKHR raw() {
        return VkPhysicalDeviceAccelerationStructureFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,
            .pNext = nullptr,
            .accelerationStructure = static_cast<VkBool32>(acceleration_structure),
            .accelerationStructureCaptureReplay = static_cast<VkBool32>(acceleration_structure_capture_replay),
            .accelerationStructureIndirectBuild = static_cast<VkBool32>(acceleration_structure_indirect_build),
            .accelerationStructureHostCommands = static_cast<VkBool32>(acceleration_structure_host_commands),
            .descriptorBindingAccelerationStructureUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_acceleration_structure_update_after_bind)
        };
    }
};

struct PhysicalDeviceAccelerationStructurePropertiesKHR {
    uint64_t max_geometry_count;
    uint64_t max_instance_count;
    uint64_t max_primitive_count;
    u32 max_per_stage_descriptor_acceleration_structures;
    u32 max_per_stage_descriptor_update_after_bind_acceleration_structures;
    u32 max_descriptor_set_acceleration_structures;
    u32 max_descriptor_set_update_after_bind_acceleration_structures;
    u32 min_acceleration_structure_scratch_offset_alignment;
    
    VkPhysicalDeviceAccelerationStructurePropertiesKHR raw() {
        return VkPhysicalDeviceAccelerationStructurePropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,
            .pNext = nullptr,
            .maxGeometryCount = max_geometry_count,
            .maxInstanceCount = max_instance_count,
            .maxPrimitiveCount = max_primitive_count,
            .maxPerStageDescriptorAccelerationStructures = max_per_stage_descriptor_acceleration_structures,
            .maxPerStageDescriptorUpdateAfterBindAccelerationStructures = max_per_stage_descriptor_update_after_bind_acceleration_structures,
            .maxDescriptorSetAccelerationStructures = max_descriptor_set_acceleration_structures,
            .maxDescriptorSetUpdateAfterBindAccelerationStructures = max_descriptor_set_update_after_bind_acceleration_structures,
            .minAccelerationStructureScratchOffsetAlignment = min_acceleration_structure_scratch_offset_alignment
        };
    }
};

struct PhysicalDeviceAddressBindingReportFeaturesEXT {
    bool report_address_binding;
    
    VkPhysicalDeviceAddressBindingReportFeaturesEXT raw() {
        return VkPhysicalDeviceAddressBindingReportFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT,
            .pNext = nullptr,
            .reportAddressBinding = static_cast<VkBool32>(report_address_binding)
        };
    }
};

struct PhysicalDeviceAmigoProfilingFeaturesSEC {
    bool amigo_profiling;
    
    VkPhysicalDeviceAmigoProfilingFeaturesSEC raw() {
        return VkPhysicalDeviceAmigoProfilingFeaturesSEC {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC,
            .pNext = nullptr,
            .amigoProfiling = static_cast<VkBool32>(amigo_profiling)
        };
    }
};

struct PhysicalDeviceAntiLagFeaturesAMD {
    bool anti_lag;
    
    VkPhysicalDeviceAntiLagFeaturesAMD raw() {
        return VkPhysicalDeviceAntiLagFeaturesAMD {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD,
            .pNext = nullptr,
            .antiLag = static_cast<VkBool32>(anti_lag)
        };
    }
};

struct PhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
    bool attachment_feedback_loop_dynamic_state;
    
    VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT raw() {
        return VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT,
            .pNext = nullptr,
            .attachmentFeedbackLoopDynamicState = static_cast<VkBool32>(attachment_feedback_loop_dynamic_state)
        };
    }
};

struct PhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
    bool attachment_feedback_loop_layout;
    
    VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT raw() {
        return VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,
            .pNext = nullptr,
            .attachmentFeedbackLoopLayout = static_cast<VkBool32>(attachment_feedback_loop_layout)
        };
    }
};

struct PhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    bool advanced_blend_coherent_operations;
    
    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT raw() {
        return VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT,
            .pNext = nullptr,
            .advancedBlendCoherentOperations = static_cast<VkBool32>(advanced_blend_coherent_operations)
        };
    }
};

struct PhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    u32 advanced_blend_max_color_attachments;
    bool advanced_blend_independent_blend;
    bool advanced_blend_non_premultiplied_src_color;
    bool advanced_blend_non_premultiplied_dst_color;
    bool advanced_blend_correlated_overlap;
    bool advanced_blend_all_operations;
    
    VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT raw() {
        return VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT,
            .pNext = nullptr,
            .advancedBlendMaxColorAttachments = advanced_blend_max_color_attachments,
            .advancedBlendIndependentBlend = static_cast<VkBool32>(advanced_blend_independent_blend),
            .advancedBlendNonPremultipliedSrcColor = static_cast<VkBool32>(advanced_blend_non_premultiplied_src_color),
            .advancedBlendNonPremultipliedDstColor = static_cast<VkBool32>(advanced_blend_non_premultiplied_dst_color),
            .advancedBlendCorrelatedOverlap = static_cast<VkBool32>(advanced_blend_correlated_overlap),
            .advancedBlendAllOperations = static_cast<VkBool32>(advanced_blend_all_operations)
        };
    }
};

struct PhysicalDeviceBorderColorSwizzleFeaturesEXT {
    bool border_color_swizzle;
    bool border_color_swizzle_from_image;
    
    VkPhysicalDeviceBorderColorSwizzleFeaturesEXT raw() {
        return VkPhysicalDeviceBorderColorSwizzleFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,
            .pNext = nullptr,
            .borderColorSwizzle = static_cast<VkBool32>(border_color_swizzle),
            .borderColorSwizzleFromImage = static_cast<VkBool32>(border_color_swizzle_from_image)
        };
    }
};

struct PhysicalDeviceBufferDeviceAddressFeatures {
    bool buffer_device_address;
    bool buffer_device_address_capture_replay;
    bool buffer_device_address_multi_device;
    
    VkPhysicalDeviceBufferDeviceAddressFeatures raw() {
        return VkPhysicalDeviceBufferDeviceAddressFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES,
            .pNext = nullptr,
            .bufferDeviceAddress = static_cast<VkBool32>(buffer_device_address),
            .bufferDeviceAddressCaptureReplay = static_cast<VkBool32>(buffer_device_address_capture_replay),
            .bufferDeviceAddressMultiDevice = static_cast<VkBool32>(buffer_device_address_multi_device)
        };
    }
};

struct PhysicalDeviceBufferDeviceAddressFeaturesEXT {
    bool buffer_device_address;
    bool buffer_device_address_capture_replay;
    bool buffer_device_address_multi_device;
    
    VkPhysicalDeviceBufferDeviceAddressFeaturesEXT raw() {
        return VkPhysicalDeviceBufferDeviceAddressFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT,
            .pNext = nullptr,
            .bufferDeviceAddress = static_cast<VkBool32>(buffer_device_address),
            .bufferDeviceAddressCaptureReplay = static_cast<VkBool32>(buffer_device_address_capture_replay),
            .bufferDeviceAddressMultiDevice = static_cast<VkBool32>(buffer_device_address_multi_device)
        };
    }
};

struct PhysicalDeviceClusterAccelerationStructureFeaturesNV {
    bool cluster_acceleration_structure;
    
    VkPhysicalDeviceClusterAccelerationStructureFeaturesNV raw() {
        return VkPhysicalDeviceClusterAccelerationStructureFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV,
            .pNext = nullptr,
            .clusterAccelerationStructure = static_cast<VkBool32>(cluster_acceleration_structure)
        };
    }
};

struct PhysicalDeviceClusterAccelerationStructurePropertiesNV {
    u32 max_vertices_per_cluster;
    u32 max_triangles_per_cluster;
    u32 cluster_scratch_byte_alignment;
    u32 cluster_byte_alignment;
    u32 cluster_template_byte_alignment;
    u32 cluster_bottom_level_byte_alignment;
    u32 cluster_template_bounds_byte_alignment;
    u32 max_cluster_geometry_index;
    
    VkPhysicalDeviceClusterAccelerationStructurePropertiesNV raw() {
        return VkPhysicalDeviceClusterAccelerationStructurePropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV,
            .pNext = nullptr,
            .maxVerticesPerCluster = max_vertices_per_cluster,
            .maxTrianglesPerCluster = max_triangles_per_cluster,
            .clusterScratchByteAlignment = cluster_scratch_byte_alignment,
            .clusterByteAlignment = cluster_byte_alignment,
            .clusterTemplateByteAlignment = cluster_template_byte_alignment,
            .clusterBottomLevelByteAlignment = cluster_bottom_level_byte_alignment,
            .clusterTemplateBoundsByteAlignment = cluster_template_bounds_byte_alignment,
            .maxClusterGeometryIndex = max_cluster_geometry_index
        };
    }
};

struct PhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
    bool clusterculling_shader;
    bool multiview_cluster_culling_shader;
    
    VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI raw() {
        return VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI,
            .pNext = nullptr,
            .clustercullingShader = static_cast<VkBool32>(clusterculling_shader),
            .multiviewClusterCullingShader = static_cast<VkBool32>(multiview_cluster_culling_shader)
        };
    }
};

struct PhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
    uint32_t[3] max_work_group_count;
    uint32_t[3] max_work_group_size;
    u32 max_output_cluster_count;
    VkDeviceSize indirect_buffer_offset_alignment;
    
    VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI raw() {
        return VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI,
            .pNext = nullptr,
            .maxWorkGroupCount = max_work_group_count,
            .maxWorkGroupSize = max_work_group_size,
            .maxOutputClusterCount = max_output_cluster_count,
            .indirectBufferOffsetAlignment = indirect_buffer_offset_alignment
        };
    }
};

struct PhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI {
    bool cluster_shading_rate;
    
    VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI raw() {
        return VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI,
            .pNext = nullptr,
            .clusterShadingRate = static_cast<VkBool32>(cluster_shading_rate)
        };
    }
};

struct PhysicalDeviceCoherentMemoryFeaturesAMD {
    bool device_coherent_memory;
    
    VkPhysicalDeviceCoherentMemoryFeaturesAMD raw() {
        return VkPhysicalDeviceCoherentMemoryFeaturesAMD {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD,
            .pNext = nullptr,
            .deviceCoherentMemory = static_cast<VkBool32>(device_coherent_memory)
        };
    }
};

struct PhysicalDeviceColorWriteEnableFeaturesEXT {
    bool color_write_enable;
    
    VkPhysicalDeviceColorWriteEnableFeaturesEXT raw() {
        return VkPhysicalDeviceColorWriteEnableFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT,
            .pNext = nullptr,
            .colorWriteEnable = static_cast<VkBool32>(color_write_enable)
        };
    }
};

struct PhysicalDeviceCommandBufferInheritanceFeaturesNV {
    bool command_buffer_inheritance;
    
    VkPhysicalDeviceCommandBufferInheritanceFeaturesNV raw() {
        return VkPhysicalDeviceCommandBufferInheritanceFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV,
            .pNext = nullptr,
            .commandBufferInheritance = static_cast<VkBool32>(command_buffer_inheritance)
        };
    }
};

struct PhysicalDeviceComputeShaderDerivativesFeaturesKHR {
    bool compute_derivative_group_quads;
    bool compute_derivative_group_linear;
    
    VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR raw() {
        return VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR,
            .pNext = nullptr,
            .computeDerivativeGroupQuads = static_cast<VkBool32>(compute_derivative_group_quads),
            .computeDerivativeGroupLinear = static_cast<VkBool32>(compute_derivative_group_linear)
        };
    }
};

struct PhysicalDeviceComputeShaderDerivativesPropertiesKHR {
    bool mesh_and_task_shader_derivatives;
    
    VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR raw() {
        return VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR,
            .pNext = nullptr,
            .meshAndTaskShaderDerivatives = static_cast<VkBool32>(mesh_and_task_shader_derivatives)
        };
    }
};

struct PhysicalDeviceConditionalRenderingFeaturesEXT {
    bool conditional_rendering;
    bool inherited_conditional_rendering;
    
    VkPhysicalDeviceConditionalRenderingFeaturesEXT raw() {
        return VkPhysicalDeviceConditionalRenderingFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT,
            .pNext = nullptr,
            .conditionalRendering = static_cast<VkBool32>(conditional_rendering),
            .inheritedConditionalRendering = static_cast<VkBool32>(inherited_conditional_rendering)
        };
    }
};

struct PhysicalDeviceConservativeRasterizationPropertiesEXT {
    f32 primitive_overestimation_size;
    f32 max_extra_primitive_overestimation_size;
    f32 extra_primitive_overestimation_size_granularity;
    bool primitive_underestimation;
    bool conservative_point_and_line_rasterization;
    bool degenerate_triangles_rasterized;
    bool degenerate_lines_rasterized;
    bool fully_covered_fragment_shader_input_variable;
    bool conservative_rasterization_post_depth_coverage;
    
    VkPhysicalDeviceConservativeRasterizationPropertiesEXT raw() {
        return VkPhysicalDeviceConservativeRasterizationPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT,
            .pNext = nullptr,
            .primitiveOverestimationSize = primitive_overestimation_size,
            .maxExtraPrimitiveOverestimationSize = max_extra_primitive_overestimation_size,
            .extraPrimitiveOverestimationSizeGranularity = extra_primitive_overestimation_size_granularity,
            .primitiveUnderestimation = static_cast<VkBool32>(primitive_underestimation),
            .conservativePointAndLineRasterization = static_cast<VkBool32>(conservative_point_and_line_rasterization),
            .degenerateTrianglesRasterized = static_cast<VkBool32>(degenerate_triangles_rasterized),
            .degenerateLinesRasterized = static_cast<VkBool32>(degenerate_lines_rasterized),
            .fullyCoveredFragmentShaderInputVariable = static_cast<VkBool32>(fully_covered_fragment_shader_input_variable),
            .conservativeRasterizationPostDepthCoverage = static_cast<VkBool32>(conservative_rasterization_post_depth_coverage)
        };
    }
};

struct PhysicalDeviceCooperativeMatrix2FeaturesNV {
    bool cooperative_matrix_workgroup_scope;
    bool cooperative_matrix_flexible_dimensions;
    bool cooperative_matrix_reductions;
    bool cooperative_matrix_conversions;
    bool cooperative_matrix_per_element_operations;
    bool cooperative_matrix_tensor_addressing;
    bool cooperative_matrix_block_loads;
    
    VkPhysicalDeviceCooperativeMatrix2FeaturesNV raw() {
        return VkPhysicalDeviceCooperativeMatrix2FeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX2FEATURES_NV,
            .pNext = nullptr,
            .cooperativeMatrixWorkgroupScope = static_cast<VkBool32>(cooperative_matrix_workgroup_scope),
            .cooperativeMatrixFlexibleDimensions = static_cast<VkBool32>(cooperative_matrix_flexible_dimensions),
            .cooperativeMatrixReductions = static_cast<VkBool32>(cooperative_matrix_reductions),
            .cooperativeMatrixConversions = static_cast<VkBool32>(cooperative_matrix_conversions),
            .cooperativeMatrixPerElementOperations = static_cast<VkBool32>(cooperative_matrix_per_element_operations),
            .cooperativeMatrixTensorAddressing = static_cast<VkBool32>(cooperative_matrix_tensor_addressing),
            .cooperativeMatrixBlockLoads = static_cast<VkBool32>(cooperative_matrix_block_loads)
        };
    }
};

struct PhysicalDeviceCooperativeMatrix2PropertiesNV {
    u32 cooperative_matrix_workgroup_scope_max_workgroup_size;
    u32 cooperative_matrix_flexible_dimensions_max_dimension;
    u32 cooperative_matrix_workgroup_scope_reserved_shared_memory;
    
    VkPhysicalDeviceCooperativeMatrix2PropertiesNV raw() {
        return VkPhysicalDeviceCooperativeMatrix2PropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX2PROPERTIES_NV,
            .pNext = nullptr,
            .cooperativeMatrixWorkgroupScopeMaxWorkgroupSize = cooperative_matrix_workgroup_scope_max_workgroup_size,
            .cooperativeMatrixFlexibleDimensionsMaxDimension = cooperative_matrix_flexible_dimensions_max_dimension,
            .cooperativeMatrixWorkgroupScopeReservedSharedMemory = cooperative_matrix_workgroup_scope_reserved_shared_memory
        };
    }
};

struct PhysicalDeviceCooperativeMatrixFeaturesKHR {
    bool cooperative_matrix;
    bool cooperative_matrix_robust_buffer_access;
    
    VkPhysicalDeviceCooperativeMatrixFeaturesKHR raw() {
        return VkPhysicalDeviceCooperativeMatrixFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR,
            .pNext = nullptr,
            .cooperativeMatrix = static_cast<VkBool32>(cooperative_matrix),
            .cooperativeMatrixRobustBufferAccess = static_cast<VkBool32>(cooperative_matrix_robust_buffer_access)
        };
    }
};

struct PhysicalDeviceCooperativeMatrixFeaturesNV {
    bool cooperative_matrix;
    bool cooperative_matrix_robust_buffer_access;
    
    VkPhysicalDeviceCooperativeMatrixFeaturesNV raw() {
        return VkPhysicalDeviceCooperativeMatrixFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV,
            .pNext = nullptr,
            .cooperativeMatrix = static_cast<VkBool32>(cooperative_matrix),
            .cooperativeMatrixRobustBufferAccess = static_cast<VkBool32>(cooperative_matrix_robust_buffer_access)
        };
    }
};

struct PhysicalDeviceCooperativeMatrixPropertiesKHR {
    VkShaderStageFlags cooperative_matrix_supported_stages;
    
    VkPhysicalDeviceCooperativeMatrixPropertiesKHR raw() {
        return VkPhysicalDeviceCooperativeMatrixPropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR,
            .pNext = nullptr,
            .cooperativeMatrixSupportedStages = cooperative_matrix_supported_stages
        };
    }
};

struct PhysicalDeviceCooperativeMatrixPropertiesNV {
    VkShaderStageFlags cooperative_matrix_supported_stages;
    
    VkPhysicalDeviceCooperativeMatrixPropertiesNV raw() {
        return VkPhysicalDeviceCooperativeMatrixPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV,
            .pNext = nullptr,
            .cooperativeMatrixSupportedStages = cooperative_matrix_supported_stages
        };
    }
};

struct PhysicalDeviceCooperativeVectorFeaturesNV {
    bool cooperative_vector;
    bool cooperative_vector_training;
    
    VkPhysicalDeviceCooperativeVectorFeaturesNV raw() {
        return VkPhysicalDeviceCooperativeVectorFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV,
            .pNext = nullptr,
            .cooperativeVector = static_cast<VkBool32>(cooperative_vector),
            .cooperativeVectorTraining = static_cast<VkBool32>(cooperative_vector_training)
        };
    }
};

struct PhysicalDeviceCooperativeVectorPropertiesNV {
    VkShaderStageFlags cooperative_vector_supported_stages;
    bool cooperative_vector_training_float16accumulation;
    bool cooperative_vector_training_float32accumulation;
    u32 max_cooperative_vector_components;
    
    VkPhysicalDeviceCooperativeVectorPropertiesNV raw() {
        return VkPhysicalDeviceCooperativeVectorPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV,
            .pNext = nullptr,
            .cooperativeVectorSupportedStages = cooperative_vector_supported_stages,
            .cooperativeVectorTrainingFloat16Accumulation = static_cast<VkBool32>(cooperative_vector_training_float16accumulation),
            .cooperativeVectorTrainingFloat32Accumulation = static_cast<VkBool32>(cooperative_vector_training_float32accumulation),
            .maxCooperativeVectorComponents = max_cooperative_vector_components
        };
    }
};

struct PhysicalDeviceCopyMemoryIndirectFeaturesNV {
    bool indirect_copy;
    
    VkPhysicalDeviceCopyMemoryIndirectFeaturesNV raw() {
        return VkPhysicalDeviceCopyMemoryIndirectFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV,
            .pNext = nullptr,
            .indirectCopy = static_cast<VkBool32>(indirect_copy)
        };
    }
};

struct PhysicalDeviceCopyMemoryIndirectPropertiesNV {
    VkQueueFlags supported_queues;
    
    VkPhysicalDeviceCopyMemoryIndirectPropertiesNV raw() {
        return VkPhysicalDeviceCopyMemoryIndirectPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV,
            .pNext = nullptr,
            .supportedQueues = supported_queues
        };
    }
};

struct PhysicalDeviceCornerSampledImageFeaturesNV {
    bool corner_sampled_image;
    
    VkPhysicalDeviceCornerSampledImageFeaturesNV raw() {
        return VkPhysicalDeviceCornerSampledImageFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV,
            .pNext = nullptr,
            .cornerSampledImage = static_cast<VkBool32>(corner_sampled_image)
        };
    }
};

struct PhysicalDeviceCoverageReductionModeFeaturesNV {
    bool coverage_reduction_mode;
    
    VkPhysicalDeviceCoverageReductionModeFeaturesNV raw() {
        return VkPhysicalDeviceCoverageReductionModeFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV,
            .pNext = nullptr,
            .coverageReductionMode = static_cast<VkBool32>(coverage_reduction_mode)
        };
    }
};

struct PhysicalDeviceCubicClampFeaturesQCOM {
    bool cubic_range_clamp;
    
    VkPhysicalDeviceCubicClampFeaturesQCOM raw() {
        return VkPhysicalDeviceCubicClampFeaturesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM,
            .pNext = nullptr,
            .cubicRangeClamp = static_cast<VkBool32>(cubic_range_clamp)
        };
    }
};

struct PhysicalDeviceCubicWeightsFeaturesQCOM {
    bool selectable_cubic_weights;
    
    VkPhysicalDeviceCubicWeightsFeaturesQCOM raw() {
        return VkPhysicalDeviceCubicWeightsFeaturesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM,
            .pNext = nullptr,
            .selectableCubicWeights = static_cast<VkBool32>(selectable_cubic_weights)
        };
    }
};

struct PhysicalDeviceCudaKernelLaunchFeaturesNV {
    bool cuda_kernel_launch_features;
    
    VkPhysicalDeviceCudaKernelLaunchFeaturesNV raw() {
        return VkPhysicalDeviceCudaKernelLaunchFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV,
            .pNext = nullptr,
            .cudaKernelLaunchFeatures = static_cast<VkBool32>(cuda_kernel_launch_features)
        };
    }
};

struct PhysicalDeviceCudaKernelLaunchPropertiesNV {
    u32 compute_capability_minor;
    u32 compute_capability_major;
    
    VkPhysicalDeviceCudaKernelLaunchPropertiesNV raw() {
        return VkPhysicalDeviceCudaKernelLaunchPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV,
            .pNext = nullptr,
            .computeCapabilityMinor = compute_capability_minor,
            .computeCapabilityMajor = compute_capability_major
        };
    }
};

struct PhysicalDeviceCustomBorderColorFeaturesEXT {
    bool custom_border_colors;
    bool custom_border_color_without_format;
    
    VkPhysicalDeviceCustomBorderColorFeaturesEXT raw() {
        return VkPhysicalDeviceCustomBorderColorFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT,
            .pNext = nullptr,
            .customBorderColors = static_cast<VkBool32>(custom_border_colors),
            .customBorderColorWithoutFormat = static_cast<VkBool32>(custom_border_color_without_format)
        };
    }
};

struct PhysicalDeviceCustomBorderColorPropertiesEXT {
    u32 max_custom_border_color_samplers;
    
    VkPhysicalDeviceCustomBorderColorPropertiesEXT raw() {
        return VkPhysicalDeviceCustomBorderColorPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT,
            .pNext = nullptr,
            .maxCustomBorderColorSamplers = max_custom_border_color_samplers
        };
    }
};

struct PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
    bool dedicated_allocation_image_aliasing;
    
    VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV raw() {
        return VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV,
            .pNext = nullptr,
            .dedicatedAllocationImageAliasing = static_cast<VkBool32>(dedicated_allocation_image_aliasing)
        };
    }
};

struct PhysicalDeviceDepthBiasControlFeaturesEXT {
    bool depth_bias_control;
    bool least_representable_value_force_unorm_representation;
    bool float_representation;
    bool depth_bias_exact;
    
    VkPhysicalDeviceDepthBiasControlFeaturesEXT raw() {
        return VkPhysicalDeviceDepthBiasControlFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT,
            .pNext = nullptr,
            .depthBiasControl = static_cast<VkBool32>(depth_bias_control),
            .leastRepresentableValueForceUnormRepresentation = static_cast<VkBool32>(least_representable_value_force_unorm_representation),
            .floatRepresentation = static_cast<VkBool32>(float_representation),
            .depthBiasExact = static_cast<VkBool32>(depth_bias_exact)
        };
    }
};

struct PhysicalDeviceDepthClampControlFeaturesEXT {
    bool depth_clamp_control;
    
    VkPhysicalDeviceDepthClampControlFeaturesEXT raw() {
        return VkPhysicalDeviceDepthClampControlFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT,
            .pNext = nullptr,
            .depthClampControl = static_cast<VkBool32>(depth_clamp_control)
        };
    }
};

struct PhysicalDeviceDepthClampZeroOneFeaturesKHR {
    bool depth_clamp_zero_one;
    
    VkPhysicalDeviceDepthClampZeroOneFeaturesKHR raw() {
        return VkPhysicalDeviceDepthClampZeroOneFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR,
            .pNext = nullptr,
            .depthClampZeroOne = static_cast<VkBool32>(depth_clamp_zero_one)
        };
    }
};

struct PhysicalDeviceDepthClipControlFeaturesEXT {
    bool depth_clip_control;
    
    VkPhysicalDeviceDepthClipControlFeaturesEXT raw() {
        return VkPhysicalDeviceDepthClipControlFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT,
            .pNext = nullptr,
            .depthClipControl = static_cast<VkBool32>(depth_clip_control)
        };
    }
};

struct PhysicalDeviceDepthClipEnableFeaturesEXT {
    bool depth_clip_enable;
    
    VkPhysicalDeviceDepthClipEnableFeaturesEXT raw() {
        return VkPhysicalDeviceDepthClipEnableFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT,
            .pNext = nullptr,
            .depthClipEnable = static_cast<VkBool32>(depth_clip_enable)
        };
    }
};

struct PhysicalDeviceDepthStencilResolveProperties {
    VkResolveModeFlags supported_depth_resolve_modes;
    VkResolveModeFlags supported_stencil_resolve_modes;
    bool independent_resolve_none;
    bool independent_resolve;
    
    VkPhysicalDeviceDepthStencilResolveProperties raw() {
        return VkPhysicalDeviceDepthStencilResolveProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES,
            .pNext = nullptr,
            .supportedDepthResolveModes = supported_depth_resolve_modes,
            .supportedStencilResolveModes = supported_stencil_resolve_modes,
            .independentResolveNone = static_cast<VkBool32>(independent_resolve_none),
            .independentResolve = static_cast<VkBool32>(independent_resolve)
        };
    }
};

struct PhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
    size_t combined_image_sampler_density_map_descriptor_size;
    
    VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT raw() {
        return VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT,
            .pNext = nullptr,
            .combinedImageSamplerDensityMapDescriptorSize = combined_image_sampler_density_map_descriptor_size
        };
    }
};

struct PhysicalDeviceDescriptorBufferFeaturesEXT {
    bool descriptor_buffer;
    bool descriptor_buffer_capture_replay;
    bool descriptor_buffer_image_layout_ignored;
    bool descriptor_buffer_push_descriptors;
    
    VkPhysicalDeviceDescriptorBufferFeaturesEXT raw() {
        return VkPhysicalDeviceDescriptorBufferFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT,
            .pNext = nullptr,
            .descriptorBuffer = static_cast<VkBool32>(descriptor_buffer),
            .descriptorBufferCaptureReplay = static_cast<VkBool32>(descriptor_buffer_capture_replay),
            .descriptorBufferImageLayoutIgnored = static_cast<VkBool32>(descriptor_buffer_image_layout_ignored),
            .descriptorBufferPushDescriptors = static_cast<VkBool32>(descriptor_buffer_push_descriptors)
        };
    }
};

struct PhysicalDeviceDescriptorBufferPropertiesEXT {
    bool combined_image_sampler_descriptor_single_array;
    bool bufferless_push_descriptors;
    bool allow_sampler_image_view_post_submit_creation;
    VkDeviceSize descriptor_buffer_offset_alignment;
    u32 max_descriptor_buffer_bindings;
    u32 max_resource_descriptor_buffer_bindings;
    u32 max_sampler_descriptor_buffer_bindings;
    u32 max_embedded_immutable_sampler_bindings;
    u32 max_embedded_immutable_samplers;
    size_t buffer_capture_replay_descriptor_data_size;
    size_t image_capture_replay_descriptor_data_size;
    size_t image_view_capture_replay_descriptor_data_size;
    size_t sampler_capture_replay_descriptor_data_size;
    size_t acceleration_structure_capture_replay_descriptor_data_size;
    size_t sampler_descriptor_size;
    size_t combined_image_sampler_descriptor_size;
    size_t sampled_image_descriptor_size;
    size_t storage_image_descriptor_size;
    size_t uniform_texel_buffer_descriptor_size;
    size_t robust_uniform_texel_buffer_descriptor_size;
    size_t storage_texel_buffer_descriptor_size;
    size_t robust_storage_texel_buffer_descriptor_size;
    size_t uniform_buffer_descriptor_size;
    size_t robust_uniform_buffer_descriptor_size;
    size_t storage_buffer_descriptor_size;
    size_t robust_storage_buffer_descriptor_size;
    size_t input_attachment_descriptor_size;
    size_t acceleration_structure_descriptor_size;
    VkDeviceSize max_sampler_descriptor_buffer_range;
    VkDeviceSize max_resource_descriptor_buffer_range;
    VkDeviceSize sampler_descriptor_buffer_address_space_size;
    VkDeviceSize resource_descriptor_buffer_address_space_size;
    VkDeviceSize descriptor_buffer_address_space_size;
    
    VkPhysicalDeviceDescriptorBufferPropertiesEXT raw() {
        return VkPhysicalDeviceDescriptorBufferPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT,
            .pNext = nullptr,
            .combinedImageSamplerDescriptorSingleArray = static_cast<VkBool32>(combined_image_sampler_descriptor_single_array),
            .bufferlessPushDescriptors = static_cast<VkBool32>(bufferless_push_descriptors),
            .allowSamplerImageViewPostSubmitCreation = static_cast<VkBool32>(allow_sampler_image_view_post_submit_creation),
            .descriptorBufferOffsetAlignment = descriptor_buffer_offset_alignment,
            .maxDescriptorBufferBindings = max_descriptor_buffer_bindings,
            .maxResourceDescriptorBufferBindings = max_resource_descriptor_buffer_bindings,
            .maxSamplerDescriptorBufferBindings = max_sampler_descriptor_buffer_bindings,
            .maxEmbeddedImmutableSamplerBindings = max_embedded_immutable_sampler_bindings,
            .maxEmbeddedImmutableSamplers = max_embedded_immutable_samplers,
            .bufferCaptureReplayDescriptorDataSize = buffer_capture_replay_descriptor_data_size,
            .imageCaptureReplayDescriptorDataSize = image_capture_replay_descriptor_data_size,
            .imageViewCaptureReplayDescriptorDataSize = image_view_capture_replay_descriptor_data_size,
            .samplerCaptureReplayDescriptorDataSize = sampler_capture_replay_descriptor_data_size,
            .accelerationStructureCaptureReplayDescriptorDataSize = acceleration_structure_capture_replay_descriptor_data_size,
            .samplerDescriptorSize = sampler_descriptor_size,
            .combinedImageSamplerDescriptorSize = combined_image_sampler_descriptor_size,
            .sampledImageDescriptorSize = sampled_image_descriptor_size,
            .storageImageDescriptorSize = storage_image_descriptor_size,
            .uniformTexelBufferDescriptorSize = uniform_texel_buffer_descriptor_size,
            .robustUniformTexelBufferDescriptorSize = robust_uniform_texel_buffer_descriptor_size,
            .storageTexelBufferDescriptorSize = storage_texel_buffer_descriptor_size,
            .robustStorageTexelBufferDescriptorSize = robust_storage_texel_buffer_descriptor_size,
            .uniformBufferDescriptorSize = uniform_buffer_descriptor_size,
            .robustUniformBufferDescriptorSize = robust_uniform_buffer_descriptor_size,
            .storageBufferDescriptorSize = storage_buffer_descriptor_size,
            .robustStorageBufferDescriptorSize = robust_storage_buffer_descriptor_size,
            .inputAttachmentDescriptorSize = input_attachment_descriptor_size,
            .accelerationStructureDescriptorSize = acceleration_structure_descriptor_size,
            .maxSamplerDescriptorBufferRange = max_sampler_descriptor_buffer_range,
            .maxResourceDescriptorBufferRange = max_resource_descriptor_buffer_range,
            .samplerDescriptorBufferAddressSpaceSize = sampler_descriptor_buffer_address_space_size,
            .resourceDescriptorBufferAddressSpaceSize = resource_descriptor_buffer_address_space_size,
            .descriptorBufferAddressSpaceSize = descriptor_buffer_address_space_size
        };
    }
};

struct PhysicalDeviceDescriptorIndexingFeatures {
    bool shader_input_attachment_array_dynamic_indexing;
    bool shader_uniform_texel_buffer_array_dynamic_indexing;
    bool shader_storage_texel_buffer_array_dynamic_indexing;
    bool shader_uniform_buffer_array_non_uniform_indexing;
    bool shader_sampled_image_array_non_uniform_indexing;
    bool shader_storage_buffer_array_non_uniform_indexing;
    bool shader_storage_image_array_non_uniform_indexing;
    bool shader_input_attachment_array_non_uniform_indexing;
    bool shader_uniform_texel_buffer_array_non_uniform_indexing;
    bool shader_storage_texel_buffer_array_non_uniform_indexing;
    bool descriptor_binding_uniform_buffer_update_after_bind;
    bool descriptor_binding_sampled_image_update_after_bind;
    bool descriptor_binding_storage_image_update_after_bind;
    bool descriptor_binding_storage_buffer_update_after_bind;
    bool descriptor_binding_uniform_texel_buffer_update_after_bind;
    bool descriptor_binding_storage_texel_buffer_update_after_bind;
    bool descriptor_binding_update_unused_while_pending;
    bool descriptor_binding_partially_bound;
    bool descriptor_binding_variable_descriptor_count;
    bool runtime_descriptor_array;
    
    VkPhysicalDeviceDescriptorIndexingFeatures raw() {
        return VkPhysicalDeviceDescriptorIndexingFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES,
            .pNext = nullptr,
            .shaderInputAttachmentArrayDynamicIndexing = static_cast<VkBool32>(shader_input_attachment_array_dynamic_indexing),
            .shaderUniformTexelBufferArrayDynamicIndexing = static_cast<VkBool32>(shader_uniform_texel_buffer_array_dynamic_indexing),
            .shaderStorageTexelBufferArrayDynamicIndexing = static_cast<VkBool32>(shader_storage_texel_buffer_array_dynamic_indexing),
            .shaderUniformBufferArrayNonUniformIndexing = static_cast<VkBool32>(shader_uniform_buffer_array_non_uniform_indexing),
            .shaderSampledImageArrayNonUniformIndexing = static_cast<VkBool32>(shader_sampled_image_array_non_uniform_indexing),
            .shaderStorageBufferArrayNonUniformIndexing = static_cast<VkBool32>(shader_storage_buffer_array_non_uniform_indexing),
            .shaderStorageImageArrayNonUniformIndexing = static_cast<VkBool32>(shader_storage_image_array_non_uniform_indexing),
            .shaderInputAttachmentArrayNonUniformIndexing = static_cast<VkBool32>(shader_input_attachment_array_non_uniform_indexing),
            .shaderUniformTexelBufferArrayNonUniformIndexing = static_cast<VkBool32>(shader_uniform_texel_buffer_array_non_uniform_indexing),
            .shaderStorageTexelBufferArrayNonUniformIndexing = static_cast<VkBool32>(shader_storage_texel_buffer_array_non_uniform_indexing),
            .descriptorBindingUniformBufferUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_uniform_buffer_update_after_bind),
            .descriptorBindingSampledImageUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_sampled_image_update_after_bind),
            .descriptorBindingStorageImageUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_storage_image_update_after_bind),
            .descriptorBindingStorageBufferUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_storage_buffer_update_after_bind),
            .descriptorBindingUniformTexelBufferUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_uniform_texel_buffer_update_after_bind),
            .descriptorBindingStorageTexelBufferUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_storage_texel_buffer_update_after_bind),
            .descriptorBindingUpdateUnusedWhilePending = static_cast<VkBool32>(descriptor_binding_update_unused_while_pending),
            .descriptorBindingPartiallyBound = static_cast<VkBool32>(descriptor_binding_partially_bound),
            .descriptorBindingVariableDescriptorCount = static_cast<VkBool32>(descriptor_binding_variable_descriptor_count),
            .runtimeDescriptorArray = static_cast<VkBool32>(runtime_descriptor_array)
        };
    }
};

struct PhysicalDeviceDescriptorIndexingProperties {
    u32 max_update_after_bind_descriptors_in_all_pools;
    bool shader_uniform_buffer_array_non_uniform_indexing_native;
    bool shader_sampled_image_array_non_uniform_indexing_native;
    bool shader_storage_buffer_array_non_uniform_indexing_native;
    bool shader_storage_image_array_non_uniform_indexing_native;
    bool shader_input_attachment_array_non_uniform_indexing_native;
    bool robust_buffer_access_update_after_bind;
    bool quad_divergent_implicit_lod;
    u32 max_per_stage_descriptor_update_after_bind_samplers;
    u32 max_per_stage_descriptor_update_after_bind_uniform_buffers;
    u32 max_per_stage_descriptor_update_after_bind_storage_buffers;
    u32 max_per_stage_descriptor_update_after_bind_sampled_images;
    u32 max_per_stage_descriptor_update_after_bind_storage_images;
    u32 max_per_stage_descriptor_update_after_bind_input_attachments;
    u32 max_per_stage_update_after_bind_resources;
    u32 max_descriptor_set_update_after_bind_samplers;
    u32 max_descriptor_set_update_after_bind_uniform_buffers;
    u32 max_descriptor_set_update_after_bind_uniform_buffers_dynamic;
    u32 max_descriptor_set_update_after_bind_storage_buffers;
    u32 max_descriptor_set_update_after_bind_storage_buffers_dynamic;
    u32 max_descriptor_set_update_after_bind_sampled_images;
    u32 max_descriptor_set_update_after_bind_storage_images;
    u32 max_descriptor_set_update_after_bind_input_attachments;
    
    VkPhysicalDeviceDescriptorIndexingProperties raw() {
        return VkPhysicalDeviceDescriptorIndexingProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES,
            .pNext = nullptr,
            .maxUpdateAfterBindDescriptorsInAllPools = max_update_after_bind_descriptors_in_all_pools,
            .shaderUniformBufferArrayNonUniformIndexingNative = static_cast<VkBool32>(shader_uniform_buffer_array_non_uniform_indexing_native),
            .shaderSampledImageArrayNonUniformIndexingNative = static_cast<VkBool32>(shader_sampled_image_array_non_uniform_indexing_native),
            .shaderStorageBufferArrayNonUniformIndexingNative = static_cast<VkBool32>(shader_storage_buffer_array_non_uniform_indexing_native),
            .shaderStorageImageArrayNonUniformIndexingNative = static_cast<VkBool32>(shader_storage_image_array_non_uniform_indexing_native),
            .shaderInputAttachmentArrayNonUniformIndexingNative = static_cast<VkBool32>(shader_input_attachment_array_non_uniform_indexing_native),
            .robustBufferAccessUpdateAfterBind = static_cast<VkBool32>(robust_buffer_access_update_after_bind),
            .quadDivergentImplicitLod = static_cast<VkBool32>(quad_divergent_implicit_lod),
            .maxPerStageDescriptorUpdateAfterBindSamplers = max_per_stage_descriptor_update_after_bind_samplers,
            .maxPerStageDescriptorUpdateAfterBindUniformBuffers = max_per_stage_descriptor_update_after_bind_uniform_buffers,
            .maxPerStageDescriptorUpdateAfterBindStorageBuffers = max_per_stage_descriptor_update_after_bind_storage_buffers,
            .maxPerStageDescriptorUpdateAfterBindSampledImages = max_per_stage_descriptor_update_after_bind_sampled_images,
            .maxPerStageDescriptorUpdateAfterBindStorageImages = max_per_stage_descriptor_update_after_bind_storage_images,
            .maxPerStageDescriptorUpdateAfterBindInputAttachments = max_per_stage_descriptor_update_after_bind_input_attachments,
            .maxPerStageUpdateAfterBindResources = max_per_stage_update_after_bind_resources,
            .maxDescriptorSetUpdateAfterBindSamplers = max_descriptor_set_update_after_bind_samplers,
            .maxDescriptorSetUpdateAfterBindUniformBuffers = max_descriptor_set_update_after_bind_uniform_buffers,
            .maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = max_descriptor_set_update_after_bind_uniform_buffers_dynamic,
            .maxDescriptorSetUpdateAfterBindStorageBuffers = max_descriptor_set_update_after_bind_storage_buffers,
            .maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = max_descriptor_set_update_after_bind_storage_buffers_dynamic,
            .maxDescriptorSetUpdateAfterBindSampledImages = max_descriptor_set_update_after_bind_sampled_images,
            .maxDescriptorSetUpdateAfterBindStorageImages = max_descriptor_set_update_after_bind_storage_images,
            .maxDescriptorSetUpdateAfterBindInputAttachments = max_descriptor_set_update_after_bind_input_attachments
        };
    }
};

struct PhysicalDeviceDescriptorPoolOverallocationFeaturesNV {
    bool descriptor_pool_overallocation;
    
    VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV raw() {
        return VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV,
            .pNext = nullptr,
            .descriptorPoolOverallocation = static_cast<VkBool32>(descriptor_pool_overallocation)
        };
    }
};

struct PhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    bool descriptor_set_host_mapping;
    
    VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE raw() {
        return VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE,
            .pNext = nullptr,
            .descriptorSetHostMapping = static_cast<VkBool32>(descriptor_set_host_mapping)
        };
    }
};

struct PhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV {
    bool device_generated_compute;
    bool device_generated_compute_pipelines;
    bool device_generated_compute_capture_replay;
    
    VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV raw() {
        return VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV,
            .pNext = nullptr,
            .deviceGeneratedCompute = static_cast<VkBool32>(device_generated_compute),
            .deviceGeneratedComputePipelines = static_cast<VkBool32>(device_generated_compute_pipelines),
            .deviceGeneratedComputeCaptureReplay = static_cast<VkBool32>(device_generated_compute_capture_replay)
        };
    }
};

struct PhysicalDeviceDeviceGeneratedCommandsFeaturesEXT {
    bool device_generated_commands;
    bool dynamic_generated_pipeline_layout;
    
    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT raw() {
        return VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT,
            .pNext = nullptr,
            .deviceGeneratedCommands = static_cast<VkBool32>(device_generated_commands),
            .dynamicGeneratedPipelineLayout = static_cast<VkBool32>(dynamic_generated_pipeline_layout)
        };
    }
};

struct PhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
    bool device_generated_commands;
    
    VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV raw() {
        return VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV,
            .pNext = nullptr,
            .deviceGeneratedCommands = static_cast<VkBool32>(device_generated_commands)
        };
    }
};

struct PhysicalDeviceDeviceGeneratedCommandsPropertiesEXT {
    u32 max_indirect_pipeline_count;
    u32 max_indirect_shader_object_count;
    u32 max_indirect_sequence_count;
    u32 max_indirect_commands_token_count;
    u32 max_indirect_commands_token_offset;
    u32 max_indirect_commands_indirect_stride;
    VkIndirectCommandsInputModeFlagsEXT supported_indirect_commands_input_modes;
    VkShaderStageFlags supported_indirect_commands_shader_stages;
    VkShaderStageFlags supported_indirect_commands_shader_stages_pipeline_binding;
    VkShaderStageFlags supported_indirect_commands_shader_stages_shader_binding;
    bool device_generated_commands_transform_feedback;
    bool device_generated_commands_multi_draw_indirect_count;
    
    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT raw() {
        return VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT,
            .pNext = nullptr,
            .maxIndirectPipelineCount = max_indirect_pipeline_count,
            .maxIndirectShaderObjectCount = max_indirect_shader_object_count,
            .maxIndirectSequenceCount = max_indirect_sequence_count,
            .maxIndirectCommandsTokenCount = max_indirect_commands_token_count,
            .maxIndirectCommandsTokenOffset = max_indirect_commands_token_offset,
            .maxIndirectCommandsIndirectStride = max_indirect_commands_indirect_stride,
            .supportedIndirectCommandsInputModes = supported_indirect_commands_input_modes,
            .supportedIndirectCommandsShaderStages = supported_indirect_commands_shader_stages,
            .supportedIndirectCommandsShaderStagesPipelineBinding = supported_indirect_commands_shader_stages_pipeline_binding,
            .supportedIndirectCommandsShaderStagesShaderBinding = supported_indirect_commands_shader_stages_shader_binding,
            .deviceGeneratedCommandsTransformFeedback = static_cast<VkBool32>(device_generated_commands_transform_feedback),
            .deviceGeneratedCommandsMultiDrawIndirectCount = static_cast<VkBool32>(device_generated_commands_multi_draw_indirect_count)
        };
    }
};

struct PhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
    u32 max_graphics_shader_group_count;
    u32 max_indirect_sequence_count;
    u32 max_indirect_commands_token_count;
    u32 max_indirect_commands_stream_count;
    u32 max_indirect_commands_token_offset;
    u32 max_indirect_commands_stream_stride;
    u32 min_sequences_count_buffer_offset_alignment;
    u32 min_sequences_index_buffer_offset_alignment;
    u32 min_indirect_commands_buffer_offset_alignment;
    
    VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV raw() {
        return VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV,
            .pNext = nullptr,
            .maxGraphicsShaderGroupCount = max_graphics_shader_group_count,
            .maxIndirectSequenceCount = max_indirect_sequence_count,
            .maxIndirectCommandsTokenCount = max_indirect_commands_token_count,
            .maxIndirectCommandsStreamCount = max_indirect_commands_stream_count,
            .maxIndirectCommandsTokenOffset = max_indirect_commands_token_offset,
            .maxIndirectCommandsStreamStride = max_indirect_commands_stream_stride,
            .minSequencesCountBufferOffsetAlignment = min_sequences_count_buffer_offset_alignment,
            .minSequencesIndexBufferOffsetAlignment = min_sequences_index_buffer_offset_alignment,
            .minIndirectCommandsBufferOffsetAlignment = min_indirect_commands_buffer_offset_alignment
        };
    }
};

struct PhysicalDeviceDeviceMemoryReportFeaturesEXT {
    bool device_memory_report;
    
    VkPhysicalDeviceDeviceMemoryReportFeaturesEXT raw() {
        return VkPhysicalDeviceDeviceMemoryReportFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT,
            .pNext = nullptr,
            .deviceMemoryReport = static_cast<VkBool32>(device_memory_report)
        };
    }
};

struct PhysicalDeviceDiagnosticsConfigFeaturesNV {
    bool diagnostics_config;
    
    VkPhysicalDeviceDiagnosticsConfigFeaturesNV raw() {
        return VkPhysicalDeviceDiagnosticsConfigFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV,
            .pNext = nullptr,
            .diagnosticsConfig = static_cast<VkBool32>(diagnostics_config)
        };
    }
};

struct PhysicalDeviceDiscardRectanglePropertiesEXT {
    u32 max_discard_rectangles;
    
    VkPhysicalDeviceDiscardRectanglePropertiesEXT raw() {
        return VkPhysicalDeviceDiscardRectanglePropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT,
            .pNext = nullptr,
            .maxDiscardRectangles = max_discard_rectangles
        };
    }
};

struct PhysicalDeviceDriverProperties {
    DriverId driver_id;
    char[] vk_max_driver_name_size;
    char[] vk_max_driver_info_size;
    ConformanceVersion conformance_version;
    
    VkPhysicalDeviceDriverProperties raw() {
        return VkPhysicalDeviceDriverProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES,
            .pNext = nullptr,
            .driverID = static_cast<VkDriverId>(driver_id),
            .VK_MAX_DRIVER_NAME_SIZE = vk_max_driver_name_size,
            .VK_MAX_DRIVER_INFO_SIZE = vk_max_driver_info_size,
            .conformanceVersion = conformance_version.raw()
        };
    }
};

struct PhysicalDeviceDrmPropertiesEXT {
    bool has_primary;
    bool has_render;
    int64_t primary_major;
    int64_t primary_minor;
    int64_t render_major;
    int64_t render_minor;
    
    VkPhysicalDeviceDrmPropertiesEXT raw() {
        return VkPhysicalDeviceDrmPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT,
            .pNext = nullptr,
            .hasPrimary = static_cast<VkBool32>(has_primary),
            .hasRender = static_cast<VkBool32>(has_render),
            .primaryMajor = primary_major,
            .primaryMinor = primary_minor,
            .renderMajor = render_major,
            .renderMinor = render_minor
        };
    }
};

struct PhysicalDeviceDynamicRenderingFeatures {
    bool dynamic_rendering;
    
    VkPhysicalDeviceDynamicRenderingFeatures raw() {
        return VkPhysicalDeviceDynamicRenderingFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES,
            .pNext = nullptr,
            .dynamicRendering = static_cast<VkBool32>(dynamic_rendering)
        };
    }
};

struct PhysicalDeviceDynamicRenderingLocalReadFeatures {
    bool dynamic_rendering_local_read;
    
    VkPhysicalDeviceDynamicRenderingLocalReadFeatures raw() {
        return VkPhysicalDeviceDynamicRenderingLocalReadFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES,
            .pNext = nullptr,
            .dynamicRenderingLocalRead = static_cast<VkBool32>(dynamic_rendering_local_read)
        };
    }
};

struct PhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
    bool dynamic_rendering_unused_attachments;
    
    VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT raw() {
        return VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT,
            .pNext = nullptr,
            .dynamicRenderingUnusedAttachments = static_cast<VkBool32>(dynamic_rendering_unused_attachments)
        };
    }
};

struct PhysicalDeviceExclusiveScissorFeaturesNV {
    bool exclusive_scissor;
    
    VkPhysicalDeviceExclusiveScissorFeaturesNV raw() {
        return VkPhysicalDeviceExclusiveScissorFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV,
            .pNext = nullptr,
            .exclusiveScissor = static_cast<VkBool32>(exclusive_scissor)
        };
    }
};

struct PhysicalDeviceExtendedDynamicState2FeaturesEXT {
    bool extended_dynamic_state2;
    bool extended_dynamic_state2logic_op;
    bool extended_dynamic_state2patch_control_points;
    
    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT raw() {
        return VkPhysicalDeviceExtendedDynamicState2FeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE2FEATURES_EXT,
            .pNext = nullptr,
            .extendedDynamicState2 = static_cast<VkBool32>(extended_dynamic_state2),
            .extendedDynamicState2LogicOp = static_cast<VkBool32>(extended_dynamic_state2logic_op),
            .extendedDynamicState2PatchControlPoints = static_cast<VkBool32>(extended_dynamic_state2patch_control_points)
        };
    }
};

struct PhysicalDeviceExtendedDynamicState3FeaturesEXT {
    bool extended_dynamic_state3tessellation_domain_origin;
    bool extended_dynamic_state3depth_clamp_enable;
    bool extended_dynamic_state3polygon_mode;
    bool extended_dynamic_state3rasterization_samples;
    bool extended_dynamic_state3sample_mask;
    bool extended_dynamic_state3alpha_to_coverage_enable;
    bool extended_dynamic_state3alpha_to_one_enable;
    bool extended_dynamic_state3logic_op_enable;
    bool extended_dynamic_state3color_blend_enable;
    bool extended_dynamic_state3color_blend_equation;
    bool extended_dynamic_state3color_write_mask;
    bool extended_dynamic_state3rasterization_stream;
    bool extended_dynamic_state3conservative_rasterization_mode;
    bool extended_dynamic_state3extra_primitive_overestimation_size;
    bool extended_dynamic_state3depth_clip_enable;
    bool extended_dynamic_state3sample_locations_enable;
    bool extended_dynamic_state3color_blend_advanced;
    bool extended_dynamic_state3provoking_vertex_mode;
    bool extended_dynamic_state3line_rasterization_mode;
    bool extended_dynamic_state3line_stipple_enable;
    bool extended_dynamic_state3depth_clip_negative_one_to_one;
    bool extended_dynamic_state3viewport_wscaling_enable;
    bool extended_dynamic_state3viewport_swizzle;
    bool extended_dynamic_state3coverage_to_color_enable;
    bool extended_dynamic_state3coverage_to_color_location;
    bool extended_dynamic_state3coverage_modulation_mode;
    bool extended_dynamic_state3coverage_modulation_table_enable;
    bool extended_dynamic_state3coverage_modulation_table;
    bool extended_dynamic_state3coverage_reduction_mode;
    bool extended_dynamic_state3representative_fragment_test_enable;
    bool extended_dynamic_state3shading_rate_image_enable;
    
    VkPhysicalDeviceExtendedDynamicState3FeaturesEXT raw() {
        return VkPhysicalDeviceExtendedDynamicState3FeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE3FEATURES_EXT,
            .pNext = nullptr,
            .extendedDynamicState3TessellationDomainOrigin = static_cast<VkBool32>(extended_dynamic_state3tessellation_domain_origin),
            .extendedDynamicState3DepthClampEnable = static_cast<VkBool32>(extended_dynamic_state3depth_clamp_enable),
            .extendedDynamicState3PolygonMode = static_cast<VkBool32>(extended_dynamic_state3polygon_mode),
            .extendedDynamicState3RasterizationSamples = static_cast<VkBool32>(extended_dynamic_state3rasterization_samples),
            .extendedDynamicState3SampleMask = static_cast<VkBool32>(extended_dynamic_state3sample_mask),
            .extendedDynamicState3AlphaToCoverageEnable = static_cast<VkBool32>(extended_dynamic_state3alpha_to_coverage_enable),
            .extendedDynamicState3AlphaToOneEnable = static_cast<VkBool32>(extended_dynamic_state3alpha_to_one_enable),
            .extendedDynamicState3LogicOpEnable = static_cast<VkBool32>(extended_dynamic_state3logic_op_enable),
            .extendedDynamicState3ColorBlendEnable = static_cast<VkBool32>(extended_dynamic_state3color_blend_enable),
            .extendedDynamicState3ColorBlendEquation = static_cast<VkBool32>(extended_dynamic_state3color_blend_equation),
            .extendedDynamicState3ColorWriteMask = static_cast<VkBool32>(extended_dynamic_state3color_write_mask),
            .extendedDynamicState3RasterizationStream = static_cast<VkBool32>(extended_dynamic_state3rasterization_stream),
            .extendedDynamicState3ConservativeRasterizationMode = static_cast<VkBool32>(extended_dynamic_state3conservative_rasterization_mode),
            .extendedDynamicState3ExtraPrimitiveOverestimationSize = static_cast<VkBool32>(extended_dynamic_state3extra_primitive_overestimation_size),
            .extendedDynamicState3DepthClipEnable = static_cast<VkBool32>(extended_dynamic_state3depth_clip_enable),
            .extendedDynamicState3SampleLocationsEnable = static_cast<VkBool32>(extended_dynamic_state3sample_locations_enable),
            .extendedDynamicState3ColorBlendAdvanced = static_cast<VkBool32>(extended_dynamic_state3color_blend_advanced),
            .extendedDynamicState3ProvokingVertexMode = static_cast<VkBool32>(extended_dynamic_state3provoking_vertex_mode),
            .extendedDynamicState3LineRasterizationMode = static_cast<VkBool32>(extended_dynamic_state3line_rasterization_mode),
            .extendedDynamicState3LineStippleEnable = static_cast<VkBool32>(extended_dynamic_state3line_stipple_enable),
            .extendedDynamicState3DepthClipNegativeOneToOne = static_cast<VkBool32>(extended_dynamic_state3depth_clip_negative_one_to_one),
            .extendedDynamicState3ViewportWScalingEnable = static_cast<VkBool32>(extended_dynamic_state3viewport_wscaling_enable),
            .extendedDynamicState3ViewportSwizzle = static_cast<VkBool32>(extended_dynamic_state3viewport_swizzle),
            .extendedDynamicState3CoverageToColorEnable = static_cast<VkBool32>(extended_dynamic_state3coverage_to_color_enable),
            .extendedDynamicState3CoverageToColorLocation = static_cast<VkBool32>(extended_dynamic_state3coverage_to_color_location),
            .extendedDynamicState3CoverageModulationMode = static_cast<VkBool32>(extended_dynamic_state3coverage_modulation_mode),
            .extendedDynamicState3CoverageModulationTableEnable = static_cast<VkBool32>(extended_dynamic_state3coverage_modulation_table_enable),
            .extendedDynamicState3CoverageModulationTable = static_cast<VkBool32>(extended_dynamic_state3coverage_modulation_table),
            .extendedDynamicState3CoverageReductionMode = static_cast<VkBool32>(extended_dynamic_state3coverage_reduction_mode),
            .extendedDynamicState3RepresentativeFragmentTestEnable = static_cast<VkBool32>(extended_dynamic_state3representative_fragment_test_enable),
            .extendedDynamicState3ShadingRateImageEnable = static_cast<VkBool32>(extended_dynamic_state3shading_rate_image_enable)
        };
    }
};

struct PhysicalDeviceExtendedDynamicState3PropertiesEXT {
    bool dynamic_primitive_topology_unrestricted;
    
    VkPhysicalDeviceExtendedDynamicState3PropertiesEXT raw() {
        return VkPhysicalDeviceExtendedDynamicState3PropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE3PROPERTIES_EXT,
            .pNext = nullptr,
            .dynamicPrimitiveTopologyUnrestricted = static_cast<VkBool32>(dynamic_primitive_topology_unrestricted)
        };
    }
};

struct PhysicalDeviceExtendedDynamicStateFeaturesEXT {
    bool extended_dynamic_state;
    
    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT raw() {
        return VkPhysicalDeviceExtendedDynamicStateFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT,
            .pNext = nullptr,
            .extendedDynamicState = static_cast<VkBool32>(extended_dynamic_state)
        };
    }
};

struct PhysicalDeviceExtendedSparseAddressSpaceFeaturesNV {
    bool extended_sparse_address_space;
    
    VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV raw() {
        return VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV,
            .pNext = nullptr,
            .extendedSparseAddressSpace = static_cast<VkBool32>(extended_sparse_address_space)
        };
    }
};

struct PhysicalDeviceExtendedSparseAddressSpacePropertiesNV {
    VkDeviceSize extended_sparse_address_space_size;
    VkImageUsageFlags extended_sparse_image_usage_flags;
    VkBufferUsageFlags extended_sparse_buffer_usage_flags;
    
    VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV raw() {
        return VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV,
            .pNext = nullptr,
            .extendedSparseAddressSpaceSize = extended_sparse_address_space_size,
            .extendedSparseImageUsageFlags = extended_sparse_image_usage_flags,
            .extendedSparseBufferUsageFlags = extended_sparse_buffer_usage_flags
        };
    }
};

struct PhysicalDeviceExternalBufferInfo {
    VkBufferCreateFlags flags;
    VkBufferUsageFlags usage;
    ExternalMemoryHandleTypeFlags handle_type;
    
    VkPhysicalDeviceExternalBufferInfo raw() {
        return VkPhysicalDeviceExternalBufferInfo {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
            .pNext = nullptr,
            .flags = flags,
            .usage = usage,
            .handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(handle_type)
        };
    }
};

struct PhysicalDeviceExternalComputeQueuePropertiesNV {
    u32 external_data_size;
    u32 max_external_queues;
    
    VkPhysicalDeviceExternalComputeQueuePropertiesNV raw() {
        return VkPhysicalDeviceExternalComputeQueuePropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV,
            .pNext = nullptr,
            .externalDataSize = external_data_size,
            .maxExternalQueues = max_external_queues
        };
    }
};

struct PhysicalDeviceExternalFenceInfo {
    ExternalFenceHandleTypeFlags handle_type;
    
    VkPhysicalDeviceExternalFenceInfo raw() {
        return VkPhysicalDeviceExternalFenceInfo {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
            .pNext = nullptr,
            .handleType = static_cast<VkExternalFenceHandleTypeFlagBits>(handle_type)
        };
    }
};

struct PhysicalDeviceExternalImageFormatInfo {
    ExternalMemoryHandleTypeFlags handle_type;
    
    VkPhysicalDeviceExternalImageFormatInfo raw() {
        return VkPhysicalDeviceExternalImageFormatInfo {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
            .pNext = nullptr,
            .handleType = static_cast<VkExternalMemoryHandleTypeFlagBits>(handle_type)
        };
    }
};

struct PhysicalDeviceExternalMemoryHostPropertiesEXT {
    VkDeviceSize min_imported_host_pointer_alignment;
    
    VkPhysicalDeviceExternalMemoryHostPropertiesEXT raw() {
        return VkPhysicalDeviceExternalMemoryHostPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT,
            .pNext = nullptr,
            .minImportedHostPointerAlignment = min_imported_host_pointer_alignment
        };
    }
};

struct PhysicalDeviceExternalMemoryRDMAFeaturesNV {
    bool external_memory_rdma;
    
    VkPhysicalDeviceExternalMemoryRDMAFeaturesNV raw() {
        return VkPhysicalDeviceExternalMemoryRDMAFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMAFEATURES_NV,
            .pNext = nullptr,
            .externalMemoryRDMA = static_cast<VkBool32>(external_memory_rdma)
        };
    }
};

struct PhysicalDeviceExternalSemaphoreInfo {
    ExternalSemaphoreHandleTypeFlags handle_type;
    
    VkPhysicalDeviceExternalSemaphoreInfo raw() {
        return VkPhysicalDeviceExternalSemaphoreInfo {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
            .pNext = nullptr,
            .handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(handle_type)
        };
    }
};

struct PhysicalDeviceFaultFeaturesEXT {
    bool device_fault;
    bool device_fault_vendor_binary;
    
    VkPhysicalDeviceFaultFeaturesEXT raw() {
        return VkPhysicalDeviceFaultFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT,
            .pNext = nullptr,
            .deviceFault = static_cast<VkBool32>(device_fault),
            .deviceFaultVendorBinary = static_cast<VkBool32>(device_fault_vendor_binary)
        };
    }
};

struct PhysicalDeviceFeatures {
    bool robust_buffer_access;
    bool full_draw_index_uint32;
    bool image_cube_array;
    bool independent_blend;
    bool geometry_shader;
    bool tessellation_shader;
    bool sample_rate_shading;
    bool dual_src_blend;
    bool logic_op;
    bool multi_draw_indirect;
    bool draw_indirect_first_instance;
    bool depth_clamp;
    bool depth_bias_clamp;
    bool fill_mode_non_solid;
    bool depth_bounds;
    bool wide_lines;
    bool large_points;
    bool alpha_to_one;
    bool multi_viewport;
    bool sampler_anisotropy;
    bool texture_compression_etc2;
    bool texture_compression_astc_ldr;
    bool texture_compression_bc;
    bool occlusion_query_precise;
    bool pipeline_statistics_query;
    bool vertex_pipeline_stores_and_atomics;
    bool fragment_stores_and_atomics;
    bool shader_tessellation_and_geometry_point_size;
    bool shader_image_gather_extended;
    bool shader_storage_image_extended_formats;
    bool shader_storage_image_multisample;
    bool shader_storage_image_read_without_format;
    bool shader_storage_image_write_without_format;
    bool shader_uniform_buffer_array_dynamic_indexing;
    bool shader_sampled_image_array_dynamic_indexing;
    bool shader_storage_buffer_array_dynamic_indexing;
    bool shader_storage_image_array_dynamic_indexing;
    bool shader_clip_distance;
    bool shader_cull_distance;
    bool shader_float64;
    bool shader_int64;
    bool shader_int16;
    bool shader_resource_residency;
    bool shader_resource_min_lod;
    bool sparse_binding;
    bool sparse_residency_buffer;
    bool sparse_residency_image2d;
    bool sparse_residency_image3d;
    bool sparse_residency2samples;
    bool sparse_residency4samples;
    bool sparse_residency8samples;
    bool sparse_residency16samples;
    bool sparse_residency_aliased;
    bool variable_multisample_rate;
    bool inherited_queries;
    
    VkPhysicalDeviceFeatures raw() {
        return VkPhysicalDeviceFeatures {
            .robustBufferAccess = static_cast<VkBool32>(robust_buffer_access),
            .fullDrawIndexUint32 = static_cast<VkBool32>(full_draw_index_uint32),
            .imageCubeArray = static_cast<VkBool32>(image_cube_array),
            .independentBlend = static_cast<VkBool32>(independent_blend),
            .geometryShader = static_cast<VkBool32>(geometry_shader),
            .tessellationShader = static_cast<VkBool32>(tessellation_shader),
            .sampleRateShading = static_cast<VkBool32>(sample_rate_shading),
            .dualSrcBlend = static_cast<VkBool32>(dual_src_blend),
            .logicOp = static_cast<VkBool32>(logic_op),
            .multiDrawIndirect = static_cast<VkBool32>(multi_draw_indirect),
            .drawIndirectFirstInstance = static_cast<VkBool32>(draw_indirect_first_instance),
            .depthClamp = static_cast<VkBool32>(depth_clamp),
            .depthBiasClamp = static_cast<VkBool32>(depth_bias_clamp),
            .fillModeNonSolid = static_cast<VkBool32>(fill_mode_non_solid),
            .depthBounds = static_cast<VkBool32>(depth_bounds),
            .wideLines = static_cast<VkBool32>(wide_lines),
            .largePoints = static_cast<VkBool32>(large_points),
            .alphaToOne = static_cast<VkBool32>(alpha_to_one),
            .multiViewport = static_cast<VkBool32>(multi_viewport),
            .samplerAnisotropy = static_cast<VkBool32>(sampler_anisotropy),
            .textureCompressionETC2 = static_cast<VkBool32>(texture_compression_etc2),
            .textureCompressionASTC_LDR = static_cast<VkBool32>(texture_compression_astc_ldr),
            .textureCompressionBC = static_cast<VkBool32>(texture_compression_bc),
            .occlusionQueryPrecise = static_cast<VkBool32>(occlusion_query_precise),
            .pipelineStatisticsQuery = static_cast<VkBool32>(pipeline_statistics_query),
            .vertexPipelineStoresAndAtomics = static_cast<VkBool32>(vertex_pipeline_stores_and_atomics),
            .fragmentStoresAndAtomics = static_cast<VkBool32>(fragment_stores_and_atomics),
            .shaderTessellationAndGeometryPointSize = static_cast<VkBool32>(shader_tessellation_and_geometry_point_size),
            .shaderImageGatherExtended = static_cast<VkBool32>(shader_image_gather_extended),
            .shaderStorageImageExtendedFormats = static_cast<VkBool32>(shader_storage_image_extended_formats),
            .shaderStorageImageMultisample = static_cast<VkBool32>(shader_storage_image_multisample),
            .shaderStorageImageReadWithoutFormat = static_cast<VkBool32>(shader_storage_image_read_without_format),
            .shaderStorageImageWriteWithoutFormat = static_cast<VkBool32>(shader_storage_image_write_without_format),
            .shaderUniformBufferArrayDynamicIndexing = static_cast<VkBool32>(shader_uniform_buffer_array_dynamic_indexing),
            .shaderSampledImageArrayDynamicIndexing = static_cast<VkBool32>(shader_sampled_image_array_dynamic_indexing),
            .shaderStorageBufferArrayDynamicIndexing = static_cast<VkBool32>(shader_storage_buffer_array_dynamic_indexing),
            .shaderStorageImageArrayDynamicIndexing = static_cast<VkBool32>(shader_storage_image_array_dynamic_indexing),
            .shaderClipDistance = static_cast<VkBool32>(shader_clip_distance),
            .shaderCullDistance = static_cast<VkBool32>(shader_cull_distance),
            .shaderFloat64 = static_cast<VkBool32>(shader_float64),
            .shaderInt64 = static_cast<VkBool32>(shader_int64),
            .shaderInt16 = static_cast<VkBool32>(shader_int16),
            .shaderResourceResidency = static_cast<VkBool32>(shader_resource_residency),
            .shaderResourceMinLod = static_cast<VkBool32>(shader_resource_min_lod),
            .sparseBinding = static_cast<VkBool32>(sparse_binding),
            .sparseResidencyBuffer = static_cast<VkBool32>(sparse_residency_buffer),
            .sparseResidencyImage2D = static_cast<VkBool32>(sparse_residency_image2d),
            .sparseResidencyImage3D = static_cast<VkBool32>(sparse_residency_image3d),
            .sparseResidency2Samples = static_cast<VkBool32>(sparse_residency2samples),
            .sparseResidency4Samples = static_cast<VkBool32>(sparse_residency4samples),
            .sparseResidency8Samples = static_cast<VkBool32>(sparse_residency8samples),
            .sparseResidency16Samples = static_cast<VkBool32>(sparse_residency16samples),
            .sparseResidencyAliased = static_cast<VkBool32>(sparse_residency_aliased),
            .variableMultisampleRate = static_cast<VkBool32>(variable_multisample_rate),
            .inheritedQueries = static_cast<VkBool32>(inherited_queries)
        };
    }
};

struct PhysicalDeviceFeatures2 {
    PhysicalDeviceFeatures features;
    
    VkPhysicalDeviceFeatures2 raw() {
        return VkPhysicalDeviceFeatures2 {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FEATURES2,
            .pNext = nullptr,
            .features = features.raw()
        };
    }
};

struct PhysicalDeviceFloatControlsProperties {
    ShaderFloatControlsIndependence denorm_behavior_independence;
    ShaderFloatControlsIndependence rounding_mode_independence;
    bool shader_signed_zero_inf_nan_preserve_float16;
    bool shader_signed_zero_inf_nan_preserve_float32;
    bool shader_signed_zero_inf_nan_preserve_float64;
    bool shader_denorm_preserve_float16;
    bool shader_denorm_preserve_float32;
    bool shader_denorm_preserve_float64;
    bool shader_denorm_flush_to_zero_float16;
    bool shader_denorm_flush_to_zero_float32;
    bool shader_denorm_flush_to_zero_float64;
    bool shader_rounding_mode_rtefloat16;
    bool shader_rounding_mode_rtefloat32;
    bool shader_rounding_mode_rtefloat64;
    bool shader_rounding_mode_rtzfloat16;
    bool shader_rounding_mode_rtzfloat32;
    bool shader_rounding_mode_rtzfloat64;
    
    VkPhysicalDeviceFloatControlsProperties raw() {
        return VkPhysicalDeviceFloatControlsProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES,
            .pNext = nullptr,
            .denormBehaviorIndependence = static_cast<VkShaderFloatControlsIndependence>(denorm_behavior_independence),
            .roundingModeIndependence = static_cast<VkShaderFloatControlsIndependence>(rounding_mode_independence),
            .shaderSignedZeroInfNanPreserveFloat16 = static_cast<VkBool32>(shader_signed_zero_inf_nan_preserve_float16),
            .shaderSignedZeroInfNanPreserveFloat32 = static_cast<VkBool32>(shader_signed_zero_inf_nan_preserve_float32),
            .shaderSignedZeroInfNanPreserveFloat64 = static_cast<VkBool32>(shader_signed_zero_inf_nan_preserve_float64),
            .shaderDenormPreserveFloat16 = static_cast<VkBool32>(shader_denorm_preserve_float16),
            .shaderDenormPreserveFloat32 = static_cast<VkBool32>(shader_denorm_preserve_float32),
            .shaderDenormPreserveFloat64 = static_cast<VkBool32>(shader_denorm_preserve_float64),
            .shaderDenormFlushToZeroFloat16 = static_cast<VkBool32>(shader_denorm_flush_to_zero_float16),
            .shaderDenormFlushToZeroFloat32 = static_cast<VkBool32>(shader_denorm_flush_to_zero_float32),
            .shaderDenormFlushToZeroFloat64 = static_cast<VkBool32>(shader_denorm_flush_to_zero_float64),
            .shaderRoundingModeRTEFloat16 = static_cast<VkBool32>(shader_rounding_mode_rtefloat16),
            .shaderRoundingModeRTEFloat32 = static_cast<VkBool32>(shader_rounding_mode_rtefloat32),
            .shaderRoundingModeRTEFloat64 = static_cast<VkBool32>(shader_rounding_mode_rtefloat64),
            .shaderRoundingModeRTZFloat16 = static_cast<VkBool32>(shader_rounding_mode_rtzfloat16),
            .shaderRoundingModeRTZFloat32 = static_cast<VkBool32>(shader_rounding_mode_rtzfloat32),
            .shaderRoundingModeRTZFloat64 = static_cast<VkBool32>(shader_rounding_mode_rtzfloat64)
        };
    }
};

struct PhysicalDeviceFragmentDensityMap2FeaturesEXT {
    bool fragment_density_map_deferred;
    
    VkPhysicalDeviceFragmentDensityMap2FeaturesEXT raw() {
        return VkPhysicalDeviceFragmentDensityMap2FeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP2FEATURES_EXT,
            .pNext = nullptr,
            .fragmentDensityMapDeferred = static_cast<VkBool32>(fragment_density_map_deferred)
        };
    }
};

struct PhysicalDeviceFragmentDensityMap2PropertiesEXT {
    bool subsampled_loads;
    bool subsampled_coarse_reconstruction_early_access;
    u32 max_subsampled_array_layers;
    u32 max_descriptor_set_subsampled_samplers;
    
    VkPhysicalDeviceFragmentDensityMap2PropertiesEXT raw() {
        return VkPhysicalDeviceFragmentDensityMap2PropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP2PROPERTIES_EXT,
            .pNext = nullptr,
            .subsampledLoads = static_cast<VkBool32>(subsampled_loads),
            .subsampledCoarseReconstructionEarlyAccess = static_cast<VkBool32>(subsampled_coarse_reconstruction_early_access),
            .maxSubsampledArrayLayers = max_subsampled_array_layers,
            .maxDescriptorSetSubsampledSamplers = max_descriptor_set_subsampled_samplers
        };
    }
};

struct PhysicalDeviceFragmentDensityMapFeaturesEXT {
    bool fragment_density_map;
    bool fragment_density_map_dynamic;
    bool fragment_density_map_non_subsampled_images;
    
    VkPhysicalDeviceFragmentDensityMapFeaturesEXT raw() {
        return VkPhysicalDeviceFragmentDensityMapFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT,
            .pNext = nullptr,
            .fragmentDensityMap = static_cast<VkBool32>(fragment_density_map),
            .fragmentDensityMapDynamic = static_cast<VkBool32>(fragment_density_map_dynamic),
            .fragmentDensityMapNonSubsampledImages = static_cast<VkBool32>(fragment_density_map_non_subsampled_images)
        };
    }
};

struct PhysicalDeviceFragmentDensityMapOffsetFeaturesEXT {
    bool fragment_density_map_offset;
    
    VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT raw() {
        return VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT,
            .pNext = nullptr,
            .fragmentDensityMapOffset = static_cast<VkBool32>(fragment_density_map_offset)
        };
    }
};

struct PhysicalDeviceFragmentDensityMapOffsetPropertiesEXT {
    Extent2D fragment_density_offset_granularity;
    
    VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT raw() {
        return VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT,
            .pNext = nullptr,
            .fragmentDensityOffsetGranularity = fragment_density_offset_granularity.raw()
        };
    }
};

struct PhysicalDeviceFragmentDensityMapPropertiesEXT {
    Extent2D min_fragment_density_texel_size;
    Extent2D max_fragment_density_texel_size;
    bool fragment_density_invocations;
    
    VkPhysicalDeviceFragmentDensityMapPropertiesEXT raw() {
        return VkPhysicalDeviceFragmentDensityMapPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT,
            .pNext = nullptr,
            .minFragmentDensityTexelSize = min_fragment_density_texel_size.raw(),
            .maxFragmentDensityTexelSize = max_fragment_density_texel_size.raw(),
            .fragmentDensityInvocations = static_cast<VkBool32>(fragment_density_invocations)
        };
    }
};

struct PhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
    bool fragment_shader_barycentric;
    
    VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR raw() {
        return VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR,
            .pNext = nullptr,
            .fragmentShaderBarycentric = static_cast<VkBool32>(fragment_shader_barycentric)
        };
    }
};

struct PhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
    bool tri_strip_vertex_order_independent_of_provoking_vertex;
    
    VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR raw() {
        return VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR,
            .pNext = nullptr,
            .triStripVertexOrderIndependentOfProvokingVertex = static_cast<VkBool32>(tri_strip_vertex_order_independent_of_provoking_vertex)
        };
    }
};

struct PhysicalDeviceFragmentShaderInterlockFeaturesEXT {
    bool fragment_shader_sample_interlock;
    bool fragment_shader_pixel_interlock;
    bool fragment_shader_shading_rate_interlock;
    
    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT raw() {
        return VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT,
            .pNext = nullptr,
            .fragmentShaderSampleInterlock = static_cast<VkBool32>(fragment_shader_sample_interlock),
            .fragmentShaderPixelInterlock = static_cast<VkBool32>(fragment_shader_pixel_interlock),
            .fragmentShaderShadingRateInterlock = static_cast<VkBool32>(fragment_shader_shading_rate_interlock)
        };
    }
};

struct PhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
    bool fragment_shading_rate_enums;
    bool supersample_fragment_shading_rates;
    bool no_invocation_fragment_shading_rates;
    
    VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV raw() {
        return VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV,
            .pNext = nullptr,
            .fragmentShadingRateEnums = static_cast<VkBool32>(fragment_shading_rate_enums),
            .supersampleFragmentShadingRates = static_cast<VkBool32>(supersample_fragment_shading_rates),
            .noInvocationFragmentShadingRates = static_cast<VkBool32>(no_invocation_fragment_shading_rates)
        };
    }
};

struct PhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
    SampleCountFlags max_fragment_shading_rate_invocation_count;
    
    VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV raw() {
        return VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV,
            .pNext = nullptr,
            .maxFragmentShadingRateInvocationCount = static_cast<VkSampleCountFlagBits>(max_fragment_shading_rate_invocation_count)
        };
    }
};

struct PhysicalDeviceFragmentShadingRateFeaturesKHR {
    bool pipeline_fragment_shading_rate;
    bool primitive_fragment_shading_rate;
    bool attachment_fragment_shading_rate;
    
    VkPhysicalDeviceFragmentShadingRateFeaturesKHR raw() {
        return VkPhysicalDeviceFragmentShadingRateFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR,
            .pNext = nullptr,
            .pipelineFragmentShadingRate = static_cast<VkBool32>(pipeline_fragment_shading_rate),
            .primitiveFragmentShadingRate = static_cast<VkBool32>(primitive_fragment_shading_rate),
            .attachmentFragmentShadingRate = static_cast<VkBool32>(attachment_fragment_shading_rate)
        };
    }
};

struct PhysicalDeviceFragmentShadingRateKHR {
    VkSampleCountFlags sample_counts;
    Extent2D fragment_size;
    
    VkPhysicalDeviceFragmentShadingRateKHR raw() {
        return VkPhysicalDeviceFragmentShadingRateKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR,
            .pNext = nullptr,
            .sampleCounts = sample_counts,
            .fragmentSize = fragment_size.raw()
        };
    }
};

struct PhysicalDeviceFragmentShadingRatePropertiesKHR {
    Extent2D min_fragment_shading_rate_attachment_texel_size;
    Extent2D max_fragment_shading_rate_attachment_texel_size;
    u32 max_fragment_shading_rate_attachment_texel_size_aspect_ratio;
    bool primitive_fragment_shading_rate_with_multiple_viewports;
    bool layered_shading_rate_attachments;
    bool fragment_shading_rate_non_trivial_combiner_ops;
    Extent2D max_fragment_size;
    u32 max_fragment_size_aspect_ratio;
    u32 max_fragment_shading_rate_coverage_samples;
    SampleCountFlags max_fragment_shading_rate_rasterization_samples;
    bool fragment_shading_rate_with_shader_depth_stencil_writes;
    bool fragment_shading_rate_with_sample_mask;
    bool fragment_shading_rate_with_shader_sample_mask;
    bool fragment_shading_rate_with_conservative_rasterization;
    bool fragment_shading_rate_with_fragment_shader_interlock;
    bool fragment_shading_rate_with_custom_sample_locations;
    bool fragment_shading_rate_strict_multiply_combiner;
    
    VkPhysicalDeviceFragmentShadingRatePropertiesKHR raw() {
        return VkPhysicalDeviceFragmentShadingRatePropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR,
            .pNext = nullptr,
            .minFragmentShadingRateAttachmentTexelSize = min_fragment_shading_rate_attachment_texel_size.raw(),
            .maxFragmentShadingRateAttachmentTexelSize = max_fragment_shading_rate_attachment_texel_size.raw(),
            .maxFragmentShadingRateAttachmentTexelSizeAspectRatio = max_fragment_shading_rate_attachment_texel_size_aspect_ratio,
            .primitiveFragmentShadingRateWithMultipleViewports = static_cast<VkBool32>(primitive_fragment_shading_rate_with_multiple_viewports),
            .layeredShadingRateAttachments = static_cast<VkBool32>(layered_shading_rate_attachments),
            .fragmentShadingRateNonTrivialCombinerOps = static_cast<VkBool32>(fragment_shading_rate_non_trivial_combiner_ops),
            .maxFragmentSize = max_fragment_size.raw(),
            .maxFragmentSizeAspectRatio = max_fragment_size_aspect_ratio,
            .maxFragmentShadingRateCoverageSamples = max_fragment_shading_rate_coverage_samples,
            .maxFragmentShadingRateRasterizationSamples = static_cast<VkSampleCountFlagBits>(max_fragment_shading_rate_rasterization_samples),
            .fragmentShadingRateWithShaderDepthStencilWrites = static_cast<VkBool32>(fragment_shading_rate_with_shader_depth_stencil_writes),
            .fragmentShadingRateWithSampleMask = static_cast<VkBool32>(fragment_shading_rate_with_sample_mask),
            .fragmentShadingRateWithShaderSampleMask = static_cast<VkBool32>(fragment_shading_rate_with_shader_sample_mask),
            .fragmentShadingRateWithConservativeRasterization = static_cast<VkBool32>(fragment_shading_rate_with_conservative_rasterization),
            .fragmentShadingRateWithFragmentShaderInterlock = static_cast<VkBool32>(fragment_shading_rate_with_fragment_shader_interlock),
            .fragmentShadingRateWithCustomSampleLocations = static_cast<VkBool32>(fragment_shading_rate_with_custom_sample_locations),
            .fragmentShadingRateStrictMultiplyCombiner = static_cast<VkBool32>(fragment_shading_rate_strict_multiply_combiner)
        };
    }
};

struct PhysicalDeviceFrameBoundaryFeaturesEXT {
    bool frame_boundary;
    
    VkPhysicalDeviceFrameBoundaryFeaturesEXT raw() {
        return VkPhysicalDeviceFrameBoundaryFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT,
            .pNext = nullptr,
            .frameBoundary = static_cast<VkBool32>(frame_boundary)
        };
    }
};

struct PhysicalDeviceGlobalPriorityQueryFeatures {
    bool global_priority_query;
    
    VkPhysicalDeviceGlobalPriorityQueryFeatures raw() {
        return VkPhysicalDeviceGlobalPriorityQueryFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES,
            .pNext = nullptr,
            .globalPriorityQuery = static_cast<VkBool32>(global_priority_query)
        };
    }
};

struct PhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    bool graphics_pipeline_library;
    
    VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT raw() {
        return VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT,
            .pNext = nullptr,
            .graphicsPipelineLibrary = static_cast<VkBool32>(graphics_pipeline_library)
        };
    }
};

struct PhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    bool graphics_pipeline_library_fast_linking;
    bool graphics_pipeline_library_independent_interpolation_decoration;
    
    VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT raw() {
        return VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT,
            .pNext = nullptr,
            .graphicsPipelineLibraryFastLinking = static_cast<VkBool32>(graphics_pipeline_library_fast_linking),
            .graphicsPipelineLibraryIndependentInterpolationDecoration = static_cast<VkBool32>(graphics_pipeline_library_independent_interpolation_decoration)
        };
    }
};

struct PhysicalDeviceGroupProperties {
    u32 physical_device_count;
    VkPhysicalDevice[] vk_max_device_group_size;
    bool subset_allocation;
    
    VkPhysicalDeviceGroupProperties raw() {
        return VkPhysicalDeviceGroupProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
            .pNext = nullptr,
            .physicalDeviceCount = physical_device_count,
            .VK_MAX_DEVICE_GROUP_SIZE = vk_max_device_group_size,
            .subsetAllocation = static_cast<VkBool32>(subset_allocation)
        };
    }
};

struct PhysicalDeviceHdrVividFeaturesHUAWEI {
    bool hdr_vivid;
    
    VkPhysicalDeviceHdrVividFeaturesHUAWEI raw() {
        return VkPhysicalDeviceHdrVividFeaturesHUAWEI {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI,
            .pNext = nullptr,
            .hdrVivid = static_cast<VkBool32>(hdr_vivid)
        };
    }
};

struct PhysicalDeviceHostImageCopyFeatures {
    bool host_image_copy;
    
    VkPhysicalDeviceHostImageCopyFeatures raw() {
        return VkPhysicalDeviceHostImageCopyFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES,
            .pNext = nullptr,
            .hostImageCopy = static_cast<VkBool32>(host_image_copy)
        };
    }
};

struct PhysicalDeviceHostImageCopyProperties {
    u32 copy_src_layout_count;
    VkImageLayout* copy_src_layouts;
    u32 copy_dst_layout_count;
    VkImageLayout* copy_dst_layouts;
    uint8_t[] vk_uuid_size;
    bool identical_memory_type_requirements;
    
    VkPhysicalDeviceHostImageCopyProperties raw() {
        return VkPhysicalDeviceHostImageCopyProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES,
            .pNext = nullptr,
            .copySrcLayoutCount = copy_src_layout_count,
            .pCopySrcLayouts = copy_src_layouts,
            .copyDstLayoutCount = copy_dst_layout_count,
            .pCopyDstLayouts = copy_dst_layouts,
            .VK_UUID_SIZE = vk_uuid_size,
            .identicalMemoryTypeRequirements = static_cast<VkBool32>(identical_memory_type_requirements)
        };
    }
};

struct PhysicalDeviceHostQueryResetFeatures {
    bool host_query_reset;
    
    VkPhysicalDeviceHostQueryResetFeatures raw() {
        return VkPhysicalDeviceHostQueryResetFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES,
            .pNext = nullptr,
            .hostQueryReset = static_cast<VkBool32>(host_query_reset)
        };
    }
};

struct PhysicalDeviceIDProperties {
    uint8_t[] vk_uuid_size;
    uint8_t[] vk_uuid_size;
    uint8_t[] vk_luid_size;
    u32 device_node_mask;
    bool device_luidvalid;
    
    VkPhysicalDeviceIDProperties raw() {
        return VkPhysicalDeviceIDProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IDPROPERTIES,
            .pNext = nullptr,
            .VK_UUID_SIZE = vk_uuid_size,
            .VK_UUID_SIZE = vk_uuid_size,
            .VK_LUID_SIZE = vk_luid_size,
            .deviceNodeMask = device_node_mask,
            .deviceLUIDValid = static_cast<VkBool32>(device_luidvalid)
        };
    }
};

struct PhysicalDeviceImage2DViewOf3DFeaturesEXT {
    bool image2dview_of3d;
    bool sampler2dview_of3d;
    
    VkPhysicalDeviceImage2DViewOf3DFeaturesEXT raw() {
        return VkPhysicalDeviceImage2DViewOf3DFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE2DVIEW_OF3DFEATURES_EXT,
            .pNext = nullptr,
            .image2DViewOf3D = static_cast<VkBool32>(image2dview_of3d),
            .sampler2DViewOf3D = static_cast<VkBool32>(sampler2dview_of3d)
        };
    }
};

struct PhysicalDeviceImageAlignmentControlFeaturesMESA {
    bool image_alignment_control;
    
    VkPhysicalDeviceImageAlignmentControlFeaturesMESA raw() {
        return VkPhysicalDeviceImageAlignmentControlFeaturesMESA {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA,
            .pNext = nullptr,
            .imageAlignmentControl = static_cast<VkBool32>(image_alignment_control)
        };
    }
};

struct PhysicalDeviceImageAlignmentControlPropertiesMESA {
    u32 supported_image_alignment_mask;
    
    VkPhysicalDeviceImageAlignmentControlPropertiesMESA raw() {
        return VkPhysicalDeviceImageAlignmentControlPropertiesMESA {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA,
            .pNext = nullptr,
            .supportedImageAlignmentMask = supported_image_alignment_mask
        };
    }
};

struct PhysicalDeviceImageCompressionControlFeaturesEXT {
    bool image_compression_control;
    
    VkPhysicalDeviceImageCompressionControlFeaturesEXT raw() {
        return VkPhysicalDeviceImageCompressionControlFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT,
            .pNext = nullptr,
            .imageCompressionControl = static_cast<VkBool32>(image_compression_control)
        };
    }
};

struct PhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
    bool image_compression_control_swapchain;
    
    VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT raw() {
        return VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT,
            .pNext = nullptr,
            .imageCompressionControlSwapchain = static_cast<VkBool32>(image_compression_control_swapchain)
        };
    }
};

struct PhysicalDeviceImageDrmFormatModifierInfoEXT {
    uint64_t drm_format_modifier;
    SharingMode sharing_mode;
    u32 queue_family_index_count;
    uint32_t* queue_family_indices;
    
    VkPhysicalDeviceImageDrmFormatModifierInfoEXT raw() {
        return VkPhysicalDeviceImageDrmFormatModifierInfoEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT,
            .pNext = nullptr,
            .drmFormatModifier = drm_format_modifier,
            .sharingMode = static_cast<VkSharingMode>(sharing_mode),
            .queueFamilyIndexCount = queue_family_index_count,
            .pQueueFamilyIndices = queue_family_indices
        };
    }
};

struct PhysicalDeviceImageFormatInfo2 {
    Format format;
    ImageType type;
    ImageTiling tiling;
    VkImageUsageFlags usage;
    VkImageCreateFlags flags;
    
    VkPhysicalDeviceImageFormatInfo2 raw() {
        return VkPhysicalDeviceImageFormatInfo2 {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO2,
            .pNext = nullptr,
            .format = static_cast<VkFormat>(format),
            .type = static_cast<VkImageType>(type),
            .tiling = static_cast<VkImageTiling>(tiling),
            .usage = usage,
            .flags = flags
        };
    }
};

struct PhysicalDeviceImageProcessing2FeaturesQCOM {
    bool texture_block_match2;
    
    VkPhysicalDeviceImageProcessing2FeaturesQCOM raw() {
        return VkPhysicalDeviceImageProcessing2FeaturesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING2FEATURES_QCOM,
            .pNext = nullptr,
            .textureBlockMatch2 = static_cast<VkBool32>(texture_block_match2)
        };
    }
};

struct PhysicalDeviceImageProcessing2PropertiesQCOM {
    Extent2D max_block_match_window;
    
    VkPhysicalDeviceImageProcessing2PropertiesQCOM raw() {
        return VkPhysicalDeviceImageProcessing2PropertiesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING2PROPERTIES_QCOM,
            .pNext = nullptr,
            .maxBlockMatchWindow = max_block_match_window.raw()
        };
    }
};

struct PhysicalDeviceImageProcessingFeaturesQCOM {
    bool texture_sample_weighted;
    bool texture_box_filter;
    bool texture_block_match;
    
    VkPhysicalDeviceImageProcessingFeaturesQCOM raw() {
        return VkPhysicalDeviceImageProcessingFeaturesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM,
            .pNext = nullptr,
            .textureSampleWeighted = static_cast<VkBool32>(texture_sample_weighted),
            .textureBoxFilter = static_cast<VkBool32>(texture_box_filter),
            .textureBlockMatch = static_cast<VkBool32>(texture_block_match)
        };
    }
};

struct PhysicalDeviceImageProcessingPropertiesQCOM {
    u32 max_weight_filter_phases;
    Extent2D max_weight_filter_dimension;
    Extent2D max_block_match_region;
    Extent2D max_box_filter_block_size;
    
    VkPhysicalDeviceImageProcessingPropertiesQCOM raw() {
        return VkPhysicalDeviceImageProcessingPropertiesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM,
            .pNext = nullptr,
            .maxWeightFilterPhases = max_weight_filter_phases,
            .maxWeightFilterDimension = max_weight_filter_dimension.raw(),
            .maxBlockMatchRegion = max_block_match_region.raw(),
            .maxBoxFilterBlockSize = max_box_filter_block_size.raw()
        };
    }
};

struct PhysicalDeviceImageRobustnessFeatures {
    bool robust_image_access;
    
    VkPhysicalDeviceImageRobustnessFeatures raw() {
        return VkPhysicalDeviceImageRobustnessFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES,
            .pNext = nullptr,
            .robustImageAccess = static_cast<VkBool32>(robust_image_access)
        };
    }
};

struct PhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
    bool image_sliced_view_of3d;
    
    VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT raw() {
        return VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF3DFEATURES_EXT,
            .pNext = nullptr,
            .imageSlicedViewOf3D = static_cast<VkBool32>(image_sliced_view_of3d)
        };
    }
};

struct PhysicalDeviceImageViewImageFormatInfoEXT {
    ImageViewType image_view_type;
    
    VkPhysicalDeviceImageViewImageFormatInfoEXT raw() {
        return VkPhysicalDeviceImageViewImageFormatInfoEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT,
            .pNext = nullptr,
            .imageViewType = static_cast<VkImageViewType>(image_view_type)
        };
    }
};

struct PhysicalDeviceImageViewMinLodFeaturesEXT {
    bool min_lod;
    
    VkPhysicalDeviceImageViewMinLodFeaturesEXT raw() {
        return VkPhysicalDeviceImageViewMinLodFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT,
            .pNext = nullptr,
            .minLod = static_cast<VkBool32>(min_lod)
        };
    }
};

struct PhysicalDeviceImagelessFramebufferFeatures {
    bool imageless_framebuffer;
    
    VkPhysicalDeviceImagelessFramebufferFeatures raw() {
        return VkPhysicalDeviceImagelessFramebufferFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES,
            .pNext = nullptr,
            .imagelessFramebuffer = static_cast<VkBool32>(imageless_framebuffer)
        };
    }
};

struct PhysicalDeviceIndexTypeUint8Features {
    bool index_type_uint8;
    
    VkPhysicalDeviceIndexTypeUint8Features raw() {
        return VkPhysicalDeviceIndexTypeUint8Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8FEATURES,
            .pNext = nullptr,
            .indexTypeUint8 = static_cast<VkBool32>(index_type_uint8)
        };
    }
};

struct PhysicalDeviceInheritedViewportScissorFeaturesNV {
    bool inherited_viewport_scissor2d;
    
    VkPhysicalDeviceInheritedViewportScissorFeaturesNV raw() {
        return VkPhysicalDeviceInheritedViewportScissorFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV,
            .pNext = nullptr,
            .inheritedViewportScissor2D = static_cast<VkBool32>(inherited_viewport_scissor2d)
        };
    }
};

struct PhysicalDeviceInlineUniformBlockFeatures {
    bool inline_uniform_block;
    bool descriptor_binding_inline_uniform_block_update_after_bind;
    
    VkPhysicalDeviceInlineUniformBlockFeatures raw() {
        return VkPhysicalDeviceInlineUniformBlockFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES,
            .pNext = nullptr,
            .inlineUniformBlock = static_cast<VkBool32>(inline_uniform_block),
            .descriptorBindingInlineUniformBlockUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_inline_uniform_block_update_after_bind)
        };
    }
};

struct PhysicalDeviceInlineUniformBlockProperties {
    u32 max_inline_uniform_block_size;
    u32 max_per_stage_descriptor_inline_uniform_blocks;
    u32 max_per_stage_descriptor_update_after_bind_inline_uniform_blocks;
    u32 max_descriptor_set_inline_uniform_blocks;
    u32 max_descriptor_set_update_after_bind_inline_uniform_blocks;
    
    VkPhysicalDeviceInlineUniformBlockProperties raw() {
        return VkPhysicalDeviceInlineUniformBlockProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES,
            .pNext = nullptr,
            .maxInlineUniformBlockSize = max_inline_uniform_block_size,
            .maxPerStageDescriptorInlineUniformBlocks = max_per_stage_descriptor_inline_uniform_blocks,
            .maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = max_per_stage_descriptor_update_after_bind_inline_uniform_blocks,
            .maxDescriptorSetInlineUniformBlocks = max_descriptor_set_inline_uniform_blocks,
            .maxDescriptorSetUpdateAfterBindInlineUniformBlocks = max_descriptor_set_update_after_bind_inline_uniform_blocks
        };
    }
};

struct PhysicalDeviceInvocationMaskFeaturesHUAWEI {
    bool invocation_mask;
    
    VkPhysicalDeviceInvocationMaskFeaturesHUAWEI raw() {
        return VkPhysicalDeviceInvocationMaskFeaturesHUAWEI {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI,
            .pNext = nullptr,
            .invocationMask = static_cast<VkBool32>(invocation_mask)
        };
    }
};

struct PhysicalDeviceLayeredApiPropertiesKHR {
    u32 vendor_id;
    u32 device_id;
    PhysicalDeviceLayeredApiKHR layered_api;
    char[] vk_max_physical_device_name_size;
    
    VkPhysicalDeviceLayeredApiPropertiesKHR raw() {
        return VkPhysicalDeviceLayeredApiPropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR,
            .pNext = nullptr,
            .vendorID = vendor_id,
            .deviceID = device_id,
            .layeredAPI = static_cast<VkPhysicalDeviceLayeredApiKHR>(layered_api),
            .VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = vk_max_physical_device_name_size
        };
    }
};

struct PhysicalDeviceLayeredApiPropertiesListKHR {
    u32 layered_api_count;
    VkPhysicalDeviceLayeredApiPropertiesKHR* layered_apis;
    
    VkPhysicalDeviceLayeredApiPropertiesListKHR raw() {
        return VkPhysicalDeviceLayeredApiPropertiesListKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR,
            .pNext = nullptr,
            .layeredApiCount = layered_api_count,
            .pLayeredApis = layered_apis
        };
    }
};

struct PhysicalDeviceLayeredApiVulkanPropertiesKHR {
    PhysicalDeviceProperties2 properties;
    
    VkPhysicalDeviceLayeredApiVulkanPropertiesKHR raw() {
        return VkPhysicalDeviceLayeredApiVulkanPropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR,
            .pNext = nullptr,
            .properties = properties.raw()
        };
    }
};

struct PhysicalDeviceLayeredDriverPropertiesMSFT {
    LayeredDriverUnderlyingApiMSFT underlying_api;
    
    VkPhysicalDeviceLayeredDriverPropertiesMSFT raw() {
        return VkPhysicalDeviceLayeredDriverPropertiesMSFT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT,
            .pNext = nullptr,
            .underlyingAPI = static_cast<VkLayeredDriverUnderlyingApiMSFT>(underlying_api)
        };
    }
};

struct PhysicalDeviceLegacyDitheringFeaturesEXT {
    bool legacy_dithering;
    
    VkPhysicalDeviceLegacyDitheringFeaturesEXT raw() {
        return VkPhysicalDeviceLegacyDitheringFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT,
            .pNext = nullptr,
            .legacyDithering = static_cast<VkBool32>(legacy_dithering)
        };
    }
};

struct PhysicalDeviceLegacyVertexAttributesFeaturesEXT {
    bool legacy_vertex_attributes;
    
    VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT raw() {
        return VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT,
            .pNext = nullptr,
            .legacyVertexAttributes = static_cast<VkBool32>(legacy_vertex_attributes)
        };
    }
};

struct PhysicalDeviceLegacyVertexAttributesPropertiesEXT {
    bool native_unaligned_performance;
    
    VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT raw() {
        return VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT,
            .pNext = nullptr,
            .nativeUnalignedPerformance = static_cast<VkBool32>(native_unaligned_performance)
        };
    }
};

struct PhysicalDeviceLimits {
    u32 max_image_dimension1d;
    u32 max_image_dimension2d;
    u32 max_image_dimension3d;
    u32 max_image_dimension_cube;
    u32 max_image_array_layers;
    u32 max_texel_buffer_elements;
    u32 max_uniform_buffer_range;
    u32 max_storage_buffer_range;
    u32 max_push_constants_size;
    u32 max_memory_allocation_count;
    u32 max_sampler_allocation_count;
    VkDeviceSize buffer_image_granularity;
    VkDeviceSize sparse_address_space_size;
    u32 max_bound_descriptor_sets;
    u32 max_per_stage_descriptor_samplers;
    u32 max_per_stage_descriptor_uniform_buffers;
    u32 max_per_stage_descriptor_storage_buffers;
    u32 max_per_stage_descriptor_sampled_images;
    u32 max_per_stage_descriptor_storage_images;
    u32 max_per_stage_descriptor_input_attachments;
    u32 max_per_stage_resources;
    u32 max_descriptor_set_samplers;
    u32 max_descriptor_set_uniform_buffers;
    u32 max_descriptor_set_uniform_buffers_dynamic;
    u32 max_descriptor_set_storage_buffers;
    u32 max_descriptor_set_storage_buffers_dynamic;
    u32 max_descriptor_set_sampled_images;
    u32 max_descriptor_set_storage_images;
    u32 max_descriptor_set_input_attachments;
    u32 max_vertex_input_attributes;
    u32 max_vertex_input_bindings;
    u32 max_vertex_input_attribute_offset;
    u32 max_vertex_input_binding_stride;
    u32 max_vertex_output_components;
    u32 max_tessellation_generation_level;
    u32 max_tessellation_patch_size;
    u32 max_tessellation_control_per_vertex_input_components;
    u32 max_tessellation_control_per_vertex_output_components;
    u32 max_tessellation_control_per_patch_output_components;
    u32 max_tessellation_control_total_output_components;
    u32 max_tessellation_evaluation_input_components;
    u32 max_tessellation_evaluation_output_components;
    u32 max_geometry_shader_invocations;
    u32 max_geometry_input_components;
    u32 max_geometry_output_components;
    u32 max_geometry_output_vertices;
    u32 max_geometry_total_output_components;
    u32 max_fragment_input_components;
    u32 max_fragment_output_attachments;
    u32 max_fragment_dual_src_attachments;
    u32 max_fragment_combined_output_resources;
    u32 max_compute_shared_memory_size;
    uint32_t[3] max_compute_work_group_count;
    u32 max_compute_work_group_invocations;
    uint32_t[3] max_compute_work_group_size;
    u32 sub_pixel_precision_bits;
    u32 sub_texel_precision_bits;
    u32 mipmap_precision_bits;
    u32 max_draw_indexed_index_value;
    u32 max_draw_indirect_count;
    f32 max_sampler_lod_bias;
    f32 max_sampler_anisotropy;
    u32 max_viewports;
    uint32_t[2] max_viewport_dimensions;
    float[2] viewport_bounds_range;
    u32 viewport_sub_pixel_bits;
    size_t min_memory_map_alignment;
    VkDeviceSize min_texel_buffer_offset_alignment;
    VkDeviceSize min_uniform_buffer_offset_alignment;
    VkDeviceSize min_storage_buffer_offset_alignment;
    i32 min_texel_offset;
    u32 max_texel_offset;
    i32 min_texel_gather_offset;
    u32 max_texel_gather_offset;
    f32 min_interpolation_offset;
    f32 max_interpolation_offset;
    u32 sub_pixel_interpolation_offset_bits;
    u32 max_framebuffer_width;
    u32 max_framebuffer_height;
    u32 max_framebuffer_layers;
    VkSampleCountFlags framebuffer_color_sample_counts;
    VkSampleCountFlags framebuffer_depth_sample_counts;
    VkSampleCountFlags framebuffer_stencil_sample_counts;
    VkSampleCountFlags framebuffer_no_attachments_sample_counts;
    u32 max_color_attachments;
    VkSampleCountFlags sampled_image_color_sample_counts;
    VkSampleCountFlags sampled_image_integer_sample_counts;
    VkSampleCountFlags sampled_image_depth_sample_counts;
    VkSampleCountFlags sampled_image_stencil_sample_counts;
    VkSampleCountFlags storage_image_sample_counts;
    u32 max_sample_mask_words;
    bool timestamp_compute_and_graphics;
    f32 timestamp_period;
    u32 max_clip_distances;
    u32 max_cull_distances;
    u32 max_combined_clip_and_cull_distances;
    u32 discrete_queue_priorities;
    float[2] point_size_range;
    float[2] line_width_range;
    f32 point_size_granularity;
    f32 line_width_granularity;
    bool strict_lines;
    bool standard_sample_locations;
    VkDeviceSize optimal_buffer_copy_offset_alignment;
    VkDeviceSize optimal_buffer_copy_row_pitch_alignment;
    VkDeviceSize non_coherent_atom_size;
    
    VkPhysicalDeviceLimits raw() {
        return VkPhysicalDeviceLimits {
            .maxImageDimension1D = max_image_dimension1d,
            .maxImageDimension2D = max_image_dimension2d,
            .maxImageDimension3D = max_image_dimension3d,
            .maxImageDimensionCube = max_image_dimension_cube,
            .maxImageArrayLayers = max_image_array_layers,
            .maxTexelBufferElements = max_texel_buffer_elements,
            .maxUniformBufferRange = max_uniform_buffer_range,
            .maxStorageBufferRange = max_storage_buffer_range,
            .maxPushConstantsSize = max_push_constants_size,
            .maxMemoryAllocationCount = max_memory_allocation_count,
            .maxSamplerAllocationCount = max_sampler_allocation_count,
            .bufferImageGranularity = buffer_image_granularity,
            .sparseAddressSpaceSize = sparse_address_space_size,
            .maxBoundDescriptorSets = max_bound_descriptor_sets,
            .maxPerStageDescriptorSamplers = max_per_stage_descriptor_samplers,
            .maxPerStageDescriptorUniformBuffers = max_per_stage_descriptor_uniform_buffers,
            .maxPerStageDescriptorStorageBuffers = max_per_stage_descriptor_storage_buffers,
            .maxPerStageDescriptorSampledImages = max_per_stage_descriptor_sampled_images,
            .maxPerStageDescriptorStorageImages = max_per_stage_descriptor_storage_images,
            .maxPerStageDescriptorInputAttachments = max_per_stage_descriptor_input_attachments,
            .maxPerStageResources = max_per_stage_resources,
            .maxDescriptorSetSamplers = max_descriptor_set_samplers,
            .maxDescriptorSetUniformBuffers = max_descriptor_set_uniform_buffers,
            .maxDescriptorSetUniformBuffersDynamic = max_descriptor_set_uniform_buffers_dynamic,
            .maxDescriptorSetStorageBuffers = max_descriptor_set_storage_buffers,
            .maxDescriptorSetStorageBuffersDynamic = max_descriptor_set_storage_buffers_dynamic,
            .maxDescriptorSetSampledImages = max_descriptor_set_sampled_images,
            .maxDescriptorSetStorageImages = max_descriptor_set_storage_images,
            .maxDescriptorSetInputAttachments = max_descriptor_set_input_attachments,
            .maxVertexInputAttributes = max_vertex_input_attributes,
            .maxVertexInputBindings = max_vertex_input_bindings,
            .maxVertexInputAttributeOffset = max_vertex_input_attribute_offset,
            .maxVertexInputBindingStride = max_vertex_input_binding_stride,
            .maxVertexOutputComponents = max_vertex_output_components,
            .maxTessellationGenerationLevel = max_tessellation_generation_level,
            .maxTessellationPatchSize = max_tessellation_patch_size,
            .maxTessellationControlPerVertexInputComponents = max_tessellation_control_per_vertex_input_components,
            .maxTessellationControlPerVertexOutputComponents = max_tessellation_control_per_vertex_output_components,
            .maxTessellationControlPerPatchOutputComponents = max_tessellation_control_per_patch_output_components,
            .maxTessellationControlTotalOutputComponents = max_tessellation_control_total_output_components,
            .maxTessellationEvaluationInputComponents = max_tessellation_evaluation_input_components,
            .maxTessellationEvaluationOutputComponents = max_tessellation_evaluation_output_components,
            .maxGeometryShaderInvocations = max_geometry_shader_invocations,
            .maxGeometryInputComponents = max_geometry_input_components,
            .maxGeometryOutputComponents = max_geometry_output_components,
            .maxGeometryOutputVertices = max_geometry_output_vertices,
            .maxGeometryTotalOutputComponents = max_geometry_total_output_components,
            .maxFragmentInputComponents = max_fragment_input_components,
            .maxFragmentOutputAttachments = max_fragment_output_attachments,
            .maxFragmentDualSrcAttachments = max_fragment_dual_src_attachments,
            .maxFragmentCombinedOutputResources = max_fragment_combined_output_resources,
            .maxComputeSharedMemorySize = max_compute_shared_memory_size,
            .maxComputeWorkGroupCount = max_compute_work_group_count,
            .maxComputeWorkGroupInvocations = max_compute_work_group_invocations,
            .maxComputeWorkGroupSize = max_compute_work_group_size,
            .subPixelPrecisionBits = sub_pixel_precision_bits,
            .subTexelPrecisionBits = sub_texel_precision_bits,
            .mipmapPrecisionBits = mipmap_precision_bits,
            .maxDrawIndexedIndexValue = max_draw_indexed_index_value,
            .maxDrawIndirectCount = max_draw_indirect_count,
            .maxSamplerLodBias = max_sampler_lod_bias,
            .maxSamplerAnisotropy = max_sampler_anisotropy,
            .maxViewports = max_viewports,
            .maxViewportDimensions = max_viewport_dimensions,
            .viewportBoundsRange = viewport_bounds_range,
            .viewportSubPixelBits = viewport_sub_pixel_bits,
            .minMemoryMapAlignment = min_memory_map_alignment,
            .minTexelBufferOffsetAlignment = min_texel_buffer_offset_alignment,
            .minUniformBufferOffsetAlignment = min_uniform_buffer_offset_alignment,
            .minStorageBufferOffsetAlignment = min_storage_buffer_offset_alignment,
            .minTexelOffset = min_texel_offset,
            .maxTexelOffset = max_texel_offset,
            .minTexelGatherOffset = min_texel_gather_offset,
            .maxTexelGatherOffset = max_texel_gather_offset,
            .minInterpolationOffset = min_interpolation_offset,
            .maxInterpolationOffset = max_interpolation_offset,
            .subPixelInterpolationOffsetBits = sub_pixel_interpolation_offset_bits,
            .maxFramebufferWidth = max_framebuffer_width,
            .maxFramebufferHeight = max_framebuffer_height,
            .maxFramebufferLayers = max_framebuffer_layers,
            .framebufferColorSampleCounts = framebuffer_color_sample_counts,
            .framebufferDepthSampleCounts = framebuffer_depth_sample_counts,
            .framebufferStencilSampleCounts = framebuffer_stencil_sample_counts,
            .framebufferNoAttachmentsSampleCounts = framebuffer_no_attachments_sample_counts,
            .maxColorAttachments = max_color_attachments,
            .sampledImageColorSampleCounts = sampled_image_color_sample_counts,
            .sampledImageIntegerSampleCounts = sampled_image_integer_sample_counts,
            .sampledImageDepthSampleCounts = sampled_image_depth_sample_counts,
            .sampledImageStencilSampleCounts = sampled_image_stencil_sample_counts,
            .storageImageSampleCounts = storage_image_sample_counts,
            .maxSampleMaskWords = max_sample_mask_words,
            .timestampComputeAndGraphics = static_cast<VkBool32>(timestamp_compute_and_graphics),
            .timestampPeriod = timestamp_period,
            .maxClipDistances = max_clip_distances,
            .maxCullDistances = max_cull_distances,
            .maxCombinedClipAndCullDistances = max_combined_clip_and_cull_distances,
            .discreteQueuePriorities = discrete_queue_priorities,
            .pointSizeRange = point_size_range,
            .lineWidthRange = line_width_range,
            .pointSizeGranularity = point_size_granularity,
            .lineWidthGranularity = line_width_granularity,
            .strictLines = static_cast<VkBool32>(strict_lines),
            .standardSampleLocations = static_cast<VkBool32>(standard_sample_locations),
            .optimalBufferCopyOffsetAlignment = optimal_buffer_copy_offset_alignment,
            .optimalBufferCopyRowPitchAlignment = optimal_buffer_copy_row_pitch_alignment,
            .nonCoherentAtomSize = non_coherent_atom_size
        };
    }
};

struct PhysicalDeviceLineRasterizationFeatures {
    bool rectangular_lines;
    bool bresenham_lines;
    bool smooth_lines;
    bool stippled_rectangular_lines;
    bool stippled_bresenham_lines;
    bool stippled_smooth_lines;
    
    VkPhysicalDeviceLineRasterizationFeatures raw() {
        return VkPhysicalDeviceLineRasterizationFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES,
            .pNext = nullptr,
            .rectangularLines = static_cast<VkBool32>(rectangular_lines),
            .bresenhamLines = static_cast<VkBool32>(bresenham_lines),
            .smoothLines = static_cast<VkBool32>(smooth_lines),
            .stippledRectangularLines = static_cast<VkBool32>(stippled_rectangular_lines),
            .stippledBresenhamLines = static_cast<VkBool32>(stippled_bresenham_lines),
            .stippledSmoothLines = static_cast<VkBool32>(stippled_smooth_lines)
        };
    }
};

struct PhysicalDeviceLineRasterizationProperties {
    u32 line_sub_pixel_precision_bits;
    
    VkPhysicalDeviceLineRasterizationProperties raw() {
        return VkPhysicalDeviceLineRasterizationProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES,
            .pNext = nullptr,
            .lineSubPixelPrecisionBits = line_sub_pixel_precision_bits
        };
    }
};

struct PhysicalDeviceLinearColorAttachmentFeaturesNV {
    bool linear_color_attachment;
    
    VkPhysicalDeviceLinearColorAttachmentFeaturesNV raw() {
        return VkPhysicalDeviceLinearColorAttachmentFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV,
            .pNext = nullptr,
            .linearColorAttachment = static_cast<VkBool32>(linear_color_attachment)
        };
    }
};

struct PhysicalDeviceMaintenance3Properties {
    u32 max_per_set_descriptors;
    VkDeviceSize max_memory_allocation_size;
    
    VkPhysicalDeviceMaintenance3Properties raw() {
        return VkPhysicalDeviceMaintenance3Properties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAINTENANCE3PROPERTIES,
            .pNext = nullptr,
            .maxPerSetDescriptors = max_per_set_descriptors,
            .maxMemoryAllocationSize = max_memory_allocation_size
        };
    }
};

struct PhysicalDeviceMaintenance4Features {
    bool maintenance4;
    
    VkPhysicalDeviceMaintenance4Features raw() {
        return VkPhysicalDeviceMaintenance4Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAINTENANCE4FEATURES,
            .pNext = nullptr,
            .maintenance4 = static_cast<VkBool32>(maintenance4)
        };
    }
};

struct PhysicalDeviceMaintenance4Properties {
    VkDeviceSize max_buffer_size;
    
    VkPhysicalDeviceMaintenance4Properties raw() {
        return VkPhysicalDeviceMaintenance4Properties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAINTENANCE4PROPERTIES,
            .pNext = nullptr,
            .maxBufferSize = max_buffer_size
        };
    }
};

struct PhysicalDeviceMaintenance5Features {
    bool maintenance5;
    
    VkPhysicalDeviceMaintenance5Features raw() {
        return VkPhysicalDeviceMaintenance5Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAINTENANCE5FEATURES,
            .pNext = nullptr,
            .maintenance5 = static_cast<VkBool32>(maintenance5)
        };
    }
};

struct PhysicalDeviceMaintenance5Properties {
    bool early_fragment_multisample_coverage_after_sample_counting;
    bool early_fragment_sample_mask_test_before_sample_counting;
    bool depth_stencil_swizzle_one_support;
    bool polygon_mode_point_size;
    bool non_strict_single_pixel_wide_lines_use_parallelogram;
    bool non_strict_wide_lines_use_parallelogram;
    
    VkPhysicalDeviceMaintenance5Properties raw() {
        return VkPhysicalDeviceMaintenance5Properties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAINTENANCE5PROPERTIES,
            .pNext = nullptr,
            .earlyFragmentMultisampleCoverageAfterSampleCounting = static_cast<VkBool32>(early_fragment_multisample_coverage_after_sample_counting),
            .earlyFragmentSampleMaskTestBeforeSampleCounting = static_cast<VkBool32>(early_fragment_sample_mask_test_before_sample_counting),
            .depthStencilSwizzleOneSupport = static_cast<VkBool32>(depth_stencil_swizzle_one_support),
            .polygonModePointSize = static_cast<VkBool32>(polygon_mode_point_size),
            .nonStrictSinglePixelWideLinesUseParallelogram = static_cast<VkBool32>(non_strict_single_pixel_wide_lines_use_parallelogram),
            .nonStrictWideLinesUseParallelogram = static_cast<VkBool32>(non_strict_wide_lines_use_parallelogram)
        };
    }
};

struct PhysicalDeviceMaintenance6Features {
    bool maintenance6;
    
    VkPhysicalDeviceMaintenance6Features raw() {
        return VkPhysicalDeviceMaintenance6Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAINTENANCE6FEATURES,
            .pNext = nullptr,
            .maintenance6 = static_cast<VkBool32>(maintenance6)
        };
    }
};

struct PhysicalDeviceMaintenance6Properties {
    bool block_texel_view_compatible_multiple_layers;
    u32 max_combined_image_sampler_descriptor_count;
    bool fragment_shading_rate_clamp_combiner_inputs;
    
    VkPhysicalDeviceMaintenance6Properties raw() {
        return VkPhysicalDeviceMaintenance6Properties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAINTENANCE6PROPERTIES,
            .pNext = nullptr,
            .blockTexelViewCompatibleMultipleLayers = static_cast<VkBool32>(block_texel_view_compatible_multiple_layers),
            .maxCombinedImageSamplerDescriptorCount = max_combined_image_sampler_descriptor_count,
            .fragmentShadingRateClampCombinerInputs = static_cast<VkBool32>(fragment_shading_rate_clamp_combiner_inputs)
        };
    }
};

struct PhysicalDeviceMaintenance7FeaturesKHR {
    bool maintenance7;
    
    VkPhysicalDeviceMaintenance7FeaturesKHR raw() {
        return VkPhysicalDeviceMaintenance7FeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAINTENANCE7FEATURES_KHR,
            .pNext = nullptr,
            .maintenance7 = static_cast<VkBool32>(maintenance7)
        };
    }
};

struct PhysicalDeviceMaintenance7PropertiesKHR {
    bool robust_fragment_shading_rate_attachment_access;
    bool separate_depth_stencil_attachment_access;
    u32 max_descriptor_set_total_uniform_buffers_dynamic;
    u32 max_descriptor_set_total_storage_buffers_dynamic;
    u32 max_descriptor_set_total_buffers_dynamic;
    u32 max_descriptor_set_update_after_bind_total_uniform_buffers_dynamic;
    u32 max_descriptor_set_update_after_bind_total_storage_buffers_dynamic;
    u32 max_descriptor_set_update_after_bind_total_buffers_dynamic;
    
    VkPhysicalDeviceMaintenance7PropertiesKHR raw() {
        return VkPhysicalDeviceMaintenance7PropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAINTENANCE7PROPERTIES_KHR,
            .pNext = nullptr,
            .robustFragmentShadingRateAttachmentAccess = static_cast<VkBool32>(robust_fragment_shading_rate_attachment_access),
            .separateDepthStencilAttachmentAccess = static_cast<VkBool32>(separate_depth_stencil_attachment_access),
            .maxDescriptorSetTotalUniformBuffersDynamic = max_descriptor_set_total_uniform_buffers_dynamic,
            .maxDescriptorSetTotalStorageBuffersDynamic = max_descriptor_set_total_storage_buffers_dynamic,
            .maxDescriptorSetTotalBuffersDynamic = max_descriptor_set_total_buffers_dynamic,
            .maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic = max_descriptor_set_update_after_bind_total_uniform_buffers_dynamic,
            .maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic = max_descriptor_set_update_after_bind_total_storage_buffers_dynamic,
            .maxDescriptorSetUpdateAfterBindTotalBuffersDynamic = max_descriptor_set_update_after_bind_total_buffers_dynamic
        };
    }
};

struct PhysicalDeviceMaintenance8FeaturesKHR {
    bool maintenance8;
    
    VkPhysicalDeviceMaintenance8FeaturesKHR raw() {
        return VkPhysicalDeviceMaintenance8FeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAINTENANCE8FEATURES_KHR,
            .pNext = nullptr,
            .maintenance8 = static_cast<VkBool32>(maintenance8)
        };
    }
};

struct PhysicalDeviceMapMemoryPlacedFeaturesEXT {
    bool memory_map_placed;
    bool memory_map_range_placed;
    bool memory_unmap_reserve;
    
    VkPhysicalDeviceMapMemoryPlacedFeaturesEXT raw() {
        return VkPhysicalDeviceMapMemoryPlacedFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT,
            .pNext = nullptr,
            .memoryMapPlaced = static_cast<VkBool32>(memory_map_placed),
            .memoryMapRangePlaced = static_cast<VkBool32>(memory_map_range_placed),
            .memoryUnmapReserve = static_cast<VkBool32>(memory_unmap_reserve)
        };
    }
};

struct PhysicalDeviceMapMemoryPlacedPropertiesEXT {
    VkDeviceSize min_placed_memory_map_alignment;
    
    VkPhysicalDeviceMapMemoryPlacedPropertiesEXT raw() {
        return VkPhysicalDeviceMapMemoryPlacedPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT,
            .pNext = nullptr,
            .minPlacedMemoryMapAlignment = min_placed_memory_map_alignment
        };
    }
};

struct PhysicalDeviceMemoryBudgetPropertiesEXT {
    VkDeviceSize[] vk_max_memory_heaps;
    VkDeviceSize[] vk_max_memory_heaps;
    
    VkPhysicalDeviceMemoryBudgetPropertiesEXT raw() {
        return VkPhysicalDeviceMemoryBudgetPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT,
            .pNext = nullptr,
            .VK_MAX_MEMORY_HEAPS = vk_max_memory_heaps,
            .VK_MAX_MEMORY_HEAPS = vk_max_memory_heaps
        };
    }
};

struct PhysicalDeviceMemoryDecompressionFeaturesNV {
    bool memory_decompression;
    
    VkPhysicalDeviceMemoryDecompressionFeaturesNV raw() {
        return VkPhysicalDeviceMemoryDecompressionFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV,
            .pNext = nullptr,
            .memoryDecompression = static_cast<VkBool32>(memory_decompression)
        };
    }
};

struct PhysicalDeviceMemoryDecompressionPropertiesNV {
    VkMemoryDecompressionMethodFlagsNV decompression_methods;
    uint64_t max_decompression_indirect_count;
    
    VkPhysicalDeviceMemoryDecompressionPropertiesNV raw() {
        return VkPhysicalDeviceMemoryDecompressionPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV,
            .pNext = nullptr,
            .decompressionMethods = decompression_methods,
            .maxDecompressionIndirectCount = max_decompression_indirect_count
        };
    }
};

struct PhysicalDeviceMemoryPriorityFeaturesEXT {
    bool memory_priority;
    
    VkPhysicalDeviceMemoryPriorityFeaturesEXT raw() {
        return VkPhysicalDeviceMemoryPriorityFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT,
            .pNext = nullptr,
            .memoryPriority = static_cast<VkBool32>(memory_priority)
        };
    }
};

struct PhysicalDeviceMemoryProperties {
    u32 memory_type_count;
    VkMemoryType[] vk_max_memory_types;
    u32 memory_heap_count;
    VkMemoryHeap[] vk_max_memory_heaps;
    
    VkPhysicalDeviceMemoryProperties raw() {
        return VkPhysicalDeviceMemoryProperties {
            .memoryTypeCount = memory_type_count,
            .VK_MAX_MEMORY_TYPES = vk_max_memory_types,
            .memoryHeapCount = memory_heap_count,
            .VK_MAX_MEMORY_HEAPS = vk_max_memory_heaps
        };
    }
};

struct PhysicalDeviceMemoryProperties2 {
    PhysicalDeviceMemoryProperties memory_properties;
    
    VkPhysicalDeviceMemoryProperties2 raw() {
        return VkPhysicalDeviceMemoryProperties2 {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES2,
            .pNext = nullptr,
            .memoryProperties = memory_properties.raw()
        };
    }
};

struct PhysicalDeviceMeshShaderFeaturesEXT {
    bool task_shader;
    bool mesh_shader;
    bool multiview_mesh_shader;
    bool primitive_fragment_shading_rate_mesh_shader;
    bool mesh_shader_queries;
    
    VkPhysicalDeviceMeshShaderFeaturesEXT raw() {
        return VkPhysicalDeviceMeshShaderFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT,
            .pNext = nullptr,
            .taskShader = static_cast<VkBool32>(task_shader),
            .meshShader = static_cast<VkBool32>(mesh_shader),
            .multiviewMeshShader = static_cast<VkBool32>(multiview_mesh_shader),
            .primitiveFragmentShadingRateMeshShader = static_cast<VkBool32>(primitive_fragment_shading_rate_mesh_shader),
            .meshShaderQueries = static_cast<VkBool32>(mesh_shader_queries)
        };
    }
};

struct PhysicalDeviceMeshShaderFeaturesNV {
    bool task_shader;
    bool mesh_shader;
    
    VkPhysicalDeviceMeshShaderFeaturesNV raw() {
        return VkPhysicalDeviceMeshShaderFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV,
            .pNext = nullptr,
            .taskShader = static_cast<VkBool32>(task_shader),
            .meshShader = static_cast<VkBool32>(mesh_shader)
        };
    }
};

struct PhysicalDeviceMeshShaderPropertiesEXT {
    u32 max_task_work_group_total_count;
    uint32_t[3] max_task_work_group_count;
    u32 max_task_work_group_invocations;
    uint32_t[3] max_task_work_group_size;
    u32 max_task_payload_size;
    u32 max_task_shared_memory_size;
    u32 max_task_payload_and_shared_memory_size;
    u32 max_mesh_work_group_total_count;
    uint32_t[3] max_mesh_work_group_count;
    u32 max_mesh_work_group_invocations;
    uint32_t[3] max_mesh_work_group_size;
    u32 max_mesh_shared_memory_size;
    u32 max_mesh_payload_and_shared_memory_size;
    u32 max_mesh_output_memory_size;
    u32 max_mesh_payload_and_output_memory_size;
    u32 max_mesh_output_components;
    u32 max_mesh_output_vertices;
    u32 max_mesh_output_primitives;
    u32 max_mesh_output_layers;
    u32 max_mesh_multiview_view_count;
    u32 mesh_output_per_vertex_granularity;
    u32 mesh_output_per_primitive_granularity;
    u32 max_preferred_task_work_group_invocations;
    u32 max_preferred_mesh_work_group_invocations;
    bool prefers_local_invocation_vertex_output;
    bool prefers_local_invocation_primitive_output;
    bool prefers_compact_vertex_output;
    bool prefers_compact_primitive_output;
    
    VkPhysicalDeviceMeshShaderPropertiesEXT raw() {
        return VkPhysicalDeviceMeshShaderPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT,
            .pNext = nullptr,
            .maxTaskWorkGroupTotalCount = max_task_work_group_total_count,
            .maxTaskWorkGroupCount = max_task_work_group_count,
            .maxTaskWorkGroupInvocations = max_task_work_group_invocations,
            .maxTaskWorkGroupSize = max_task_work_group_size,
            .maxTaskPayloadSize = max_task_payload_size,
            .maxTaskSharedMemorySize = max_task_shared_memory_size,
            .maxTaskPayloadAndSharedMemorySize = max_task_payload_and_shared_memory_size,
            .maxMeshWorkGroupTotalCount = max_mesh_work_group_total_count,
            .maxMeshWorkGroupCount = max_mesh_work_group_count,
            .maxMeshWorkGroupInvocations = max_mesh_work_group_invocations,
            .maxMeshWorkGroupSize = max_mesh_work_group_size,
            .maxMeshSharedMemorySize = max_mesh_shared_memory_size,
            .maxMeshPayloadAndSharedMemorySize = max_mesh_payload_and_shared_memory_size,
            .maxMeshOutputMemorySize = max_mesh_output_memory_size,
            .maxMeshPayloadAndOutputMemorySize = max_mesh_payload_and_output_memory_size,
            .maxMeshOutputComponents = max_mesh_output_components,
            .maxMeshOutputVertices = max_mesh_output_vertices,
            .maxMeshOutputPrimitives = max_mesh_output_primitives,
            .maxMeshOutputLayers = max_mesh_output_layers,
            .maxMeshMultiviewViewCount = max_mesh_multiview_view_count,
            .meshOutputPerVertexGranularity = mesh_output_per_vertex_granularity,
            .meshOutputPerPrimitiveGranularity = mesh_output_per_primitive_granularity,
            .maxPreferredTaskWorkGroupInvocations = max_preferred_task_work_group_invocations,
            .maxPreferredMeshWorkGroupInvocations = max_preferred_mesh_work_group_invocations,
            .prefersLocalInvocationVertexOutput = static_cast<VkBool32>(prefers_local_invocation_vertex_output),
            .prefersLocalInvocationPrimitiveOutput = static_cast<VkBool32>(prefers_local_invocation_primitive_output),
            .prefersCompactVertexOutput = static_cast<VkBool32>(prefers_compact_vertex_output),
            .prefersCompactPrimitiveOutput = static_cast<VkBool32>(prefers_compact_primitive_output)
        };
    }
};

struct PhysicalDeviceMeshShaderPropertiesNV {
    u32 max_draw_mesh_tasks_count;
    u32 max_task_work_group_invocations;
    uint32_t[3] max_task_work_group_size;
    u32 max_task_total_memory_size;
    u32 max_task_output_count;
    u32 max_mesh_work_group_invocations;
    uint32_t[3] max_mesh_work_group_size;
    u32 max_mesh_total_memory_size;
    u32 max_mesh_output_vertices;
    u32 max_mesh_output_primitives;
    u32 max_mesh_multiview_view_count;
    u32 mesh_output_per_vertex_granularity;
    u32 mesh_output_per_primitive_granularity;
    
    VkPhysicalDeviceMeshShaderPropertiesNV raw() {
        return VkPhysicalDeviceMeshShaderPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV,
            .pNext = nullptr,
            .maxDrawMeshTasksCount = max_draw_mesh_tasks_count,
            .maxTaskWorkGroupInvocations = max_task_work_group_invocations,
            .maxTaskWorkGroupSize = max_task_work_group_size,
            .maxTaskTotalMemorySize = max_task_total_memory_size,
            .maxTaskOutputCount = max_task_output_count,
            .maxMeshWorkGroupInvocations = max_mesh_work_group_invocations,
            .maxMeshWorkGroupSize = max_mesh_work_group_size,
            .maxMeshTotalMemorySize = max_mesh_total_memory_size,
            .maxMeshOutputVertices = max_mesh_output_vertices,
            .maxMeshOutputPrimitives = max_mesh_output_primitives,
            .maxMeshMultiviewViewCount = max_mesh_multiview_view_count,
            .meshOutputPerVertexGranularity = mesh_output_per_vertex_granularity,
            .meshOutputPerPrimitiveGranularity = mesh_output_per_primitive_granularity
        };
    }
};

struct PhysicalDeviceMultiDrawFeaturesEXT {
    bool multi_draw;
    
    VkPhysicalDeviceMultiDrawFeaturesEXT raw() {
        return VkPhysicalDeviceMultiDrawFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT,
            .pNext = nullptr,
            .multiDraw = static_cast<VkBool32>(multi_draw)
        };
    }
};

struct PhysicalDeviceMultiDrawPropertiesEXT {
    u32 max_multi_draw_count;
    
    VkPhysicalDeviceMultiDrawPropertiesEXT raw() {
        return VkPhysicalDeviceMultiDrawPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT,
            .pNext = nullptr,
            .maxMultiDrawCount = max_multi_draw_count
        };
    }
};

struct PhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
    bool multisampled_render_to_single_sampled;
    
    VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT raw() {
        return VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT,
            .pNext = nullptr,
            .multisampledRenderToSingleSampled = static_cast<VkBool32>(multisampled_render_to_single_sampled)
        };
    }
};

struct PhysicalDeviceMultiviewFeatures {
    bool multiview;
    bool multiview_geometry_shader;
    bool multiview_tessellation_shader;
    
    VkPhysicalDeviceMultiviewFeatures raw() {
        return VkPhysicalDeviceMultiviewFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
            .pNext = nullptr,
            .multiview = static_cast<VkBool32>(multiview),
            .multiviewGeometryShader = static_cast<VkBool32>(multiview_geometry_shader),
            .multiviewTessellationShader = static_cast<VkBool32>(multiview_tessellation_shader)
        };
    }
};

struct PhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    bool per_view_position_all_components;
    
    VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX raw() {
        return VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX,
            .pNext = nullptr,
            .perViewPositionAllComponents = static_cast<VkBool32>(per_view_position_all_components)
        };
    }
};

struct PhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
    bool multiview_per_view_render_areas;
    
    VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM raw() {
        return VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM,
            .pNext = nullptr,
            .multiviewPerViewRenderAreas = static_cast<VkBool32>(multiview_per_view_render_areas)
        };
    }
};

struct PhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
    bool multiview_per_view_viewports;
    
    VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM raw() {
        return VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM,
            .pNext = nullptr,
            .multiviewPerViewViewports = static_cast<VkBool32>(multiview_per_view_viewports)
        };
    }
};

struct PhysicalDeviceMultiviewProperties {
    u32 max_multiview_view_count;
    u32 max_multiview_instance_index;
    
    VkPhysicalDeviceMultiviewProperties raw() {
        return VkPhysicalDeviceMultiviewProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
            .pNext = nullptr,
            .maxMultiviewViewCount = max_multiview_view_count,
            .maxMultiviewInstanceIndex = max_multiview_instance_index
        };
    }
};

struct PhysicalDeviceMutableDescriptorTypeFeaturesEXT {
    bool mutable_descriptor_type;
    
    VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT raw() {
        return VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT,
            .pNext = nullptr,
            .mutableDescriptorType = static_cast<VkBool32>(mutable_descriptor_type)
        };
    }
};

struct PhysicalDeviceNestedCommandBufferFeaturesEXT {
    bool nested_command_buffer;
    bool nested_command_buffer_rendering;
    bool nested_command_buffer_simultaneous_use;
    
    VkPhysicalDeviceNestedCommandBufferFeaturesEXT raw() {
        return VkPhysicalDeviceNestedCommandBufferFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT,
            .pNext = nullptr,
            .nestedCommandBuffer = static_cast<VkBool32>(nested_command_buffer),
            .nestedCommandBufferRendering = static_cast<VkBool32>(nested_command_buffer_rendering),
            .nestedCommandBufferSimultaneousUse = static_cast<VkBool32>(nested_command_buffer_simultaneous_use)
        };
    }
};

struct PhysicalDeviceNestedCommandBufferPropertiesEXT {
    u32 max_command_buffer_nesting_level;
    
    VkPhysicalDeviceNestedCommandBufferPropertiesEXT raw() {
        return VkPhysicalDeviceNestedCommandBufferPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT,
            .pNext = nullptr,
            .maxCommandBufferNestingLevel = max_command_buffer_nesting_level
        };
    }
};

struct PhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
    bool non_seamless_cube_map;
    
    VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT raw() {
        return VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT,
            .pNext = nullptr,
            .nonSeamlessCubeMap = static_cast<VkBool32>(non_seamless_cube_map)
        };
    }
};

struct PhysicalDeviceOpacityMicromapFeaturesEXT {
    bool micromap;
    bool micromap_capture_replay;
    bool micromap_host_commands;
    
    VkPhysicalDeviceOpacityMicromapFeaturesEXT raw() {
        return VkPhysicalDeviceOpacityMicromapFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT,
            .pNext = nullptr,
            .micromap = static_cast<VkBool32>(micromap),
            .micromapCaptureReplay = static_cast<VkBool32>(micromap_capture_replay),
            .micromapHostCommands = static_cast<VkBool32>(micromap_host_commands)
        };
    }
};

struct PhysicalDeviceOpacityMicromapPropertiesEXT {
    u32 max_opacity2state_subdivision_level;
    u32 max_opacity4state_subdivision_level;
    
    VkPhysicalDeviceOpacityMicromapPropertiesEXT raw() {
        return VkPhysicalDeviceOpacityMicromapPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT,
            .pNext = nullptr,
            .maxOpacity2StateSubdivisionLevel = max_opacity2state_subdivision_level,
            .maxOpacity4StateSubdivisionLevel = max_opacity4state_subdivision_level
        };
    }
};

struct PhysicalDeviceOpticalFlowFeaturesNV {
    bool optical_flow;
    
    VkPhysicalDeviceOpticalFlowFeaturesNV raw() {
        return VkPhysicalDeviceOpticalFlowFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV,
            .pNext = nullptr,
            .opticalFlow = static_cast<VkBool32>(optical_flow)
        };
    }
};

struct PhysicalDeviceOpticalFlowPropertiesNV {
    VkOpticalFlowGridSizeFlagsNV supported_output_grid_sizes;
    VkOpticalFlowGridSizeFlagsNV supported_hint_grid_sizes;
    bool hint_supported;
    bool cost_supported;
    bool bidirectional_flow_supported;
    bool global_flow_supported;
    u32 min_width;
    u32 min_height;
    u32 max_width;
    u32 max_height;
    u32 max_num_regions_of_interest;
    
    VkPhysicalDeviceOpticalFlowPropertiesNV raw() {
        return VkPhysicalDeviceOpticalFlowPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV,
            .pNext = nullptr,
            .supportedOutputGridSizes = supported_output_grid_sizes,
            .supportedHintGridSizes = supported_hint_grid_sizes,
            .hintSupported = static_cast<VkBool32>(hint_supported),
            .costSupported = static_cast<VkBool32>(cost_supported),
            .bidirectionalFlowSupported = static_cast<VkBool32>(bidirectional_flow_supported),
            .globalFlowSupported = static_cast<VkBool32>(global_flow_supported),
            .minWidth = min_width,
            .minHeight = min_height,
            .maxWidth = max_width,
            .maxHeight = max_height,
            .maxNumRegionsOfInterest = max_num_regions_of_interest
        };
    }
};

struct PhysicalDevicePCIBusInfoPropertiesEXT {
    u32 pci_domain;
    u32 pci_bus;
    u32 pci_device;
    u32 pci_function;
    
    VkPhysicalDevicePCIBusInfoPropertiesEXT raw() {
        return VkPhysicalDevicePCIBusInfoPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PCIBUS_INFO_PROPERTIES_EXT,
            .pNext = nullptr,
            .pciDomain = pci_domain,
            .pciBus = pci_bus,
            .pciDevice = pci_device,
            .pciFunction = pci_function
        };
    }
};

struct PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
    bool pageable_device_local_memory;
    
    VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT raw() {
        return VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT,
            .pNext = nullptr,
            .pageableDeviceLocalMemory = static_cast<VkBool32>(pageable_device_local_memory)
        };
    }
};

struct PhysicalDevicePartitionedAccelerationStructureFeaturesNV {
    bool partitioned_acceleration_structure;
    
    VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV raw() {
        return VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV,
            .pNext = nullptr,
            .partitionedAccelerationStructure = static_cast<VkBool32>(partitioned_acceleration_structure)
        };
    }
};

struct PhysicalDevicePartitionedAccelerationStructurePropertiesNV {
    u32 max_partition_count;
    
    VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV raw() {
        return VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV,
            .pNext = nullptr,
            .maxPartitionCount = max_partition_count
        };
    }
};

struct PhysicalDevicePerStageDescriptorSetFeaturesNV {
    bool per_stage_descriptor_set;
    bool dynamic_pipeline_layout;
    
    VkPhysicalDevicePerStageDescriptorSetFeaturesNV raw() {
        return VkPhysicalDevicePerStageDescriptorSetFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV,
            .pNext = nullptr,
            .perStageDescriptorSet = static_cast<VkBool32>(per_stage_descriptor_set),
            .dynamicPipelineLayout = static_cast<VkBool32>(dynamic_pipeline_layout)
        };
    }
};

struct PhysicalDevicePerformanceQueryFeaturesKHR {
    bool performance_counter_query_pools;
    bool performance_counter_multiple_query_pools;
    
    VkPhysicalDevicePerformanceQueryFeaturesKHR raw() {
        return VkPhysicalDevicePerformanceQueryFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR,
            .pNext = nullptr,
            .performanceCounterQueryPools = static_cast<VkBool32>(performance_counter_query_pools),
            .performanceCounterMultipleQueryPools = static_cast<VkBool32>(performance_counter_multiple_query_pools)
        };
    }
};

struct PhysicalDevicePerformanceQueryPropertiesKHR {
    bool allow_command_buffer_query_copies;
    
    VkPhysicalDevicePerformanceQueryPropertiesKHR raw() {
        return VkPhysicalDevicePerformanceQueryPropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR,
            .pNext = nullptr,
            .allowCommandBufferQueryCopies = static_cast<VkBool32>(allow_command_buffer_query_copies)
        };
    }
};

struct PhysicalDevicePipelineBinaryFeaturesKHR {
    bool pipeline_binaries;
    
    VkPhysicalDevicePipelineBinaryFeaturesKHR raw() {
        return VkPhysicalDevicePipelineBinaryFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR,
            .pNext = nullptr,
            .pipelineBinaries = static_cast<VkBool32>(pipeline_binaries)
        };
    }
};

struct PhysicalDevicePipelineBinaryPropertiesKHR {
    bool pipeline_binary_internal_cache;
    bool pipeline_binary_internal_cache_control;
    bool pipeline_binary_prefers_internal_cache;
    bool pipeline_binary_precompiled_internal_cache;
    bool pipeline_binary_compressed_data;
    
    VkPhysicalDevicePipelineBinaryPropertiesKHR raw() {
        return VkPhysicalDevicePipelineBinaryPropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR,
            .pNext = nullptr,
            .pipelineBinaryInternalCache = static_cast<VkBool32>(pipeline_binary_internal_cache),
            .pipelineBinaryInternalCacheControl = static_cast<VkBool32>(pipeline_binary_internal_cache_control),
            .pipelineBinaryPrefersInternalCache = static_cast<VkBool32>(pipeline_binary_prefers_internal_cache),
            .pipelineBinaryPrecompiledInternalCache = static_cast<VkBool32>(pipeline_binary_precompiled_internal_cache),
            .pipelineBinaryCompressedData = static_cast<VkBool32>(pipeline_binary_compressed_data)
        };
    }
};

struct PhysicalDevicePipelineCreationCacheControlFeatures {
    bool pipeline_creation_cache_control;
    
    VkPhysicalDevicePipelineCreationCacheControlFeatures raw() {
        return VkPhysicalDevicePipelineCreationCacheControlFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES,
            .pNext = nullptr,
            .pipelineCreationCacheControl = static_cast<VkBool32>(pipeline_creation_cache_control)
        };
    }
};

struct PhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
    bool pipeline_executable_info;
    
    VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR raw() {
        return VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR,
            .pNext = nullptr,
            .pipelineExecutableInfo = static_cast<VkBool32>(pipeline_executable_info)
        };
    }
};

struct PhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
    bool pipeline_library_group_handles;
    
    VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT raw() {
        return VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT,
            .pNext = nullptr,
            .pipelineLibraryGroupHandles = static_cast<VkBool32>(pipeline_library_group_handles)
        };
    }
};

struct PhysicalDevicePipelineOpacityMicromapFeaturesARM {
    bool pipeline_opacity_micromap;
    
    VkPhysicalDevicePipelineOpacityMicromapFeaturesARM raw() {
        return VkPhysicalDevicePipelineOpacityMicromapFeaturesARM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM,
            .pNext = nullptr,
            .pipelineOpacityMicromap = static_cast<VkBool32>(pipeline_opacity_micromap)
        };
    }
};

struct PhysicalDevicePipelinePropertiesFeaturesEXT {
    bool pipeline_properties_identifier;
    
    VkPhysicalDevicePipelinePropertiesFeaturesEXT raw() {
        return VkPhysicalDevicePipelinePropertiesFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT,
            .pNext = nullptr,
            .pipelinePropertiesIdentifier = static_cast<VkBool32>(pipeline_properties_identifier)
        };
    }
};

struct PhysicalDevicePipelineProtectedAccessFeatures {
    bool pipeline_protected_access;
    
    VkPhysicalDevicePipelineProtectedAccessFeatures raw() {
        return VkPhysicalDevicePipelineProtectedAccessFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES,
            .pNext = nullptr,
            .pipelineProtectedAccess = static_cast<VkBool32>(pipeline_protected_access)
        };
    }
};

struct PhysicalDevicePipelineRobustnessFeatures {
    bool pipeline_robustness;
    
    VkPhysicalDevicePipelineRobustnessFeatures raw() {
        return VkPhysicalDevicePipelineRobustnessFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES,
            .pNext = nullptr,
            .pipelineRobustness = static_cast<VkBool32>(pipeline_robustness)
        };
    }
};

struct PhysicalDevicePipelineRobustnessProperties {
    PipelineRobustnessBufferBehavior default_robustness_storage_buffers;
    PipelineRobustnessBufferBehavior default_robustness_uniform_buffers;
    PipelineRobustnessBufferBehavior default_robustness_vertex_inputs;
    PipelineRobustnessImageBehavior default_robustness_images;
    
    VkPhysicalDevicePipelineRobustnessProperties raw() {
        return VkPhysicalDevicePipelineRobustnessProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES,
            .pNext = nullptr,
            .defaultRobustnessStorageBuffers = static_cast<VkPipelineRobustnessBufferBehavior>(default_robustness_storage_buffers),
            .defaultRobustnessUniformBuffers = static_cast<VkPipelineRobustnessBufferBehavior>(default_robustness_uniform_buffers),
            .defaultRobustnessVertexInputs = static_cast<VkPipelineRobustnessBufferBehavior>(default_robustness_vertex_inputs),
            .defaultRobustnessImages = static_cast<VkPipelineRobustnessImageBehavior>(default_robustness_images)
        };
    }
};

struct PhysicalDevicePointClippingProperties {
    PointClippingBehavior point_clipping_behavior;
    
    VkPhysicalDevicePointClippingProperties raw() {
        return VkPhysicalDevicePointClippingProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
            .pNext = nullptr,
            .pointClippingBehavior = static_cast<VkPointClippingBehavior>(point_clipping_behavior)
        };
    }
};

struct PhysicalDevicePresentBarrierFeaturesNV {
    bool present_barrier;
    
    VkPhysicalDevicePresentBarrierFeaturesNV raw() {
        return VkPhysicalDevicePresentBarrierFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV,
            .pNext = nullptr,
            .presentBarrier = static_cast<VkBool32>(present_barrier)
        };
    }
};

struct PhysicalDevicePresentIdFeaturesKHR {
    bool present_id;
    
    VkPhysicalDevicePresentIdFeaturesKHR raw() {
        return VkPhysicalDevicePresentIdFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR,
            .pNext = nullptr,
            .presentId = static_cast<VkBool32>(present_id)
        };
    }
};

struct PhysicalDevicePresentMeteringFeaturesNV {
    bool present_metering;
    
    VkPhysicalDevicePresentMeteringFeaturesNV raw() {
        return VkPhysicalDevicePresentMeteringFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV,
            .pNext = nullptr,
            .presentMetering = static_cast<VkBool32>(present_metering)
        };
    }
};

struct PhysicalDevicePresentModeFifoLatestReadyFeaturesEXT {
    bool present_mode_fifo_latest_ready;
    
    VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT raw() {
        return VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT,
            .pNext = nullptr,
            .presentModeFifoLatestReady = static_cast<VkBool32>(present_mode_fifo_latest_ready)
        };
    }
};

struct PhysicalDevicePresentWaitFeaturesKHR {
    bool present_wait;
    
    VkPhysicalDevicePresentWaitFeaturesKHR raw() {
        return VkPhysicalDevicePresentWaitFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR,
            .pNext = nullptr,
            .presentWait = static_cast<VkBool32>(present_wait)
        };
    }
};

struct PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
    bool primitive_topology_list_restart;
    bool primitive_topology_patch_list_restart;
    
    VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT raw() {
        return VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT,
            .pNext = nullptr,
            .primitiveTopologyListRestart = static_cast<VkBool32>(primitive_topology_list_restart),
            .primitiveTopologyPatchListRestart = static_cast<VkBool32>(primitive_topology_patch_list_restart)
        };
    }
};

struct PhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
    bool primitives_generated_query;
    bool primitives_generated_query_with_rasterizer_discard;
    bool primitives_generated_query_with_non_zero_streams;
    
    VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT raw() {
        return VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT,
            .pNext = nullptr,
            .primitivesGeneratedQuery = static_cast<VkBool32>(primitives_generated_query),
            .primitivesGeneratedQueryWithRasterizerDiscard = static_cast<VkBool32>(primitives_generated_query_with_rasterizer_discard),
            .primitivesGeneratedQueryWithNonZeroStreams = static_cast<VkBool32>(primitives_generated_query_with_non_zero_streams)
        };
    }
};

struct PhysicalDevicePrivateDataFeatures {
    bool private_data;
    
    VkPhysicalDevicePrivateDataFeatures raw() {
        return VkPhysicalDevicePrivateDataFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES,
            .pNext = nullptr,
            .privateData = static_cast<VkBool32>(private_data)
        };
    }
};

struct PhysicalDeviceProperties {
    u32 api_version;
    u32 driver_version;
    u32 vendor_id;
    u32 device_id;
    PhysicalDeviceType device_type;
    char[] vk_max_physical_device_name_size;
    uint8_t[] vk_uuid_size;
    PhysicalDeviceLimits limits;
    PhysicalDeviceSparseProperties sparse_properties;
    
    VkPhysicalDeviceProperties raw() {
        return VkPhysicalDeviceProperties {
            .apiVersion = api_version,
            .driverVersion = driver_version,
            .vendorID = vendor_id,
            .deviceID = device_id,
            .deviceType = static_cast<VkPhysicalDeviceType>(device_type),
            .VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = vk_max_physical_device_name_size,
            .VK_UUID_SIZE = vk_uuid_size,
            .limits = limits.raw(),
            .sparseProperties = sparse_properties.raw()
        };
    }
};

struct PhysicalDeviceProperties2 {
    PhysicalDeviceProperties properties;
    
    VkPhysicalDeviceProperties2 raw() {
        return VkPhysicalDeviceProperties2 {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PROPERTIES2,
            .pNext = nullptr,
            .properties = properties.raw()
        };
    }
};

struct PhysicalDeviceProtectedMemoryFeatures {
    bool protected_memory;
    
    VkPhysicalDeviceProtectedMemoryFeatures raw() {
        return VkPhysicalDeviceProtectedMemoryFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES,
            .pNext = nullptr,
            .protectedMemory = static_cast<VkBool32>(protected_memory)
        };
    }
};

struct PhysicalDeviceProtectedMemoryProperties {
    bool protected_no_fault;
    
    VkPhysicalDeviceProtectedMemoryProperties raw() {
        return VkPhysicalDeviceProtectedMemoryProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES,
            .pNext = nullptr,
            .protectedNoFault = static_cast<VkBool32>(protected_no_fault)
        };
    }
};

struct PhysicalDeviceProvokingVertexFeaturesEXT {
    bool provoking_vertex_last;
    bool transform_feedback_preserves_provoking_vertex;
    
    VkPhysicalDeviceProvokingVertexFeaturesEXT raw() {
        return VkPhysicalDeviceProvokingVertexFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT,
            .pNext = nullptr,
            .provokingVertexLast = static_cast<VkBool32>(provoking_vertex_last),
            .transformFeedbackPreservesProvokingVertex = static_cast<VkBool32>(transform_feedback_preserves_provoking_vertex)
        };
    }
};

struct PhysicalDeviceProvokingVertexPropertiesEXT {
    bool provoking_vertex_mode_per_pipeline;
    bool transform_feedback_preserves_triangle_fan_provoking_vertex;
    
    VkPhysicalDeviceProvokingVertexPropertiesEXT raw() {
        return VkPhysicalDeviceProvokingVertexPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT,
            .pNext = nullptr,
            .provokingVertexModePerPipeline = static_cast<VkBool32>(provoking_vertex_mode_per_pipeline),
            .transformFeedbackPreservesTriangleFanProvokingVertex = static_cast<VkBool32>(transform_feedback_preserves_triangle_fan_provoking_vertex)
        };
    }
};

struct PhysicalDevicePushDescriptorProperties {
    u32 max_push_descriptors;
    
    VkPhysicalDevicePushDescriptorProperties raw() {
        return VkPhysicalDevicePushDescriptorProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES,
            .pNext = nullptr,
            .maxPushDescriptors = max_push_descriptors
        };
    }
};

struct PhysicalDeviceRGBA10X6FormatsFeaturesEXT {
    bool format_rgba10x6without_ycb_cr_sampler;
    
    VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT raw() {
        return VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RGBA10X6FORMATS_FEATURES_EXT,
            .pNext = nullptr,
            .formatRgba10x6WithoutYCbCrSampler = static_cast<VkBool32>(format_rgba10x6without_ycb_cr_sampler)
        };
    }
};

struct PhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
    bool rasterization_order_color_attachment_access;
    bool rasterization_order_depth_attachment_access;
    bool rasterization_order_stencil_attachment_access;
    
    VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT raw() {
        return VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT,
            .pNext = nullptr,
            .rasterizationOrderColorAttachmentAccess = static_cast<VkBool32>(rasterization_order_color_attachment_access),
            .rasterizationOrderDepthAttachmentAccess = static_cast<VkBool32>(rasterization_order_depth_attachment_access),
            .rasterizationOrderStencilAttachmentAccess = static_cast<VkBool32>(rasterization_order_stencil_attachment_access)
        };
    }
};

struct PhysicalDeviceRawAccessChainsFeaturesNV {
    bool shader_raw_access_chains;
    
    VkPhysicalDeviceRawAccessChainsFeaturesNV raw() {
        return VkPhysicalDeviceRawAccessChainsFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV,
            .pNext = nullptr,
            .shaderRawAccessChains = static_cast<VkBool32>(shader_raw_access_chains)
        };
    }
};

struct PhysicalDeviceRayQueryFeaturesKHR {
    bool ray_query;
    
    VkPhysicalDeviceRayQueryFeaturesKHR raw() {
        return VkPhysicalDeviceRayQueryFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR,
            .pNext = nullptr,
            .rayQuery = static_cast<VkBool32>(ray_query)
        };
    }
};

struct PhysicalDeviceRayTracingInvocationReorderFeaturesNV {
    bool ray_tracing_invocation_reorder;
    
    VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV raw() {
        return VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV,
            .pNext = nullptr,
            .rayTracingInvocationReorder = static_cast<VkBool32>(ray_tracing_invocation_reorder)
        };
    }
};

struct PhysicalDeviceRayTracingInvocationReorderPropertiesNV {
    RayTracingInvocationReorderModeNV ray_tracing_invocation_reorder_reordering_hint;
    
    VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV raw() {
        return VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV,
            .pNext = nullptr,
            .rayTracingInvocationReorderReorderingHint = static_cast<VkRayTracingInvocationReorderModeNV>(ray_tracing_invocation_reorder_reordering_hint)
        };
    }
};

struct PhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV {
    bool spheres;
    bool linear_swept_spheres;
    
    VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV raw() {
        return VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV,
            .pNext = nullptr,
            .spheres = static_cast<VkBool32>(spheres),
            .linearSweptSpheres = static_cast<VkBool32>(linear_swept_spheres)
        };
    }
};

struct PhysicalDeviceRayTracingMaintenance1FeaturesKHR {
    bool ray_tracing_maintenance1;
    bool ray_tracing_pipeline_trace_rays_indirect2;
    
    VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR raw() {
        return VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE1FEATURES_KHR,
            .pNext = nullptr,
            .rayTracingMaintenance1 = static_cast<VkBool32>(ray_tracing_maintenance1),
            .rayTracingPipelineTraceRaysIndirect2 = static_cast<VkBool32>(ray_tracing_pipeline_trace_rays_indirect2)
        };
    }
};

struct PhysicalDeviceRayTracingMotionBlurFeaturesNV {
    bool ray_tracing_motion_blur;
    bool ray_tracing_motion_blur_pipeline_trace_rays_indirect;
    
    VkPhysicalDeviceRayTracingMotionBlurFeaturesNV raw() {
        return VkPhysicalDeviceRayTracingMotionBlurFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV,
            .pNext = nullptr,
            .rayTracingMotionBlur = static_cast<VkBool32>(ray_tracing_motion_blur),
            .rayTracingMotionBlurPipelineTraceRaysIndirect = static_cast<VkBool32>(ray_tracing_motion_blur_pipeline_trace_rays_indirect)
        };
    }
};

struct PhysicalDeviceRayTracingPipelineFeaturesKHR {
    bool ray_tracing_pipeline;
    bool ray_tracing_pipeline_shader_group_handle_capture_replay;
    bool ray_tracing_pipeline_shader_group_handle_capture_replay_mixed;
    bool ray_tracing_pipeline_trace_rays_indirect;
    bool ray_traversal_primitive_culling;
    
    VkPhysicalDeviceRayTracingPipelineFeaturesKHR raw() {
        return VkPhysicalDeviceRayTracingPipelineFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,
            .pNext = nullptr,
            .rayTracingPipeline = static_cast<VkBool32>(ray_tracing_pipeline),
            .rayTracingPipelineShaderGroupHandleCaptureReplay = static_cast<VkBool32>(ray_tracing_pipeline_shader_group_handle_capture_replay),
            .rayTracingPipelineShaderGroupHandleCaptureReplayMixed = static_cast<VkBool32>(ray_tracing_pipeline_shader_group_handle_capture_replay_mixed),
            .rayTracingPipelineTraceRaysIndirect = static_cast<VkBool32>(ray_tracing_pipeline_trace_rays_indirect),
            .rayTraversalPrimitiveCulling = static_cast<VkBool32>(ray_traversal_primitive_culling)
        };
    }
};

struct PhysicalDeviceRayTracingPipelinePropertiesKHR {
    u32 shader_group_handle_size;
    u32 max_ray_recursion_depth;
    u32 max_shader_group_stride;
    u32 shader_group_base_alignment;
    u32 shader_group_handle_capture_replay_size;
    u32 max_ray_dispatch_invocation_count;
    u32 shader_group_handle_alignment;
    u32 max_ray_hit_attribute_size;
    
    VkPhysicalDeviceRayTracingPipelinePropertiesKHR raw() {
        return VkPhysicalDeviceRayTracingPipelinePropertiesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,
            .pNext = nullptr,
            .shaderGroupHandleSize = shader_group_handle_size,
            .maxRayRecursionDepth = max_ray_recursion_depth,
            .maxShaderGroupStride = max_shader_group_stride,
            .shaderGroupBaseAlignment = shader_group_base_alignment,
            .shaderGroupHandleCaptureReplaySize = shader_group_handle_capture_replay_size,
            .maxRayDispatchInvocationCount = max_ray_dispatch_invocation_count,
            .shaderGroupHandleAlignment = shader_group_handle_alignment,
            .maxRayHitAttributeSize = max_ray_hit_attribute_size
        };
    }
};

struct PhysicalDeviceRayTracingPositionFetchFeaturesKHR {
    bool ray_tracing_position_fetch;
    
    VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR raw() {
        return VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR,
            .pNext = nullptr,
            .rayTracingPositionFetch = static_cast<VkBool32>(ray_tracing_position_fetch)
        };
    }
};

struct PhysicalDeviceRayTracingPropertiesNV {
    u32 shader_group_handle_size;
    u32 max_recursion_depth;
    u32 max_shader_group_stride;
    u32 shader_group_base_alignment;
    uint64_t max_geometry_count;
    uint64_t max_instance_count;
    uint64_t max_triangle_count;
    u32 max_descriptor_set_acceleration_structures;
    
    VkPhysicalDeviceRayTracingPropertiesNV raw() {
        return VkPhysicalDeviceRayTracingPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV,
            .pNext = nullptr,
            .shaderGroupHandleSize = shader_group_handle_size,
            .maxRecursionDepth = max_recursion_depth,
            .maxShaderGroupStride = max_shader_group_stride,
            .shaderGroupBaseAlignment = shader_group_base_alignment,
            .maxGeometryCount = max_geometry_count,
            .maxInstanceCount = max_instance_count,
            .maxTriangleCount = max_triangle_count,
            .maxDescriptorSetAccelerationStructures = max_descriptor_set_acceleration_structures
        };
    }
};

struct PhysicalDeviceRayTracingValidationFeaturesNV {
    bool ray_tracing_validation;
    
    VkPhysicalDeviceRayTracingValidationFeaturesNV raw() {
        return VkPhysicalDeviceRayTracingValidationFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV,
            .pNext = nullptr,
            .rayTracingValidation = static_cast<VkBool32>(ray_tracing_validation)
        };
    }
};

struct PhysicalDeviceRelaxedLineRasterizationFeaturesIMG {
    bool relaxed_line_rasterization;
    
    VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG raw() {
        return VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG,
            .pNext = nullptr,
            .relaxedLineRasterization = static_cast<VkBool32>(relaxed_line_rasterization)
        };
    }
};

struct PhysicalDeviceRenderPassStripedFeaturesARM {
    bool render_pass_striped;
    
    VkPhysicalDeviceRenderPassStripedFeaturesARM raw() {
        return VkPhysicalDeviceRenderPassStripedFeaturesARM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM,
            .pNext = nullptr,
            .renderPassStriped = static_cast<VkBool32>(render_pass_striped)
        };
    }
};

struct PhysicalDeviceRenderPassStripedPropertiesARM {
    Extent2D render_pass_stripe_granularity;
    u32 max_render_pass_stripes;
    
    VkPhysicalDeviceRenderPassStripedPropertiesARM raw() {
        return VkPhysicalDeviceRenderPassStripedPropertiesARM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM,
            .pNext = nullptr,
            .renderPassStripeGranularity = render_pass_stripe_granularity.raw(),
            .maxRenderPassStripes = max_render_pass_stripes
        };
    }
};

struct PhysicalDeviceRepresentativeFragmentTestFeaturesNV {
    bool representative_fragment_test;
    
    VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV raw() {
        return VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV,
            .pNext = nullptr,
            .representativeFragmentTest = static_cast<VkBool32>(representative_fragment_test)
        };
    }
};

struct PhysicalDeviceRobustness2FeaturesEXT {
    bool robust_buffer_access2;
    bool robust_image_access2;
    bool null_descriptor;
    
    VkPhysicalDeviceRobustness2FeaturesEXT raw() {
        return VkPhysicalDeviceRobustness2FeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_ROBUSTNESS2FEATURES_EXT,
            .pNext = nullptr,
            .robustBufferAccess2 = static_cast<VkBool32>(robust_buffer_access2),
            .robustImageAccess2 = static_cast<VkBool32>(robust_image_access2),
            .nullDescriptor = static_cast<VkBool32>(null_descriptor)
        };
    }
};

struct PhysicalDeviceRobustness2PropertiesEXT {
    VkDeviceSize robust_storage_buffer_access_size_alignment;
    VkDeviceSize robust_uniform_buffer_access_size_alignment;
    
    VkPhysicalDeviceRobustness2PropertiesEXT raw() {
        return VkPhysicalDeviceRobustness2PropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_ROBUSTNESS2PROPERTIES_EXT,
            .pNext = nullptr,
            .robustStorageBufferAccessSizeAlignment = robust_storage_buffer_access_size_alignment,
            .robustUniformBufferAccessSizeAlignment = robust_uniform_buffer_access_size_alignment
        };
    }
};

struct PhysicalDeviceSampleLocationsPropertiesEXT {
    VkSampleCountFlags sample_location_sample_counts;
    Extent2D max_sample_location_grid_size;
    float[2] sample_location_coordinate_range;
    u32 sample_location_sub_pixel_bits;
    bool variable_sample_locations;
    
    VkPhysicalDeviceSampleLocationsPropertiesEXT raw() {
        return VkPhysicalDeviceSampleLocationsPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT,
            .pNext = nullptr,
            .sampleLocationSampleCounts = sample_location_sample_counts,
            .maxSampleLocationGridSize = max_sample_location_grid_size.raw(),
            .sampleLocationCoordinateRange = sample_location_coordinate_range,
            .sampleLocationSubPixelBits = sample_location_sub_pixel_bits,
            .variableSampleLocations = static_cast<VkBool32>(variable_sample_locations)
        };
    }
};

struct PhysicalDeviceSamplerFilterMinmaxProperties {
    bool filter_minmax_single_component_formats;
    bool filter_minmax_image_component_mapping;
    
    VkPhysicalDeviceSamplerFilterMinmaxProperties raw() {
        return VkPhysicalDeviceSamplerFilterMinmaxProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES,
            .pNext = nullptr,
            .filterMinmaxSingleComponentFormats = static_cast<VkBool32>(filter_minmax_single_component_formats),
            .filterMinmaxImageComponentMapping = static_cast<VkBool32>(filter_minmax_image_component_mapping)
        };
    }
};

struct PhysicalDeviceSamplerYcbcrConversionFeatures {
    bool sampler_ycbcr_conversion;
    
    VkPhysicalDeviceSamplerYcbcrConversionFeatures raw() {
        return VkPhysicalDeviceSamplerYcbcrConversionFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
            .pNext = nullptr,
            .samplerYcbcrConversion = static_cast<VkBool32>(sampler_ycbcr_conversion)
        };
    }
};

struct PhysicalDeviceScalarBlockLayoutFeatures {
    bool scalar_block_layout;
    
    VkPhysicalDeviceScalarBlockLayoutFeatures raw() {
        return VkPhysicalDeviceScalarBlockLayoutFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES,
            .pNext = nullptr,
            .scalarBlockLayout = static_cast<VkBool32>(scalar_block_layout)
        };
    }
};

struct PhysicalDeviceSchedulingControlsFeaturesARM {
    bool scheduling_controls;
    
    VkPhysicalDeviceSchedulingControlsFeaturesARM raw() {
        return VkPhysicalDeviceSchedulingControlsFeaturesARM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM,
            .pNext = nullptr,
            .schedulingControls = static_cast<VkBool32>(scheduling_controls)
        };
    }
};

struct PhysicalDeviceSchedulingControlsPropertiesARM {
    VkPhysicalDeviceSchedulingControlsFlagsARM scheduling_controls_flags;
    
    VkPhysicalDeviceSchedulingControlsPropertiesARM raw() {
        return VkPhysicalDeviceSchedulingControlsPropertiesARM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM,
            .pNext = nullptr,
            .schedulingControlsFlags = scheduling_controls_flags
        };
    }
};

struct PhysicalDeviceSeparateDepthStencilLayoutsFeatures {
    bool separate_depth_stencil_layouts;
    
    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures raw() {
        return VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES,
            .pNext = nullptr,
            .separateDepthStencilLayouts = static_cast<VkBool32>(separate_depth_stencil_layouts)
        };
    }
};

struct PhysicalDeviceShaderAtomicFloat16VectorFeaturesNV {
    bool shader_float16vector_atomics;
    
    VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV raw() {
        return VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16VECTOR_FEATURES_NV,
            .pNext = nullptr,
            .shaderFloat16VectorAtomics = static_cast<VkBool32>(shader_float16vector_atomics)
        };
    }
};

struct PhysicalDeviceShaderAtomicFloat2FeaturesEXT {
    bool shader_buffer_float16atomics;
    bool shader_buffer_float16atomic_add;
    bool shader_buffer_float16atomic_min_max;
    bool shader_buffer_float32atomic_min_max;
    bool shader_buffer_float64atomic_min_max;
    bool shader_shared_float16atomics;
    bool shader_shared_float16atomic_add;
    bool shader_shared_float16atomic_min_max;
    bool shader_shared_float32atomic_min_max;
    bool shader_shared_float64atomic_min_max;
    bool shader_image_float32atomic_min_max;
    bool sparse_image_float32atomic_min_max;
    
    VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT raw() {
        return VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT2FEATURES_EXT,
            .pNext = nullptr,
            .shaderBufferFloat16Atomics = static_cast<VkBool32>(shader_buffer_float16atomics),
            .shaderBufferFloat16AtomicAdd = static_cast<VkBool32>(shader_buffer_float16atomic_add),
            .shaderBufferFloat16AtomicMinMax = static_cast<VkBool32>(shader_buffer_float16atomic_min_max),
            .shaderBufferFloat32AtomicMinMax = static_cast<VkBool32>(shader_buffer_float32atomic_min_max),
            .shaderBufferFloat64AtomicMinMax = static_cast<VkBool32>(shader_buffer_float64atomic_min_max),
            .shaderSharedFloat16Atomics = static_cast<VkBool32>(shader_shared_float16atomics),
            .shaderSharedFloat16AtomicAdd = static_cast<VkBool32>(shader_shared_float16atomic_add),
            .shaderSharedFloat16AtomicMinMax = static_cast<VkBool32>(shader_shared_float16atomic_min_max),
            .shaderSharedFloat32AtomicMinMax = static_cast<VkBool32>(shader_shared_float32atomic_min_max),
            .shaderSharedFloat64AtomicMinMax = static_cast<VkBool32>(shader_shared_float64atomic_min_max),
            .shaderImageFloat32AtomicMinMax = static_cast<VkBool32>(shader_image_float32atomic_min_max),
            .sparseImageFloat32AtomicMinMax = static_cast<VkBool32>(sparse_image_float32atomic_min_max)
        };
    }
};

struct PhysicalDeviceShaderAtomicFloatFeaturesEXT {
    bool shader_buffer_float32atomics;
    bool shader_buffer_float32atomic_add;
    bool shader_buffer_float64atomics;
    bool shader_buffer_float64atomic_add;
    bool shader_shared_float32atomics;
    bool shader_shared_float32atomic_add;
    bool shader_shared_float64atomics;
    bool shader_shared_float64atomic_add;
    bool shader_image_float32atomics;
    bool shader_image_float32atomic_add;
    bool sparse_image_float32atomics;
    bool sparse_image_float32atomic_add;
    
    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT raw() {
        return VkPhysicalDeviceShaderAtomicFloatFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT,
            .pNext = nullptr,
            .shaderBufferFloat32Atomics = static_cast<VkBool32>(shader_buffer_float32atomics),
            .shaderBufferFloat32AtomicAdd = static_cast<VkBool32>(shader_buffer_float32atomic_add),
            .shaderBufferFloat64Atomics = static_cast<VkBool32>(shader_buffer_float64atomics),
            .shaderBufferFloat64AtomicAdd = static_cast<VkBool32>(shader_buffer_float64atomic_add),
            .shaderSharedFloat32Atomics = static_cast<VkBool32>(shader_shared_float32atomics),
            .shaderSharedFloat32AtomicAdd = static_cast<VkBool32>(shader_shared_float32atomic_add),
            .shaderSharedFloat64Atomics = static_cast<VkBool32>(shader_shared_float64atomics),
            .shaderSharedFloat64AtomicAdd = static_cast<VkBool32>(shader_shared_float64atomic_add),
            .shaderImageFloat32Atomics = static_cast<VkBool32>(shader_image_float32atomics),
            .shaderImageFloat32AtomicAdd = static_cast<VkBool32>(shader_image_float32atomic_add),
            .sparseImageFloat32Atomics = static_cast<VkBool32>(sparse_image_float32atomics),
            .sparseImageFloat32AtomicAdd = static_cast<VkBool32>(sparse_image_float32atomic_add)
        };
    }
};

struct PhysicalDeviceShaderAtomicInt64Features {
    bool shader_buffer_int64atomics;
    bool shader_shared_int64atomics;
    
    VkPhysicalDeviceShaderAtomicInt64Features raw() {
        return VkPhysicalDeviceShaderAtomicInt64Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64FEATURES,
            .pNext = nullptr,
            .shaderBufferInt64Atomics = static_cast<VkBool32>(shader_buffer_int64atomics),
            .shaderSharedInt64Atomics = static_cast<VkBool32>(shader_shared_int64atomics)
        };
    }
};

struct PhysicalDeviceShaderBfloat16FeaturesKHR {
    bool shader_bfloat16type;
    bool shader_bfloat16dot_product;
    bool shader_bfloat16cooperative_matrix;
    
    VkPhysicalDeviceShaderBfloat16FeaturesKHR raw() {
        return VkPhysicalDeviceShaderBfloat16FeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16FEATURES_KHR,
            .pNext = nullptr,
            .shaderBFloat16Type = static_cast<VkBool32>(shader_bfloat16type),
            .shaderBFloat16DotProduct = static_cast<VkBool32>(shader_bfloat16dot_product),
            .shaderBFloat16CooperativeMatrix = static_cast<VkBool32>(shader_bfloat16cooperative_matrix)
        };
    }
};

struct PhysicalDeviceShaderClockFeaturesKHR {
    bool shader_subgroup_clock;
    bool shader_device_clock;
    
    VkPhysicalDeviceShaderClockFeaturesKHR raw() {
        return VkPhysicalDeviceShaderClockFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR,
            .pNext = nullptr,
            .shaderSubgroupClock = static_cast<VkBool32>(shader_subgroup_clock),
            .shaderDeviceClock = static_cast<VkBool32>(shader_device_clock)
        };
    }
};

struct PhysicalDeviceShaderCoreBuiltinsFeaturesARM {
    bool shader_core_builtins;
    
    VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM raw() {
        return VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM,
            .pNext = nullptr,
            .shaderCoreBuiltins = static_cast<VkBool32>(shader_core_builtins)
        };
    }
};

struct PhysicalDeviceShaderCoreBuiltinsPropertiesARM {
    uint64_t shader_core_mask;
    u32 shader_core_count;
    u32 shader_warps_per_core;
    
    VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM raw() {
        return VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM,
            .pNext = nullptr,
            .shaderCoreMask = shader_core_mask,
            .shaderCoreCount = shader_core_count,
            .shaderWarpsPerCore = shader_warps_per_core
        };
    }
};

struct PhysicalDeviceShaderCoreProperties2AMD {
    VkShaderCorePropertiesFlagsAMD shader_core_features;
    u32 active_compute_unit_count;
    
    VkPhysicalDeviceShaderCoreProperties2AMD raw() {
        return VkPhysicalDeviceShaderCoreProperties2AMD {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES2AMD,
            .pNext = nullptr,
            .shaderCoreFeatures = shader_core_features,
            .activeComputeUnitCount = active_compute_unit_count
        };
    }
};

struct PhysicalDeviceShaderCorePropertiesAMD {
    u32 shader_engine_count;
    u32 shader_arrays_per_engine_count;
    u32 compute_units_per_shader_array;
    u32 simd_per_compute_unit;
    u32 wavefronts_per_simd;
    u32 wavefront_size;
    u32 sgprs_per_simd;
    u32 min_sgpr_allocation;
    u32 max_sgpr_allocation;
    u32 sgpr_allocation_granularity;
    u32 vgprs_per_simd;
    u32 min_vgpr_allocation;
    u32 max_vgpr_allocation;
    u32 vgpr_allocation_granularity;
    
    VkPhysicalDeviceShaderCorePropertiesAMD raw() {
        return VkPhysicalDeviceShaderCorePropertiesAMD {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD,
            .pNext = nullptr,
            .shaderEngineCount = shader_engine_count,
            .shaderArraysPerEngineCount = shader_arrays_per_engine_count,
            .computeUnitsPerShaderArray = compute_units_per_shader_array,
            .simdPerComputeUnit = simd_per_compute_unit,
            .wavefrontsPerSimd = wavefronts_per_simd,
            .wavefrontSize = wavefront_size,
            .sgprsPerSimd = sgprs_per_simd,
            .minSgprAllocation = min_sgpr_allocation,
            .maxSgprAllocation = max_sgpr_allocation,
            .sgprAllocationGranularity = sgpr_allocation_granularity,
            .vgprsPerSimd = vgprs_per_simd,
            .minVgprAllocation = min_vgpr_allocation,
            .maxVgprAllocation = max_vgpr_allocation,
            .vgprAllocationGranularity = vgpr_allocation_granularity
        };
    }
};

struct PhysicalDeviceShaderCorePropertiesARM {
    u32 pixel_rate;
    u32 texel_rate;
    u32 fma_rate;
    
    VkPhysicalDeviceShaderCorePropertiesARM raw() {
        return VkPhysicalDeviceShaderCorePropertiesARM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM,
            .pNext = nullptr,
            .pixelRate = pixel_rate,
            .texelRate = texel_rate,
            .fmaRate = fma_rate
        };
    }
};

struct PhysicalDeviceShaderDemoteToHelperInvocationFeatures {
    bool shader_demote_to_helper_invocation;
    
    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures raw() {
        return VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES,
            .pNext = nullptr,
            .shaderDemoteToHelperInvocation = static_cast<VkBool32>(shader_demote_to_helper_invocation)
        };
    }
};

struct PhysicalDeviceShaderDrawParametersFeatures {
    bool shader_draw_parameters;
    
    VkPhysicalDeviceShaderDrawParametersFeatures raw() {
        return VkPhysicalDeviceShaderDrawParametersFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES,
            .pNext = nullptr,
            .shaderDrawParameters = static_cast<VkBool32>(shader_draw_parameters)
        };
    }
};

struct PhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
    bool shader_early_and_late_fragment_tests;
    
    VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD raw() {
        return VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD,
            .pNext = nullptr,
            .shaderEarlyAndLateFragmentTests = static_cast<VkBool32>(shader_early_and_late_fragment_tests)
        };
    }
};

struct PhysicalDeviceShaderExpectAssumeFeatures {
    bool shader_expect_assume;
    
    VkPhysicalDeviceShaderExpectAssumeFeatures raw() {
        return VkPhysicalDeviceShaderExpectAssumeFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES,
            .pNext = nullptr,
            .shaderExpectAssume = static_cast<VkBool32>(shader_expect_assume)
        };
    }
};

struct PhysicalDeviceShaderFloat16Int8Features {
    bool shader_float16;
    bool shader_int8;
    
    VkPhysicalDeviceShaderFloat16Int8Features raw() {
        return VkPhysicalDeviceShaderFloat16Int8Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16INT8FEATURES,
            .pNext = nullptr,
            .shaderFloat16 = static_cast<VkBool32>(shader_float16),
            .shaderInt8 = static_cast<VkBool32>(shader_int8)
        };
    }
};

struct PhysicalDeviceShaderFloatControls2Features {
    bool shader_float_controls2;
    
    VkPhysicalDeviceShaderFloatControls2Features raw() {
        return VkPhysicalDeviceShaderFloatControls2Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS2FEATURES,
            .pNext = nullptr,
            .shaderFloatControls2 = static_cast<VkBool32>(shader_float_controls2)
        };
    }
};

struct PhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
    bool shader_image_int64atomics;
    bool sparse_image_int64atomics;
    
    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT raw() {
        return VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64FEATURES_EXT,
            .pNext = nullptr,
            .shaderImageInt64Atomics = static_cast<VkBool32>(shader_image_int64atomics),
            .sparseImageInt64Atomics = static_cast<VkBool32>(sparse_image_int64atomics)
        };
    }
};

struct PhysicalDeviceShaderImageFootprintFeaturesNV {
    bool image_footprint;
    
    VkPhysicalDeviceShaderImageFootprintFeaturesNV raw() {
        return VkPhysicalDeviceShaderImageFootprintFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV,
            .pNext = nullptr,
            .imageFootprint = static_cast<VkBool32>(image_footprint)
        };
    }
};

struct PhysicalDeviceShaderIntegerDotProductFeatures {
    bool shader_integer_dot_product;
    
    VkPhysicalDeviceShaderIntegerDotProductFeatures raw() {
        return VkPhysicalDeviceShaderIntegerDotProductFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES,
            .pNext = nullptr,
            .shaderIntegerDotProduct = static_cast<VkBool32>(shader_integer_dot_product)
        };
    }
};

struct PhysicalDeviceShaderIntegerDotProductProperties {
    bool integer_dot_product8bit_unsigned_accelerated;
    bool integer_dot_product8bit_signed_accelerated;
    bool integer_dot_product8bit_mixed_signedness_accelerated;
    bool integer_dot_product4x8bit_packed_unsigned_accelerated;
    bool integer_dot_product4x8bit_packed_signed_accelerated;
    bool integer_dot_product4x8bit_packed_mixed_signedness_accelerated;
    bool integer_dot_product16bit_unsigned_accelerated;
    bool integer_dot_product16bit_signed_accelerated;
    bool integer_dot_product16bit_mixed_signedness_accelerated;
    bool integer_dot_product32bit_unsigned_accelerated;
    bool integer_dot_product32bit_signed_accelerated;
    bool integer_dot_product32bit_mixed_signedness_accelerated;
    bool integer_dot_product64bit_unsigned_accelerated;
    bool integer_dot_product64bit_signed_accelerated;
    bool integer_dot_product64bit_mixed_signedness_accelerated;
    bool integer_dot_product_accumulating_saturating8bit_unsigned_accelerated;
    bool integer_dot_product_accumulating_saturating8bit_signed_accelerated;
    bool integer_dot_product_accumulating_saturating8bit_mixed_signedness_accelerated;
    bool integer_dot_product_accumulating_saturating4x8bit_packed_unsigned_accelerated;
    bool integer_dot_product_accumulating_saturating4x8bit_packed_signed_accelerated;
    bool integer_dot_product_accumulating_saturating4x8bit_packed_mixed_signedness_accelerated;
    bool integer_dot_product_accumulating_saturating16bit_unsigned_accelerated;
    bool integer_dot_product_accumulating_saturating16bit_signed_accelerated;
    bool integer_dot_product_accumulating_saturating16bit_mixed_signedness_accelerated;
    bool integer_dot_product_accumulating_saturating32bit_unsigned_accelerated;
    bool integer_dot_product_accumulating_saturating32bit_signed_accelerated;
    bool integer_dot_product_accumulating_saturating32bit_mixed_signedness_accelerated;
    bool integer_dot_product_accumulating_saturating64bit_unsigned_accelerated;
    bool integer_dot_product_accumulating_saturating64bit_signed_accelerated;
    bool integer_dot_product_accumulating_saturating64bit_mixed_signedness_accelerated;
    
    VkPhysicalDeviceShaderIntegerDotProductProperties raw() {
        return VkPhysicalDeviceShaderIntegerDotProductProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES,
            .pNext = nullptr,
            .integerDotProduct8BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product8bit_unsigned_accelerated),
            .integerDotProduct8BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product8bit_signed_accelerated),
            .integerDotProduct8BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product8bit_mixed_signedness_accelerated),
            .integerDotProduct4x8BitPackedUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product4x8bit_packed_unsigned_accelerated),
            .integerDotProduct4x8BitPackedSignedAccelerated = static_cast<VkBool32>(integer_dot_product4x8bit_packed_signed_accelerated),
            .integerDotProduct4x8BitPackedMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product4x8bit_packed_mixed_signedness_accelerated),
            .integerDotProduct16BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product16bit_unsigned_accelerated),
            .integerDotProduct16BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product16bit_signed_accelerated),
            .integerDotProduct16BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product16bit_mixed_signedness_accelerated),
            .integerDotProduct32BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product32bit_unsigned_accelerated),
            .integerDotProduct32BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product32bit_signed_accelerated),
            .integerDotProduct32BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product32bit_mixed_signedness_accelerated),
            .integerDotProduct64BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product64bit_unsigned_accelerated),
            .integerDotProduct64BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product64bit_signed_accelerated),
            .integerDotProduct64BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product64bit_mixed_signedness_accelerated),
            .integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating8bit_unsigned_accelerated),
            .integerDotProductAccumulatingSaturating8BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating8bit_signed_accelerated),
            .integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating8bit_mixed_signedness_accelerated),
            .integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating4x8bit_packed_unsigned_accelerated),
            .integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating4x8bit_packed_signed_accelerated),
            .integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating4x8bit_packed_mixed_signedness_accelerated),
            .integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating16bit_unsigned_accelerated),
            .integerDotProductAccumulatingSaturating16BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating16bit_signed_accelerated),
            .integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating16bit_mixed_signedness_accelerated),
            .integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating32bit_unsigned_accelerated),
            .integerDotProductAccumulatingSaturating32BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating32bit_signed_accelerated),
            .integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating32bit_mixed_signedness_accelerated),
            .integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating64bit_unsigned_accelerated),
            .integerDotProductAccumulatingSaturating64BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating64bit_signed_accelerated),
            .integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating64bit_mixed_signedness_accelerated)
        };
    }
};

struct PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
    bool shader_integer_functions2;
    
    VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL raw() {
        return VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS2FEATURES_INTEL,
            .pNext = nullptr,
            .shaderIntegerFunctions2 = static_cast<VkBool32>(shader_integer_functions2)
        };
    }
};

struct PhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {
    bool shader_maximal_reconvergence;
    
    VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR raw() {
        return VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR,
            .pNext = nullptr,
            .shaderMaximalReconvergence = static_cast<VkBool32>(shader_maximal_reconvergence)
        };
    }
};

struct PhysicalDeviceShaderModuleIdentifierFeaturesEXT {
    bool shader_module_identifier;
    
    VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT raw() {
        return VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT,
            .pNext = nullptr,
            .shaderModuleIdentifier = static_cast<VkBool32>(shader_module_identifier)
        };
    }
};

struct PhysicalDeviceShaderModuleIdentifierPropertiesEXT {
    uint8_t[] vk_uuid_size;
    
    VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT raw() {
        return VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT,
            .pNext = nullptr,
            .VK_UUID_SIZE = vk_uuid_size
        };
    }
};

struct PhysicalDeviceShaderObjectFeaturesEXT {
    bool shader_object;
    
    VkPhysicalDeviceShaderObjectFeaturesEXT raw() {
        return VkPhysicalDeviceShaderObjectFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT,
            .pNext = nullptr,
            .shaderObject = static_cast<VkBool32>(shader_object)
        };
    }
};

struct PhysicalDeviceShaderObjectPropertiesEXT {
    uint8_t[] vk_uuid_size;
    u32 shader_binary_version;
    
    VkPhysicalDeviceShaderObjectPropertiesEXT raw() {
        return VkPhysicalDeviceShaderObjectPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT,
            .pNext = nullptr,
            .VK_UUID_SIZE = vk_uuid_size,
            .shaderBinaryVersion = shader_binary_version
        };
    }
};

struct PhysicalDeviceShaderQuadControlFeaturesKHR {
    bool shader_quad_control;
    
    VkPhysicalDeviceShaderQuadControlFeaturesKHR raw() {
        return VkPhysicalDeviceShaderQuadControlFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR,
            .pNext = nullptr,
            .shaderQuadControl = static_cast<VkBool32>(shader_quad_control)
        };
    }
};

struct PhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR {
    bool shader_relaxed_extended_instruction;
    
    VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR raw() {
        return VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR,
            .pNext = nullptr,
            .shaderRelaxedExtendedInstruction = static_cast<VkBool32>(shader_relaxed_extended_instruction)
        };
    }
};

struct PhysicalDeviceShaderReplicatedCompositesFeaturesEXT {
    bool shader_replicated_composites;
    
    VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT raw() {
        return VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT,
            .pNext = nullptr,
            .shaderReplicatedComposites = static_cast<VkBool32>(shader_replicated_composites)
        };
    }
};

struct PhysicalDeviceShaderSMBuiltinsFeaturesNV {
    bool shader_smbuiltins;
    
    VkPhysicalDeviceShaderSMBuiltinsFeaturesNV raw() {
        return VkPhysicalDeviceShaderSMBuiltinsFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_SMBUILTINS_FEATURES_NV,
            .pNext = nullptr,
            .shaderSMBuiltins = static_cast<VkBool32>(shader_smbuiltins)
        };
    }
};

struct PhysicalDeviceShaderSMBuiltinsPropertiesNV {
    u32 shader_smcount;
    u32 shader_warps_per_sm;
    
    VkPhysicalDeviceShaderSMBuiltinsPropertiesNV raw() {
        return VkPhysicalDeviceShaderSMBuiltinsPropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_SMBUILTINS_PROPERTIES_NV,
            .pNext = nullptr,
            .shaderSMCount = shader_smcount,
            .shaderWarpsPerSM = shader_warps_per_sm
        };
    }
};

struct PhysicalDeviceShaderSubgroupExtendedTypesFeatures {
    bool shader_subgroup_extended_types;
    
    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures raw() {
        return VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES,
            .pNext = nullptr,
            .shaderSubgroupExtendedTypes = static_cast<VkBool32>(shader_subgroup_extended_types)
        };
    }
};

struct PhysicalDeviceShaderSubgroupRotateFeatures {
    bool shader_subgroup_rotate;
    bool shader_subgroup_rotate_clustered;
    
    VkPhysicalDeviceShaderSubgroupRotateFeatures raw() {
        return VkPhysicalDeviceShaderSubgroupRotateFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES,
            .pNext = nullptr,
            .shaderSubgroupRotate = static_cast<VkBool32>(shader_subgroup_rotate),
            .shaderSubgroupRotateClustered = static_cast<VkBool32>(shader_subgroup_rotate_clustered)
        };
    }
};

struct PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
    bool shader_subgroup_uniform_control_flow;
    
    VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR raw() {
        return VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR,
            .pNext = nullptr,
            .shaderSubgroupUniformControlFlow = static_cast<VkBool32>(shader_subgroup_uniform_control_flow)
        };
    }
};

struct PhysicalDeviceShaderTerminateInvocationFeatures {
    bool shader_terminate_invocation;
    
    VkPhysicalDeviceShaderTerminateInvocationFeatures raw() {
        return VkPhysicalDeviceShaderTerminateInvocationFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES,
            .pNext = nullptr,
            .shaderTerminateInvocation = static_cast<VkBool32>(shader_terminate_invocation)
        };
    }
};

struct PhysicalDeviceShaderTileImageFeaturesEXT {
    bool shader_tile_image_color_read_access;
    bool shader_tile_image_depth_read_access;
    bool shader_tile_image_stencil_read_access;
    
    VkPhysicalDeviceShaderTileImageFeaturesEXT raw() {
        return VkPhysicalDeviceShaderTileImageFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT,
            .pNext = nullptr,
            .shaderTileImageColorReadAccess = static_cast<VkBool32>(shader_tile_image_color_read_access),
            .shaderTileImageDepthReadAccess = static_cast<VkBool32>(shader_tile_image_depth_read_access),
            .shaderTileImageStencilReadAccess = static_cast<VkBool32>(shader_tile_image_stencil_read_access)
        };
    }
};

struct PhysicalDeviceShaderTileImagePropertiesEXT {
    bool shader_tile_image_coherent_read_accelerated;
    bool shader_tile_image_read_sample_from_pixel_rate_invocation;
    bool shader_tile_image_read_from_helper_invocation;
    
    VkPhysicalDeviceShaderTileImagePropertiesEXT raw() {
        return VkPhysicalDeviceShaderTileImagePropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT,
            .pNext = nullptr,
            .shaderTileImageCoherentReadAccelerated = static_cast<VkBool32>(shader_tile_image_coherent_read_accelerated),
            .shaderTileImageReadSampleFromPixelRateInvocation = static_cast<VkBool32>(shader_tile_image_read_sample_from_pixel_rate_invocation),
            .shaderTileImageReadFromHelperInvocation = static_cast<VkBool32>(shader_tile_image_read_from_helper_invocation)
        };
    }
};

struct PhysicalDeviceShadingRateImageFeaturesNV {
    bool shading_rate_image;
    bool shading_rate_coarse_sample_order;
    
    VkPhysicalDeviceShadingRateImageFeaturesNV raw() {
        return VkPhysicalDeviceShadingRateImageFeaturesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV,
            .pNext = nullptr,
            .shadingRateImage = static_cast<VkBool32>(shading_rate_image),
            .shadingRateCoarseSampleOrder = static_cast<VkBool32>(shading_rate_coarse_sample_order)
        };
    }
};

struct PhysicalDeviceShadingRateImagePropertiesNV {
    Extent2D shading_rate_texel_size;
    u32 shading_rate_palette_size;
    u32 shading_rate_max_coarse_samples;
    
    VkPhysicalDeviceShadingRateImagePropertiesNV raw() {
        return VkPhysicalDeviceShadingRateImagePropertiesNV {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV,
            .pNext = nullptr,
            .shadingRateTexelSize = shading_rate_texel_size.raw(),
            .shadingRatePaletteSize = shading_rate_palette_size,
            .shadingRateMaxCoarseSamples = shading_rate_max_coarse_samples
        };
    }
};

struct PhysicalDeviceSparseImageFormatInfo2 {
    Format format;
    ImageType type;
    SampleCountFlags samples;
    VkImageUsageFlags usage;
    ImageTiling tiling;
    
    VkPhysicalDeviceSparseImageFormatInfo2 raw() {
        return VkPhysicalDeviceSparseImageFormatInfo2 {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO2,
            .pNext = nullptr,
            .format = static_cast<VkFormat>(format),
            .type = static_cast<VkImageType>(type),
            .samples = static_cast<VkSampleCountFlagBits>(samples),
            .usage = usage,
            .tiling = static_cast<VkImageTiling>(tiling)
        };
    }
};

struct PhysicalDeviceSparseProperties {
    bool residency_standard2dblock_shape;
    bool residency_standard2dmultisample_block_shape;
    bool residency_standard3dblock_shape;
    bool residency_aligned_mip_size;
    bool residency_non_resident_strict;
    
    VkPhysicalDeviceSparseProperties raw() {
        return VkPhysicalDeviceSparseProperties {
            .residencyStandard2DBlockShape = static_cast<VkBool32>(residency_standard2dblock_shape),
            .residencyStandard2DMultisampleBlockShape = static_cast<VkBool32>(residency_standard2dmultisample_block_shape),
            .residencyStandard3DBlockShape = static_cast<VkBool32>(residency_standard3dblock_shape),
            .residencyAlignedMipSize = static_cast<VkBool32>(residency_aligned_mip_size),
            .residencyNonResidentStrict = static_cast<VkBool32>(residency_non_resident_strict)
        };
    }
};

struct PhysicalDeviceSubgroupProperties {
    u32 subgroup_size;
    VkShaderStageFlags supported_stages;
    VkSubgroupFeatureFlags supported_operations;
    bool quad_operations_in_all_stages;
    
    VkPhysicalDeviceSubgroupProperties raw() {
        return VkPhysicalDeviceSubgroupProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES,
            .pNext = nullptr,
            .subgroupSize = subgroup_size,
            .supportedStages = supported_stages,
            .supportedOperations = supported_operations,
            .quadOperationsInAllStages = static_cast<VkBool32>(quad_operations_in_all_stages)
        };
    }
};

struct PhysicalDeviceSubgroupSizeControlFeatures {
    bool subgroup_size_control;
    bool compute_full_subgroups;
    
    VkPhysicalDeviceSubgroupSizeControlFeatures raw() {
        return VkPhysicalDeviceSubgroupSizeControlFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES,
            .pNext = nullptr,
            .subgroupSizeControl = static_cast<VkBool32>(subgroup_size_control),
            .computeFullSubgroups = static_cast<VkBool32>(compute_full_subgroups)
        };
    }
};

struct PhysicalDeviceSubgroupSizeControlProperties {
    u32 min_subgroup_size;
    u32 max_subgroup_size;
    u32 max_compute_workgroup_subgroups;
    VkShaderStageFlags required_subgroup_size_stages;
    
    VkPhysicalDeviceSubgroupSizeControlProperties raw() {
        return VkPhysicalDeviceSubgroupSizeControlProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES,
            .pNext = nullptr,
            .minSubgroupSize = min_subgroup_size,
            .maxSubgroupSize = max_subgroup_size,
            .maxComputeWorkgroupSubgroups = max_compute_workgroup_subgroups,
            .requiredSubgroupSizeStages = required_subgroup_size_stages
        };
    }
};

struct PhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
    bool subpass_merge_feedback;
    
    VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT raw() {
        return VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT,
            .pNext = nullptr,
            .subpassMergeFeedback = static_cast<VkBool32>(subpass_merge_feedback)
        };
    }
};

struct PhysicalDeviceSubpassShadingFeaturesHUAWEI {
    bool subpass_shading;
    
    VkPhysicalDeviceSubpassShadingFeaturesHUAWEI raw() {
        return VkPhysicalDeviceSubpassShadingFeaturesHUAWEI {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI,
            .pNext = nullptr,
            .subpassShading = static_cast<VkBool32>(subpass_shading)
        };
    }
};

struct PhysicalDeviceSubpassShadingPropertiesHUAWEI {
    u32 max_subpass_shading_workgroup_size_aspect_ratio;
    
    VkPhysicalDeviceSubpassShadingPropertiesHUAWEI raw() {
        return VkPhysicalDeviceSubpassShadingPropertiesHUAWEI {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI,
            .pNext = nullptr,
            .maxSubpassShadingWorkgroupSizeAspectRatio = max_subpass_shading_workgroup_size_aspect_ratio
        };
    }
};

struct PhysicalDeviceSurfaceInfo2KHR {
    VkSurfaceKHR surface;
    
    VkPhysicalDeviceSurfaceInfo2KHR raw() {
        return VkPhysicalDeviceSurfaceInfo2KHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SURFACE_INFO2KHR,
            .pNext = nullptr,
            .surface = surface
        };
    }
};

struct PhysicalDeviceSwapchainMaintenance1FeaturesEXT {
    bool swapchain_maintenance1;
    
    VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT raw() {
        return VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE1FEATURES_EXT,
            .pNext = nullptr,
            .swapchainMaintenance1 = static_cast<VkBool32>(swapchain_maintenance1)
        };
    }
};

struct PhysicalDeviceSynchronization2Features {
    bool synchronization2;
    
    VkPhysicalDeviceSynchronization2Features raw() {
        return VkPhysicalDeviceSynchronization2Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION2FEATURES,
            .pNext = nullptr,
            .synchronization2 = static_cast<VkBool32>(synchronization2)
        };
    }
};

struct PhysicalDeviceTexelBufferAlignmentFeaturesEXT {
    bool texel_buffer_alignment;
    
    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT raw() {
        return VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT,
            .pNext = nullptr,
            .texelBufferAlignment = static_cast<VkBool32>(texel_buffer_alignment)
        };
    }
};

struct PhysicalDeviceTexelBufferAlignmentProperties {
    VkDeviceSize storage_texel_buffer_offset_alignment_bytes;
    bool storage_texel_buffer_offset_single_texel_alignment;
    VkDeviceSize uniform_texel_buffer_offset_alignment_bytes;
    bool uniform_texel_buffer_offset_single_texel_alignment;
    
    VkPhysicalDeviceTexelBufferAlignmentProperties raw() {
        return VkPhysicalDeviceTexelBufferAlignmentProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES,
            .pNext = nullptr,
            .storageTexelBufferOffsetAlignmentBytes = storage_texel_buffer_offset_alignment_bytes,
            .storageTexelBufferOffsetSingleTexelAlignment = static_cast<VkBool32>(storage_texel_buffer_offset_single_texel_alignment),
            .uniformTexelBufferOffsetAlignmentBytes = uniform_texel_buffer_offset_alignment_bytes,
            .uniformTexelBufferOffsetSingleTexelAlignment = static_cast<VkBool32>(uniform_texel_buffer_offset_single_texel_alignment)
        };
    }
};

struct PhysicalDeviceTextureCompressionASTCHDRFeatures {
    bool texture_compression_astc_hdr;
    
    VkPhysicalDeviceTextureCompressionASTCHDRFeatures raw() {
        return VkPhysicalDeviceTextureCompressionASTCHDRFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTCHDRFEATURES,
            .pNext = nullptr,
            .textureCompressionASTC_HDR = static_cast<VkBool32>(texture_compression_astc_hdr)
        };
    }
};

struct PhysicalDeviceTileMemoryHeapFeaturesQCOM {
    bool tile_memory_heap;
    
    VkPhysicalDeviceTileMemoryHeapFeaturesQCOM raw() {
        return VkPhysicalDeviceTileMemoryHeapFeaturesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM,
            .pNext = nullptr,
            .tileMemoryHeap = static_cast<VkBool32>(tile_memory_heap)
        };
    }
};

struct PhysicalDeviceTileMemoryHeapPropertiesQCOM {
    bool queue_submit_boundary;
    bool tile_buffer_transfers;
    
    VkPhysicalDeviceTileMemoryHeapPropertiesQCOM raw() {
        return VkPhysicalDeviceTileMemoryHeapPropertiesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM,
            .pNext = nullptr,
            .queueSubmitBoundary = static_cast<VkBool32>(queue_submit_boundary),
            .tileBufferTransfers = static_cast<VkBool32>(tile_buffer_transfers)
        };
    }
};

struct PhysicalDeviceTilePropertiesFeaturesQCOM {
    bool tile_properties;
    
    VkPhysicalDeviceTilePropertiesFeaturesQCOM raw() {
        return VkPhysicalDeviceTilePropertiesFeaturesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM,
            .pNext = nullptr,
            .tileProperties = static_cast<VkBool32>(tile_properties)
        };
    }
};

struct PhysicalDeviceTileShadingFeaturesQCOM {
    bool tile_shading;
    bool tile_shading_fragment_stage;
    bool tile_shading_color_attachments;
    bool tile_shading_depth_attachments;
    bool tile_shading_stencil_attachments;
    bool tile_shading_input_attachments;
    bool tile_shading_sampled_attachments;
    bool tile_shading_per_tile_draw;
    bool tile_shading_per_tile_dispatch;
    bool tile_shading_dispatch_tile;
    bool tile_shading_apron;
    bool tile_shading_anisotropic_apron;
    bool tile_shading_atomic_ops;
    bool tile_shading_image_processing;
    
    VkPhysicalDeviceTileShadingFeaturesQCOM raw() {
        return VkPhysicalDeviceTileShadingFeaturesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM,
            .pNext = nullptr,
            .tileShading = static_cast<VkBool32>(tile_shading),
            .tileShadingFragmentStage = static_cast<VkBool32>(tile_shading_fragment_stage),
            .tileShadingColorAttachments = static_cast<VkBool32>(tile_shading_color_attachments),
            .tileShadingDepthAttachments = static_cast<VkBool32>(tile_shading_depth_attachments),
            .tileShadingStencilAttachments = static_cast<VkBool32>(tile_shading_stencil_attachments),
            .tileShadingInputAttachments = static_cast<VkBool32>(tile_shading_input_attachments),
            .tileShadingSampledAttachments = static_cast<VkBool32>(tile_shading_sampled_attachments),
            .tileShadingPerTileDraw = static_cast<VkBool32>(tile_shading_per_tile_draw),
            .tileShadingPerTileDispatch = static_cast<VkBool32>(tile_shading_per_tile_dispatch),
            .tileShadingDispatchTile = static_cast<VkBool32>(tile_shading_dispatch_tile),
            .tileShadingApron = static_cast<VkBool32>(tile_shading_apron),
            .tileShadingAnisotropicApron = static_cast<VkBool32>(tile_shading_anisotropic_apron),
            .tileShadingAtomicOps = static_cast<VkBool32>(tile_shading_atomic_ops),
            .tileShadingImageProcessing = static_cast<VkBool32>(tile_shading_image_processing)
        };
    }
};

struct PhysicalDeviceTileShadingPropertiesQCOM {
    u32 max_apron_size;
    bool prefer_non_coherent;
    Extent2D tile_granularity;
    Extent2D max_tile_shading_rate;
    
    VkPhysicalDeviceTileShadingPropertiesQCOM raw() {
        return VkPhysicalDeviceTileShadingPropertiesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM,
            .pNext = nullptr,
            .maxApronSize = max_apron_size,
            .preferNonCoherent = static_cast<VkBool32>(prefer_non_coherent),
            .tileGranularity = tile_granularity.raw(),
            .maxTileShadingRate = max_tile_shading_rate.raw()
        };
    }
};

struct PhysicalDeviceTimelineSemaphoreFeatures {
    bool timeline_semaphore;
    
    VkPhysicalDeviceTimelineSemaphoreFeatures raw() {
        return VkPhysicalDeviceTimelineSemaphoreFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES,
            .pNext = nullptr,
            .timelineSemaphore = static_cast<VkBool32>(timeline_semaphore)
        };
    }
};

struct PhysicalDeviceTimelineSemaphoreProperties {
    uint64_t max_timeline_semaphore_value_difference;
    
    VkPhysicalDeviceTimelineSemaphoreProperties raw() {
        return VkPhysicalDeviceTimelineSemaphoreProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES,
            .pNext = nullptr,
            .maxTimelineSemaphoreValueDifference = max_timeline_semaphore_value_difference
        };
    }
};

struct PhysicalDeviceToolProperties {
    char[] vk_max_extension_name_size;
    char[] vk_max_extension_name_size;
    VkToolPurposeFlags purposes;
    char[] vk_max_description_size;
    char[] vk_max_extension_name_size;
    
    VkPhysicalDeviceToolProperties raw() {
        return VkPhysicalDeviceToolProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES,
            .pNext = nullptr,
            .VK_MAX_EXTENSION_NAME_SIZE = vk_max_extension_name_size,
            .VK_MAX_EXTENSION_NAME_SIZE = vk_max_extension_name_size,
            .purposes = purposes,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .VK_MAX_EXTENSION_NAME_SIZE = vk_max_extension_name_size
        };
    }
};

struct PhysicalDeviceTransformFeedbackFeaturesEXT {
    bool transform_feedback;
    bool geometry_streams;
    
    VkPhysicalDeviceTransformFeedbackFeaturesEXT raw() {
        return VkPhysicalDeviceTransformFeedbackFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT,
            .pNext = nullptr,
            .transformFeedback = static_cast<VkBool32>(transform_feedback),
            .geometryStreams = static_cast<VkBool32>(geometry_streams)
        };
    }
};

struct PhysicalDeviceTransformFeedbackPropertiesEXT {
    u32 max_transform_feedback_streams;
    u32 max_transform_feedback_buffers;
    VkDeviceSize max_transform_feedback_buffer_size;
    u32 max_transform_feedback_stream_data_size;
    u32 max_transform_feedback_buffer_data_size;
    u32 max_transform_feedback_buffer_data_stride;
    bool transform_feedback_queries;
    bool transform_feedback_streams_lines_triangles;
    bool transform_feedback_rasterization_stream_select;
    bool transform_feedback_draw;
    
    VkPhysicalDeviceTransformFeedbackPropertiesEXT raw() {
        return VkPhysicalDeviceTransformFeedbackPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT,
            .pNext = nullptr,
            .maxTransformFeedbackStreams = max_transform_feedback_streams,
            .maxTransformFeedbackBuffers = max_transform_feedback_buffers,
            .maxTransformFeedbackBufferSize = max_transform_feedback_buffer_size,
            .maxTransformFeedbackStreamDataSize = max_transform_feedback_stream_data_size,
            .maxTransformFeedbackBufferDataSize = max_transform_feedback_buffer_data_size,
            .maxTransformFeedbackBufferDataStride = max_transform_feedback_buffer_data_stride,
            .transformFeedbackQueries = static_cast<VkBool32>(transform_feedback_queries),
            .transformFeedbackStreamsLinesTriangles = static_cast<VkBool32>(transform_feedback_streams_lines_triangles),
            .transformFeedbackRasterizationStreamSelect = static_cast<VkBool32>(transform_feedback_rasterization_stream_select),
            .transformFeedbackDraw = static_cast<VkBool32>(transform_feedback_draw)
        };
    }
};

struct PhysicalDeviceUniformBufferStandardLayoutFeatures {
    bool uniform_buffer_standard_layout;
    
    VkPhysicalDeviceUniformBufferStandardLayoutFeatures raw() {
        return VkPhysicalDeviceUniformBufferStandardLayoutFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES,
            .pNext = nullptr,
            .uniformBufferStandardLayout = static_cast<VkBool32>(uniform_buffer_standard_layout)
        };
    }
};

struct PhysicalDeviceVariablePointersFeatures {
    bool variable_pointers_storage_buffer;
    bool variable_pointers;
    
    VkPhysicalDeviceVariablePointersFeatures raw() {
        return VkPhysicalDeviceVariablePointersFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES,
            .pNext = nullptr,
            .variablePointersStorageBuffer = static_cast<VkBool32>(variable_pointers_storage_buffer),
            .variablePointers = static_cast<VkBool32>(variable_pointers)
        };
    }
};

struct PhysicalDeviceVertexAttributeDivisorFeatures {
    bool vertex_attribute_instance_rate_divisor;
    bool vertex_attribute_instance_rate_zero_divisor;
    
    VkPhysicalDeviceVertexAttributeDivisorFeatures raw() {
        return VkPhysicalDeviceVertexAttributeDivisorFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES,
            .pNext = nullptr,
            .vertexAttributeInstanceRateDivisor = static_cast<VkBool32>(vertex_attribute_instance_rate_divisor),
            .vertexAttributeInstanceRateZeroDivisor = static_cast<VkBool32>(vertex_attribute_instance_rate_zero_divisor)
        };
    }
};

struct PhysicalDeviceVertexAttributeDivisorProperties {
    u32 max_vertex_attrib_divisor;
    bool supports_non_zero_first_instance;
    
    VkPhysicalDeviceVertexAttributeDivisorProperties raw() {
        return VkPhysicalDeviceVertexAttributeDivisorProperties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES,
            .pNext = nullptr,
            .maxVertexAttribDivisor = max_vertex_attrib_divisor,
            .supportsNonZeroFirstInstance = static_cast<VkBool32>(supports_non_zero_first_instance)
        };
    }
};

struct PhysicalDeviceVertexAttributeDivisorPropertiesEXT {
    u32 max_vertex_attrib_divisor;
    
    VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT raw() {
        return VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT,
            .pNext = nullptr,
            .maxVertexAttribDivisor = max_vertex_attrib_divisor
        };
    }
};

struct PhysicalDeviceVertexAttributeRobustnessFeaturesEXT {
    bool vertex_attribute_robustness;
    
    VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT raw() {
        return VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT,
            .pNext = nullptr,
            .vertexAttributeRobustness = static_cast<VkBool32>(vertex_attribute_robustness)
        };
    }
};

struct PhysicalDeviceVertexInputDynamicStateFeaturesEXT {
    bool vertex_input_dynamic_state;
    
    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT raw() {
        return VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT,
            .pNext = nullptr,
            .vertexInputDynamicState = static_cast<VkBool32>(vertex_input_dynamic_state)
        };
    }
};

struct PhysicalDeviceVideoEncodeAV1FeaturesKHR {
    bool video_encode_av1;
    
    VkPhysicalDeviceVideoEncodeAV1FeaturesKHR raw() {
        return VkPhysicalDeviceVideoEncodeAV1FeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1FEATURES_KHR,
            .pNext = nullptr,
            .videoEncodeAV1 = static_cast<VkBool32>(video_encode_av1)
        };
    }
};

struct PhysicalDeviceVideoEncodeQualityLevelInfoKHR {
    VkVideoProfileInfoKHR* video_profile;
    u32 quality_level;
    
    VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR raw() {
        return VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
            .pNext = nullptr,
            .pVideoProfile = video_profile,
            .qualityLevel = quality_level
        };
    }
};

struct PhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR {
    bool video_encode_quantization_map;
    
    VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR raw() {
        return VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR,
            .pNext = nullptr,
            .videoEncodeQuantizationMap = static_cast<VkBool32>(video_encode_quantization_map)
        };
    }
};

struct PhysicalDeviceVideoFormatInfoKHR {
    VkImageUsageFlags image_usage;
    
    VkPhysicalDeviceVideoFormatInfoKHR raw() {
        return VkPhysicalDeviceVideoFormatInfoKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR,
            .pNext = nullptr,
            .imageUsage = image_usage
        };
    }
};

struct PhysicalDeviceVideoMaintenance1FeaturesKHR {
    bool video_maintenance1;
    
    VkPhysicalDeviceVideoMaintenance1FeaturesKHR raw() {
        return VkPhysicalDeviceVideoMaintenance1FeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE1FEATURES_KHR,
            .pNext = nullptr,
            .videoMaintenance1 = static_cast<VkBool32>(video_maintenance1)
        };
    }
};

struct PhysicalDeviceVideoMaintenance2FeaturesKHR {
    bool video_maintenance2;
    
    VkPhysicalDeviceVideoMaintenance2FeaturesKHR raw() {
        return VkPhysicalDeviceVideoMaintenance2FeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE2FEATURES_KHR,
            .pNext = nullptr,
            .videoMaintenance2 = static_cast<VkBool32>(video_maintenance2)
        };
    }
};

struct PhysicalDeviceVulkan11Features {
    bool storage_buffer16bit_access;
    bool uniform_and_storage_buffer16bit_access;
    bool storage_push_constant16;
    bool storage_input_output16;
    bool multiview;
    bool multiview_geometry_shader;
    bool multiview_tessellation_shader;
    bool variable_pointers_storage_buffer;
    bool variable_pointers;
    bool protected_memory;
    bool sampler_ycbcr_conversion;
    bool shader_draw_parameters;
    
    VkPhysicalDeviceVulkan11Features raw() {
        return VkPhysicalDeviceVulkan11Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VULKAN11FEATURES,
            .pNext = nullptr,
            .storageBuffer16BitAccess = static_cast<VkBool32>(storage_buffer16bit_access),
            .uniformAndStorageBuffer16BitAccess = static_cast<VkBool32>(uniform_and_storage_buffer16bit_access),
            .storagePushConstant16 = static_cast<VkBool32>(storage_push_constant16),
            .storageInputOutput16 = static_cast<VkBool32>(storage_input_output16),
            .multiview = static_cast<VkBool32>(multiview),
            .multiviewGeometryShader = static_cast<VkBool32>(multiview_geometry_shader),
            .multiviewTessellationShader = static_cast<VkBool32>(multiview_tessellation_shader),
            .variablePointersStorageBuffer = static_cast<VkBool32>(variable_pointers_storage_buffer),
            .variablePointers = static_cast<VkBool32>(variable_pointers),
            .protectedMemory = static_cast<VkBool32>(protected_memory),
            .samplerYcbcrConversion = static_cast<VkBool32>(sampler_ycbcr_conversion),
            .shaderDrawParameters = static_cast<VkBool32>(shader_draw_parameters)
        };
    }
};

struct PhysicalDeviceVulkan11Properties {
    uint8_t[] vk_uuid_size;
    uint8_t[] vk_uuid_size;
    uint8_t[] vk_luid_size;
    u32 device_node_mask;
    bool device_luidvalid;
    u32 subgroup_size;
    VkShaderStageFlags subgroup_supported_stages;
    VkSubgroupFeatureFlags subgroup_supported_operations;
    bool subgroup_quad_operations_in_all_stages;
    PointClippingBehavior point_clipping_behavior;
    u32 max_multiview_view_count;
    u32 max_multiview_instance_index;
    bool protected_no_fault;
    u32 max_per_set_descriptors;
    VkDeviceSize max_memory_allocation_size;
    
    VkPhysicalDeviceVulkan11Properties raw() {
        return VkPhysicalDeviceVulkan11Properties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VULKAN11PROPERTIES,
            .pNext = nullptr,
            .VK_UUID_SIZE = vk_uuid_size,
            .VK_UUID_SIZE = vk_uuid_size,
            .VK_LUID_SIZE = vk_luid_size,
            .deviceNodeMask = device_node_mask,
            .deviceLUIDValid = static_cast<VkBool32>(device_luidvalid),
            .subgroupSize = subgroup_size,
            .subgroupSupportedStages = subgroup_supported_stages,
            .subgroupSupportedOperations = subgroup_supported_operations,
            .subgroupQuadOperationsInAllStages = static_cast<VkBool32>(subgroup_quad_operations_in_all_stages),
            .pointClippingBehavior = static_cast<VkPointClippingBehavior>(point_clipping_behavior),
            .maxMultiviewViewCount = max_multiview_view_count,
            .maxMultiviewInstanceIndex = max_multiview_instance_index,
            .protectedNoFault = static_cast<VkBool32>(protected_no_fault),
            .maxPerSetDescriptors = max_per_set_descriptors,
            .maxMemoryAllocationSize = max_memory_allocation_size
        };
    }
};

struct PhysicalDeviceVulkan12Features {
    bool sampler_mirror_clamp_to_edge;
    bool draw_indirect_count;
    bool storage_buffer8bit_access;
    bool uniform_and_storage_buffer8bit_access;
    bool storage_push_constant8;
    bool shader_buffer_int64atomics;
    bool shader_shared_int64atomics;
    bool shader_float16;
    bool shader_int8;
    bool descriptor_indexing;
    bool shader_input_attachment_array_dynamic_indexing;
    bool shader_uniform_texel_buffer_array_dynamic_indexing;
    bool shader_storage_texel_buffer_array_dynamic_indexing;
    bool shader_uniform_buffer_array_non_uniform_indexing;
    bool shader_sampled_image_array_non_uniform_indexing;
    bool shader_storage_buffer_array_non_uniform_indexing;
    bool shader_storage_image_array_non_uniform_indexing;
    bool shader_input_attachment_array_non_uniform_indexing;
    bool shader_uniform_texel_buffer_array_non_uniform_indexing;
    bool shader_storage_texel_buffer_array_non_uniform_indexing;
    bool descriptor_binding_uniform_buffer_update_after_bind;
    bool descriptor_binding_sampled_image_update_after_bind;
    bool descriptor_binding_storage_image_update_after_bind;
    bool descriptor_binding_storage_buffer_update_after_bind;
    bool descriptor_binding_uniform_texel_buffer_update_after_bind;
    bool descriptor_binding_storage_texel_buffer_update_after_bind;
    bool descriptor_binding_update_unused_while_pending;
    bool descriptor_binding_partially_bound;
    bool descriptor_binding_variable_descriptor_count;
    bool runtime_descriptor_array;
    bool sampler_filter_minmax;
    bool scalar_block_layout;
    bool imageless_framebuffer;
    bool uniform_buffer_standard_layout;
    bool shader_subgroup_extended_types;
    bool separate_depth_stencil_layouts;
    bool host_query_reset;
    bool timeline_semaphore;
    bool buffer_device_address;
    bool buffer_device_address_capture_replay;
    bool buffer_device_address_multi_device;
    bool vulkan_memory_model;
    bool vulkan_memory_model_device_scope;
    bool vulkan_memory_model_availability_visibility_chains;
    bool shader_output_viewport_index;
    bool shader_output_layer;
    bool subgroup_broadcast_dynamic_id;
    
    VkPhysicalDeviceVulkan12Features raw() {
        return VkPhysicalDeviceVulkan12Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VULKAN12FEATURES,
            .pNext = nullptr,
            .samplerMirrorClampToEdge = static_cast<VkBool32>(sampler_mirror_clamp_to_edge),
            .drawIndirectCount = static_cast<VkBool32>(draw_indirect_count),
            .storageBuffer8BitAccess = static_cast<VkBool32>(storage_buffer8bit_access),
            .uniformAndStorageBuffer8BitAccess = static_cast<VkBool32>(uniform_and_storage_buffer8bit_access),
            .storagePushConstant8 = static_cast<VkBool32>(storage_push_constant8),
            .shaderBufferInt64Atomics = static_cast<VkBool32>(shader_buffer_int64atomics),
            .shaderSharedInt64Atomics = static_cast<VkBool32>(shader_shared_int64atomics),
            .shaderFloat16 = static_cast<VkBool32>(shader_float16),
            .shaderInt8 = static_cast<VkBool32>(shader_int8),
            .descriptorIndexing = static_cast<VkBool32>(descriptor_indexing),
            .shaderInputAttachmentArrayDynamicIndexing = static_cast<VkBool32>(shader_input_attachment_array_dynamic_indexing),
            .shaderUniformTexelBufferArrayDynamicIndexing = static_cast<VkBool32>(shader_uniform_texel_buffer_array_dynamic_indexing),
            .shaderStorageTexelBufferArrayDynamicIndexing = static_cast<VkBool32>(shader_storage_texel_buffer_array_dynamic_indexing),
            .shaderUniformBufferArrayNonUniformIndexing = static_cast<VkBool32>(shader_uniform_buffer_array_non_uniform_indexing),
            .shaderSampledImageArrayNonUniformIndexing = static_cast<VkBool32>(shader_sampled_image_array_non_uniform_indexing),
            .shaderStorageBufferArrayNonUniformIndexing = static_cast<VkBool32>(shader_storage_buffer_array_non_uniform_indexing),
            .shaderStorageImageArrayNonUniformIndexing = static_cast<VkBool32>(shader_storage_image_array_non_uniform_indexing),
            .shaderInputAttachmentArrayNonUniformIndexing = static_cast<VkBool32>(shader_input_attachment_array_non_uniform_indexing),
            .shaderUniformTexelBufferArrayNonUniformIndexing = static_cast<VkBool32>(shader_uniform_texel_buffer_array_non_uniform_indexing),
            .shaderStorageTexelBufferArrayNonUniformIndexing = static_cast<VkBool32>(shader_storage_texel_buffer_array_non_uniform_indexing),
            .descriptorBindingUniformBufferUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_uniform_buffer_update_after_bind),
            .descriptorBindingSampledImageUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_sampled_image_update_after_bind),
            .descriptorBindingStorageImageUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_storage_image_update_after_bind),
            .descriptorBindingStorageBufferUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_storage_buffer_update_after_bind),
            .descriptorBindingUniformTexelBufferUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_uniform_texel_buffer_update_after_bind),
            .descriptorBindingStorageTexelBufferUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_storage_texel_buffer_update_after_bind),
            .descriptorBindingUpdateUnusedWhilePending = static_cast<VkBool32>(descriptor_binding_update_unused_while_pending),
            .descriptorBindingPartiallyBound = static_cast<VkBool32>(descriptor_binding_partially_bound),
            .descriptorBindingVariableDescriptorCount = static_cast<VkBool32>(descriptor_binding_variable_descriptor_count),
            .runtimeDescriptorArray = static_cast<VkBool32>(runtime_descriptor_array),
            .samplerFilterMinmax = static_cast<VkBool32>(sampler_filter_minmax),
            .scalarBlockLayout = static_cast<VkBool32>(scalar_block_layout),
            .imagelessFramebuffer = static_cast<VkBool32>(imageless_framebuffer),
            .uniformBufferStandardLayout = static_cast<VkBool32>(uniform_buffer_standard_layout),
            .shaderSubgroupExtendedTypes = static_cast<VkBool32>(shader_subgroup_extended_types),
            .separateDepthStencilLayouts = static_cast<VkBool32>(separate_depth_stencil_layouts),
            .hostQueryReset = static_cast<VkBool32>(host_query_reset),
            .timelineSemaphore = static_cast<VkBool32>(timeline_semaphore),
            .bufferDeviceAddress = static_cast<VkBool32>(buffer_device_address),
            .bufferDeviceAddressCaptureReplay = static_cast<VkBool32>(buffer_device_address_capture_replay),
            .bufferDeviceAddressMultiDevice = static_cast<VkBool32>(buffer_device_address_multi_device),
            .vulkanMemoryModel = static_cast<VkBool32>(vulkan_memory_model),
            .vulkanMemoryModelDeviceScope = static_cast<VkBool32>(vulkan_memory_model_device_scope),
            .vulkanMemoryModelAvailabilityVisibilityChains = static_cast<VkBool32>(vulkan_memory_model_availability_visibility_chains),
            .shaderOutputViewportIndex = static_cast<VkBool32>(shader_output_viewport_index),
            .shaderOutputLayer = static_cast<VkBool32>(shader_output_layer),
            .subgroupBroadcastDynamicId = static_cast<VkBool32>(subgroup_broadcast_dynamic_id)
        };
    }
};

struct PhysicalDeviceVulkan12Properties {
    DriverId driver_id;
    char[] vk_max_driver_name_size;
    char[] vk_max_driver_info_size;
    ConformanceVersion conformance_version;
    ShaderFloatControlsIndependence denorm_behavior_independence;
    ShaderFloatControlsIndependence rounding_mode_independence;
    bool shader_signed_zero_inf_nan_preserve_float16;
    bool shader_signed_zero_inf_nan_preserve_float32;
    bool shader_signed_zero_inf_nan_preserve_float64;
    bool shader_denorm_preserve_float16;
    bool shader_denorm_preserve_float32;
    bool shader_denorm_preserve_float64;
    bool shader_denorm_flush_to_zero_float16;
    bool shader_denorm_flush_to_zero_float32;
    bool shader_denorm_flush_to_zero_float64;
    bool shader_rounding_mode_rtefloat16;
    bool shader_rounding_mode_rtefloat32;
    bool shader_rounding_mode_rtefloat64;
    bool shader_rounding_mode_rtzfloat16;
    bool shader_rounding_mode_rtzfloat32;
    bool shader_rounding_mode_rtzfloat64;
    u32 max_update_after_bind_descriptors_in_all_pools;
    bool shader_uniform_buffer_array_non_uniform_indexing_native;
    bool shader_sampled_image_array_non_uniform_indexing_native;
    bool shader_storage_buffer_array_non_uniform_indexing_native;
    bool shader_storage_image_array_non_uniform_indexing_native;
    bool shader_input_attachment_array_non_uniform_indexing_native;
    bool robust_buffer_access_update_after_bind;
    bool quad_divergent_implicit_lod;
    u32 max_per_stage_descriptor_update_after_bind_samplers;
    u32 max_per_stage_descriptor_update_after_bind_uniform_buffers;
    u32 max_per_stage_descriptor_update_after_bind_storage_buffers;
    u32 max_per_stage_descriptor_update_after_bind_sampled_images;
    u32 max_per_stage_descriptor_update_after_bind_storage_images;
    u32 max_per_stage_descriptor_update_after_bind_input_attachments;
    u32 max_per_stage_update_after_bind_resources;
    u32 max_descriptor_set_update_after_bind_samplers;
    u32 max_descriptor_set_update_after_bind_uniform_buffers;
    u32 max_descriptor_set_update_after_bind_uniform_buffers_dynamic;
    u32 max_descriptor_set_update_after_bind_storage_buffers;
    u32 max_descriptor_set_update_after_bind_storage_buffers_dynamic;
    u32 max_descriptor_set_update_after_bind_sampled_images;
    u32 max_descriptor_set_update_after_bind_storage_images;
    u32 max_descriptor_set_update_after_bind_input_attachments;
    VkResolveModeFlags supported_depth_resolve_modes;
    VkResolveModeFlags supported_stencil_resolve_modes;
    bool independent_resolve_none;
    bool independent_resolve;
    bool filter_minmax_single_component_formats;
    bool filter_minmax_image_component_mapping;
    uint64_t max_timeline_semaphore_value_difference;
    VkSampleCountFlags framebuffer_integer_color_sample_counts;
    
    VkPhysicalDeviceVulkan12Properties raw() {
        return VkPhysicalDeviceVulkan12Properties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VULKAN12PROPERTIES,
            .pNext = nullptr,
            .driverID = static_cast<VkDriverId>(driver_id),
            .VK_MAX_DRIVER_NAME_SIZE = vk_max_driver_name_size,
            .VK_MAX_DRIVER_INFO_SIZE = vk_max_driver_info_size,
            .conformanceVersion = conformance_version.raw(),
            .denormBehaviorIndependence = static_cast<VkShaderFloatControlsIndependence>(denorm_behavior_independence),
            .roundingModeIndependence = static_cast<VkShaderFloatControlsIndependence>(rounding_mode_independence),
            .shaderSignedZeroInfNanPreserveFloat16 = static_cast<VkBool32>(shader_signed_zero_inf_nan_preserve_float16),
            .shaderSignedZeroInfNanPreserveFloat32 = static_cast<VkBool32>(shader_signed_zero_inf_nan_preserve_float32),
            .shaderSignedZeroInfNanPreserveFloat64 = static_cast<VkBool32>(shader_signed_zero_inf_nan_preserve_float64),
            .shaderDenormPreserveFloat16 = static_cast<VkBool32>(shader_denorm_preserve_float16),
            .shaderDenormPreserveFloat32 = static_cast<VkBool32>(shader_denorm_preserve_float32),
            .shaderDenormPreserveFloat64 = static_cast<VkBool32>(shader_denorm_preserve_float64),
            .shaderDenormFlushToZeroFloat16 = static_cast<VkBool32>(shader_denorm_flush_to_zero_float16),
            .shaderDenormFlushToZeroFloat32 = static_cast<VkBool32>(shader_denorm_flush_to_zero_float32),
            .shaderDenormFlushToZeroFloat64 = static_cast<VkBool32>(shader_denorm_flush_to_zero_float64),
            .shaderRoundingModeRTEFloat16 = static_cast<VkBool32>(shader_rounding_mode_rtefloat16),
            .shaderRoundingModeRTEFloat32 = static_cast<VkBool32>(shader_rounding_mode_rtefloat32),
            .shaderRoundingModeRTEFloat64 = static_cast<VkBool32>(shader_rounding_mode_rtefloat64),
            .shaderRoundingModeRTZFloat16 = static_cast<VkBool32>(shader_rounding_mode_rtzfloat16),
            .shaderRoundingModeRTZFloat32 = static_cast<VkBool32>(shader_rounding_mode_rtzfloat32),
            .shaderRoundingModeRTZFloat64 = static_cast<VkBool32>(shader_rounding_mode_rtzfloat64),
            .maxUpdateAfterBindDescriptorsInAllPools = max_update_after_bind_descriptors_in_all_pools,
            .shaderUniformBufferArrayNonUniformIndexingNative = static_cast<VkBool32>(shader_uniform_buffer_array_non_uniform_indexing_native),
            .shaderSampledImageArrayNonUniformIndexingNative = static_cast<VkBool32>(shader_sampled_image_array_non_uniform_indexing_native),
            .shaderStorageBufferArrayNonUniformIndexingNative = static_cast<VkBool32>(shader_storage_buffer_array_non_uniform_indexing_native),
            .shaderStorageImageArrayNonUniformIndexingNative = static_cast<VkBool32>(shader_storage_image_array_non_uniform_indexing_native),
            .shaderInputAttachmentArrayNonUniformIndexingNative = static_cast<VkBool32>(shader_input_attachment_array_non_uniform_indexing_native),
            .robustBufferAccessUpdateAfterBind = static_cast<VkBool32>(robust_buffer_access_update_after_bind),
            .quadDivergentImplicitLod = static_cast<VkBool32>(quad_divergent_implicit_lod),
            .maxPerStageDescriptorUpdateAfterBindSamplers = max_per_stage_descriptor_update_after_bind_samplers,
            .maxPerStageDescriptorUpdateAfterBindUniformBuffers = max_per_stage_descriptor_update_after_bind_uniform_buffers,
            .maxPerStageDescriptorUpdateAfterBindStorageBuffers = max_per_stage_descriptor_update_after_bind_storage_buffers,
            .maxPerStageDescriptorUpdateAfterBindSampledImages = max_per_stage_descriptor_update_after_bind_sampled_images,
            .maxPerStageDescriptorUpdateAfterBindStorageImages = max_per_stage_descriptor_update_after_bind_storage_images,
            .maxPerStageDescriptorUpdateAfterBindInputAttachments = max_per_stage_descriptor_update_after_bind_input_attachments,
            .maxPerStageUpdateAfterBindResources = max_per_stage_update_after_bind_resources,
            .maxDescriptorSetUpdateAfterBindSamplers = max_descriptor_set_update_after_bind_samplers,
            .maxDescriptorSetUpdateAfterBindUniformBuffers = max_descriptor_set_update_after_bind_uniform_buffers,
            .maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = max_descriptor_set_update_after_bind_uniform_buffers_dynamic,
            .maxDescriptorSetUpdateAfterBindStorageBuffers = max_descriptor_set_update_after_bind_storage_buffers,
            .maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = max_descriptor_set_update_after_bind_storage_buffers_dynamic,
            .maxDescriptorSetUpdateAfterBindSampledImages = max_descriptor_set_update_after_bind_sampled_images,
            .maxDescriptorSetUpdateAfterBindStorageImages = max_descriptor_set_update_after_bind_storage_images,
            .maxDescriptorSetUpdateAfterBindInputAttachments = max_descriptor_set_update_after_bind_input_attachments,
            .supportedDepthResolveModes = supported_depth_resolve_modes,
            .supportedStencilResolveModes = supported_stencil_resolve_modes,
            .independentResolveNone = static_cast<VkBool32>(independent_resolve_none),
            .independentResolve = static_cast<VkBool32>(independent_resolve),
            .filterMinmaxSingleComponentFormats = static_cast<VkBool32>(filter_minmax_single_component_formats),
            .filterMinmaxImageComponentMapping = static_cast<VkBool32>(filter_minmax_image_component_mapping),
            .maxTimelineSemaphoreValueDifference = max_timeline_semaphore_value_difference,
            .framebufferIntegerColorSampleCounts = framebuffer_integer_color_sample_counts
        };
    }
};

struct PhysicalDeviceVulkan13Features {
    bool robust_image_access;
    bool inline_uniform_block;
    bool descriptor_binding_inline_uniform_block_update_after_bind;
    bool pipeline_creation_cache_control;
    bool private_data;
    bool shader_demote_to_helper_invocation;
    bool shader_terminate_invocation;
    bool subgroup_size_control;
    bool compute_full_subgroups;
    bool synchronization2;
    bool texture_compression_astc_hdr;
    bool shader_zero_initialize_workgroup_memory;
    bool dynamic_rendering;
    bool shader_integer_dot_product;
    bool maintenance4;
    
    VkPhysicalDeviceVulkan13Features raw() {
        return VkPhysicalDeviceVulkan13Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VULKAN13FEATURES,
            .pNext = nullptr,
            .robustImageAccess = static_cast<VkBool32>(robust_image_access),
            .inlineUniformBlock = static_cast<VkBool32>(inline_uniform_block),
            .descriptorBindingInlineUniformBlockUpdateAfterBind = static_cast<VkBool32>(descriptor_binding_inline_uniform_block_update_after_bind),
            .pipelineCreationCacheControl = static_cast<VkBool32>(pipeline_creation_cache_control),
            .privateData = static_cast<VkBool32>(private_data),
            .shaderDemoteToHelperInvocation = static_cast<VkBool32>(shader_demote_to_helper_invocation),
            .shaderTerminateInvocation = static_cast<VkBool32>(shader_terminate_invocation),
            .subgroupSizeControl = static_cast<VkBool32>(subgroup_size_control),
            .computeFullSubgroups = static_cast<VkBool32>(compute_full_subgroups),
            .synchronization2 = static_cast<VkBool32>(synchronization2),
            .textureCompressionASTC_HDR = static_cast<VkBool32>(texture_compression_astc_hdr),
            .shaderZeroInitializeWorkgroupMemory = static_cast<VkBool32>(shader_zero_initialize_workgroup_memory),
            .dynamicRendering = static_cast<VkBool32>(dynamic_rendering),
            .shaderIntegerDotProduct = static_cast<VkBool32>(shader_integer_dot_product),
            .maintenance4 = static_cast<VkBool32>(maintenance4)
        };
    }
};

struct PhysicalDeviceVulkan13Properties {
    u32 min_subgroup_size;
    u32 max_subgroup_size;
    u32 max_compute_workgroup_subgroups;
    VkShaderStageFlags required_subgroup_size_stages;
    u32 max_inline_uniform_block_size;
    u32 max_per_stage_descriptor_inline_uniform_blocks;
    u32 max_per_stage_descriptor_update_after_bind_inline_uniform_blocks;
    u32 max_descriptor_set_inline_uniform_blocks;
    u32 max_descriptor_set_update_after_bind_inline_uniform_blocks;
    u32 max_inline_uniform_total_size;
    bool integer_dot_product8bit_unsigned_accelerated;
    bool integer_dot_product8bit_signed_accelerated;
    bool integer_dot_product8bit_mixed_signedness_accelerated;
    bool integer_dot_product4x8bit_packed_unsigned_accelerated;
    bool integer_dot_product4x8bit_packed_signed_accelerated;
    bool integer_dot_product4x8bit_packed_mixed_signedness_accelerated;
    bool integer_dot_product16bit_unsigned_accelerated;
    bool integer_dot_product16bit_signed_accelerated;
    bool integer_dot_product16bit_mixed_signedness_accelerated;
    bool integer_dot_product32bit_unsigned_accelerated;
    bool integer_dot_product32bit_signed_accelerated;
    bool integer_dot_product32bit_mixed_signedness_accelerated;
    bool integer_dot_product64bit_unsigned_accelerated;
    bool integer_dot_product64bit_signed_accelerated;
    bool integer_dot_product64bit_mixed_signedness_accelerated;
    bool integer_dot_product_accumulating_saturating8bit_unsigned_accelerated;
    bool integer_dot_product_accumulating_saturating8bit_signed_accelerated;
    bool integer_dot_product_accumulating_saturating8bit_mixed_signedness_accelerated;
    bool integer_dot_product_accumulating_saturating4x8bit_packed_unsigned_accelerated;
    bool integer_dot_product_accumulating_saturating4x8bit_packed_signed_accelerated;
    bool integer_dot_product_accumulating_saturating4x8bit_packed_mixed_signedness_accelerated;
    bool integer_dot_product_accumulating_saturating16bit_unsigned_accelerated;
    bool integer_dot_product_accumulating_saturating16bit_signed_accelerated;
    bool integer_dot_product_accumulating_saturating16bit_mixed_signedness_accelerated;
    bool integer_dot_product_accumulating_saturating32bit_unsigned_accelerated;
    bool integer_dot_product_accumulating_saturating32bit_signed_accelerated;
    bool integer_dot_product_accumulating_saturating32bit_mixed_signedness_accelerated;
    bool integer_dot_product_accumulating_saturating64bit_unsigned_accelerated;
    bool integer_dot_product_accumulating_saturating64bit_signed_accelerated;
    bool integer_dot_product_accumulating_saturating64bit_mixed_signedness_accelerated;
    VkDeviceSize storage_texel_buffer_offset_alignment_bytes;
    bool storage_texel_buffer_offset_single_texel_alignment;
    VkDeviceSize uniform_texel_buffer_offset_alignment_bytes;
    bool uniform_texel_buffer_offset_single_texel_alignment;
    VkDeviceSize max_buffer_size;
    
    VkPhysicalDeviceVulkan13Properties raw() {
        return VkPhysicalDeviceVulkan13Properties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VULKAN13PROPERTIES,
            .pNext = nullptr,
            .minSubgroupSize = min_subgroup_size,
            .maxSubgroupSize = max_subgroup_size,
            .maxComputeWorkgroupSubgroups = max_compute_workgroup_subgroups,
            .requiredSubgroupSizeStages = required_subgroup_size_stages,
            .maxInlineUniformBlockSize = max_inline_uniform_block_size,
            .maxPerStageDescriptorInlineUniformBlocks = max_per_stage_descriptor_inline_uniform_blocks,
            .maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = max_per_stage_descriptor_update_after_bind_inline_uniform_blocks,
            .maxDescriptorSetInlineUniformBlocks = max_descriptor_set_inline_uniform_blocks,
            .maxDescriptorSetUpdateAfterBindInlineUniformBlocks = max_descriptor_set_update_after_bind_inline_uniform_blocks,
            .maxInlineUniformTotalSize = max_inline_uniform_total_size,
            .integerDotProduct8BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product8bit_unsigned_accelerated),
            .integerDotProduct8BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product8bit_signed_accelerated),
            .integerDotProduct8BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product8bit_mixed_signedness_accelerated),
            .integerDotProduct4x8BitPackedUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product4x8bit_packed_unsigned_accelerated),
            .integerDotProduct4x8BitPackedSignedAccelerated = static_cast<VkBool32>(integer_dot_product4x8bit_packed_signed_accelerated),
            .integerDotProduct4x8BitPackedMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product4x8bit_packed_mixed_signedness_accelerated),
            .integerDotProduct16BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product16bit_unsigned_accelerated),
            .integerDotProduct16BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product16bit_signed_accelerated),
            .integerDotProduct16BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product16bit_mixed_signedness_accelerated),
            .integerDotProduct32BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product32bit_unsigned_accelerated),
            .integerDotProduct32BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product32bit_signed_accelerated),
            .integerDotProduct32BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product32bit_mixed_signedness_accelerated),
            .integerDotProduct64BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product64bit_unsigned_accelerated),
            .integerDotProduct64BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product64bit_signed_accelerated),
            .integerDotProduct64BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product64bit_mixed_signedness_accelerated),
            .integerDotProductAccumulatingSaturating8BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating8bit_unsigned_accelerated),
            .integerDotProductAccumulatingSaturating8BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating8bit_signed_accelerated),
            .integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating8bit_mixed_signedness_accelerated),
            .integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating4x8bit_packed_unsigned_accelerated),
            .integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating4x8bit_packed_signed_accelerated),
            .integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating4x8bit_packed_mixed_signedness_accelerated),
            .integerDotProductAccumulatingSaturating16BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating16bit_unsigned_accelerated),
            .integerDotProductAccumulatingSaturating16BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating16bit_signed_accelerated),
            .integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating16bit_mixed_signedness_accelerated),
            .integerDotProductAccumulatingSaturating32BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating32bit_unsigned_accelerated),
            .integerDotProductAccumulatingSaturating32BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating32bit_signed_accelerated),
            .integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating32bit_mixed_signedness_accelerated),
            .integerDotProductAccumulatingSaturating64BitUnsignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating64bit_unsigned_accelerated),
            .integerDotProductAccumulatingSaturating64BitSignedAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating64bit_signed_accelerated),
            .integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated = static_cast<VkBool32>(integer_dot_product_accumulating_saturating64bit_mixed_signedness_accelerated),
            .storageTexelBufferOffsetAlignmentBytes = storage_texel_buffer_offset_alignment_bytes,
            .storageTexelBufferOffsetSingleTexelAlignment = static_cast<VkBool32>(storage_texel_buffer_offset_single_texel_alignment),
            .uniformTexelBufferOffsetAlignmentBytes = uniform_texel_buffer_offset_alignment_bytes,
            .uniformTexelBufferOffsetSingleTexelAlignment = static_cast<VkBool32>(uniform_texel_buffer_offset_single_texel_alignment),
            .maxBufferSize = max_buffer_size
        };
    }
};

struct PhysicalDeviceVulkan14Features {
    bool global_priority_query;
    bool shader_subgroup_rotate;
    bool shader_subgroup_rotate_clustered;
    bool shader_float_controls2;
    bool shader_expect_assume;
    bool rectangular_lines;
    bool bresenham_lines;
    bool smooth_lines;
    bool stippled_rectangular_lines;
    bool stippled_bresenham_lines;
    bool stippled_smooth_lines;
    bool vertex_attribute_instance_rate_divisor;
    bool vertex_attribute_instance_rate_zero_divisor;
    bool index_type_uint8;
    bool dynamic_rendering_local_read;
    bool maintenance5;
    bool maintenance6;
    bool pipeline_protected_access;
    bool pipeline_robustness;
    bool host_image_copy;
    bool push_descriptor;
    
    VkPhysicalDeviceVulkan14Features raw() {
        return VkPhysicalDeviceVulkan14Features {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VULKAN14FEATURES,
            .pNext = nullptr,
            .globalPriorityQuery = static_cast<VkBool32>(global_priority_query),
            .shaderSubgroupRotate = static_cast<VkBool32>(shader_subgroup_rotate),
            .shaderSubgroupRotateClustered = static_cast<VkBool32>(shader_subgroup_rotate_clustered),
            .shaderFloatControls2 = static_cast<VkBool32>(shader_float_controls2),
            .shaderExpectAssume = static_cast<VkBool32>(shader_expect_assume),
            .rectangularLines = static_cast<VkBool32>(rectangular_lines),
            .bresenhamLines = static_cast<VkBool32>(bresenham_lines),
            .smoothLines = static_cast<VkBool32>(smooth_lines),
            .stippledRectangularLines = static_cast<VkBool32>(stippled_rectangular_lines),
            .stippledBresenhamLines = static_cast<VkBool32>(stippled_bresenham_lines),
            .stippledSmoothLines = static_cast<VkBool32>(stippled_smooth_lines),
            .vertexAttributeInstanceRateDivisor = static_cast<VkBool32>(vertex_attribute_instance_rate_divisor),
            .vertexAttributeInstanceRateZeroDivisor = static_cast<VkBool32>(vertex_attribute_instance_rate_zero_divisor),
            .indexTypeUint8 = static_cast<VkBool32>(index_type_uint8),
            .dynamicRenderingLocalRead = static_cast<VkBool32>(dynamic_rendering_local_read),
            .maintenance5 = static_cast<VkBool32>(maintenance5),
            .maintenance6 = static_cast<VkBool32>(maintenance6),
            .pipelineProtectedAccess = static_cast<VkBool32>(pipeline_protected_access),
            .pipelineRobustness = static_cast<VkBool32>(pipeline_robustness),
            .hostImageCopy = static_cast<VkBool32>(host_image_copy),
            .pushDescriptor = static_cast<VkBool32>(push_descriptor)
        };
    }
};

struct PhysicalDeviceVulkan14Properties {
    u32 line_sub_pixel_precision_bits;
    u32 max_vertex_attrib_divisor;
    bool supports_non_zero_first_instance;
    u32 max_push_descriptors;
    bool dynamic_rendering_local_read_depth_stencil_attachments;
    bool dynamic_rendering_local_read_multisampled_attachments;
    bool early_fragment_multisample_coverage_after_sample_counting;
    bool early_fragment_sample_mask_test_before_sample_counting;
    bool depth_stencil_swizzle_one_support;
    bool polygon_mode_point_size;
    bool non_strict_single_pixel_wide_lines_use_parallelogram;
    bool non_strict_wide_lines_use_parallelogram;
    bool block_texel_view_compatible_multiple_layers;
    u32 max_combined_image_sampler_descriptor_count;
    bool fragment_shading_rate_clamp_combiner_inputs;
    PipelineRobustnessBufferBehavior default_robustness_storage_buffers;
    PipelineRobustnessBufferBehavior default_robustness_uniform_buffers;
    PipelineRobustnessBufferBehavior default_robustness_vertex_inputs;
    PipelineRobustnessImageBehavior default_robustness_images;
    u32 copy_src_layout_count;
    VkImageLayout* copy_src_layouts;
    u32 copy_dst_layout_count;
    VkImageLayout* copy_dst_layouts;
    uint8_t[] vk_uuid_size;
    bool identical_memory_type_requirements;
    
    VkPhysicalDeviceVulkan14Properties raw() {
        return VkPhysicalDeviceVulkan14Properties {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VULKAN14PROPERTIES,
            .pNext = nullptr,
            .lineSubPixelPrecisionBits = line_sub_pixel_precision_bits,
            .maxVertexAttribDivisor = max_vertex_attrib_divisor,
            .supportsNonZeroFirstInstance = static_cast<VkBool32>(supports_non_zero_first_instance),
            .maxPushDescriptors = max_push_descriptors,
            .dynamicRenderingLocalReadDepthStencilAttachments = static_cast<VkBool32>(dynamic_rendering_local_read_depth_stencil_attachments),
            .dynamicRenderingLocalReadMultisampledAttachments = static_cast<VkBool32>(dynamic_rendering_local_read_multisampled_attachments),
            .earlyFragmentMultisampleCoverageAfterSampleCounting = static_cast<VkBool32>(early_fragment_multisample_coverage_after_sample_counting),
            .earlyFragmentSampleMaskTestBeforeSampleCounting = static_cast<VkBool32>(early_fragment_sample_mask_test_before_sample_counting),
            .depthStencilSwizzleOneSupport = static_cast<VkBool32>(depth_stencil_swizzle_one_support),
            .polygonModePointSize = static_cast<VkBool32>(polygon_mode_point_size),
            .nonStrictSinglePixelWideLinesUseParallelogram = static_cast<VkBool32>(non_strict_single_pixel_wide_lines_use_parallelogram),
            .nonStrictWideLinesUseParallelogram = static_cast<VkBool32>(non_strict_wide_lines_use_parallelogram),
            .blockTexelViewCompatibleMultipleLayers = static_cast<VkBool32>(block_texel_view_compatible_multiple_layers),
            .maxCombinedImageSamplerDescriptorCount = max_combined_image_sampler_descriptor_count,
            .fragmentShadingRateClampCombinerInputs = static_cast<VkBool32>(fragment_shading_rate_clamp_combiner_inputs),
            .defaultRobustnessStorageBuffers = static_cast<VkPipelineRobustnessBufferBehavior>(default_robustness_storage_buffers),
            .defaultRobustnessUniformBuffers = static_cast<VkPipelineRobustnessBufferBehavior>(default_robustness_uniform_buffers),
            .defaultRobustnessVertexInputs = static_cast<VkPipelineRobustnessBufferBehavior>(default_robustness_vertex_inputs),
            .defaultRobustnessImages = static_cast<VkPipelineRobustnessImageBehavior>(default_robustness_images),
            .copySrcLayoutCount = copy_src_layout_count,
            .pCopySrcLayouts = copy_src_layouts,
            .copyDstLayoutCount = copy_dst_layout_count,
            .pCopyDstLayouts = copy_dst_layouts,
            .VK_UUID_SIZE = vk_uuid_size,
            .identicalMemoryTypeRequirements = static_cast<VkBool32>(identical_memory_type_requirements)
        };
    }
};

struct PhysicalDeviceVulkanMemoryModelFeatures {
    bool vulkan_memory_model;
    bool vulkan_memory_model_device_scope;
    bool vulkan_memory_model_availability_visibility_chains;
    
    VkPhysicalDeviceVulkanMemoryModelFeatures raw() {
        return VkPhysicalDeviceVulkanMemoryModelFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES,
            .pNext = nullptr,
            .vulkanMemoryModel = static_cast<VkBool32>(vulkan_memory_model),
            .vulkanMemoryModelDeviceScope = static_cast<VkBool32>(vulkan_memory_model_device_scope),
            .vulkanMemoryModelAvailabilityVisibilityChains = static_cast<VkBool32>(vulkan_memory_model_availability_visibility_chains)
        };
    }
};

struct PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
    bool workgroup_memory_explicit_layout;
    bool workgroup_memory_explicit_layout_scalar_block_layout;
    bool workgroup_memory_explicit_layout8bit_access;
    bool workgroup_memory_explicit_layout16bit_access;
    
    VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR raw() {
        return VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR,
            .pNext = nullptr,
            .workgroupMemoryExplicitLayout = static_cast<VkBool32>(workgroup_memory_explicit_layout),
            .workgroupMemoryExplicitLayoutScalarBlockLayout = static_cast<VkBool32>(workgroup_memory_explicit_layout_scalar_block_layout),
            .workgroupMemoryExplicitLayout8BitAccess = static_cast<VkBool32>(workgroup_memory_explicit_layout8bit_access),
            .workgroupMemoryExplicitLayout16BitAccess = static_cast<VkBool32>(workgroup_memory_explicit_layout16bit_access)
        };
    }
};

struct PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
    bool ycbcr2plane444formats;
    
    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT raw() {
        return VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_YCBCR2PLANE444FORMATS_FEATURES_EXT,
            .pNext = nullptr,
            .ycbcr2plane444Formats = static_cast<VkBool32>(ycbcr2plane444formats)
        };
    }
};

struct PhysicalDeviceYcbcrDegammaFeaturesQCOM {
    bool ycbcr_degamma;
    
    VkPhysicalDeviceYcbcrDegammaFeaturesQCOM raw() {
        return VkPhysicalDeviceYcbcrDegammaFeaturesQCOM {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM,
            .pNext = nullptr,
            .ycbcrDegamma = static_cast<VkBool32>(ycbcr_degamma)
        };
    }
};

struct PhysicalDeviceYcbcrImageArraysFeaturesEXT {
    bool ycbcr_image_arrays;
    
    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT raw() {
        return VkPhysicalDeviceYcbcrImageArraysFeaturesEXT {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT,
            .pNext = nullptr,
            .ycbcrImageArrays = static_cast<VkBool32>(ycbcr_image_arrays)
        };
    }
};

struct PhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
    bool shader_zero_initialize_workgroup_memory;
    
    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures raw() {
        return VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures {
            .sType = VK_STRUCT_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES,
            .pNext = nullptr,
            .shaderZeroInitializeWorkgroupMemory = static_cast<VkBool32>(shader_zero_initialize_workgroup_memory)
        };
    }
};

struct PipelineBinaryCreateInfoKHR {
    VkPipelineBinaryKeysAndDataKHR* keys_and_data_info;
    VkPipeline pipeline;
    VkPipelineCreateInfoKHR* pipeline_create_info;
    
    VkPipelineBinaryCreateInfoKHR raw() {
        return VkPipelineBinaryCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR,
            .pNext = nullptr,
            .pKeysAndDataInfo = keys_and_data_info,
            .pipeline = pipeline,
            .pPipelineCreateInfo = pipeline_create_info
        };
    }
};

struct PipelineBinaryDataInfoKHR {
    VkPipelineBinaryKHR pipeline_binary;
    
    VkPipelineBinaryDataInfoKHR raw() {
        return VkPipelineBinaryDataInfoKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_BINARY_DATA_INFO_KHR,
            .pNext = nullptr,
            .pipelineBinary = pipeline_binary
        };
    }
};

struct PipelineBinaryDataKHR {
    size_t data_size;
    void* data;
    
    VkPipelineBinaryDataKHR raw() {
        return VkPipelineBinaryDataKHR {
            .dataSize = data_size,
            .pData = data
        };
    }
};

struct PipelineBinaryHandlesInfoKHR {
    u32 pipeline_binary_count;
    VkPipelineBinaryKHR* pipeline_binaries;
    
    VkPipelineBinaryHandlesInfoKHR raw() {
        return VkPipelineBinaryHandlesInfoKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR,
            .pNext = nullptr,
            .pipelineBinaryCount = pipeline_binary_count,
            .pPipelineBinaries = pipeline_binaries
        };
    }
};

struct PipelineBinaryInfoKHR {
    u32 binary_count;
    VkPipelineBinaryKHR* pipeline_binaries;
    
    VkPipelineBinaryInfoKHR raw() {
        return VkPipelineBinaryInfoKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_BINARY_INFO_KHR,
            .pNext = nullptr,
            .binaryCount = binary_count,
            .pPipelineBinaries = pipeline_binaries
        };
    }
};

struct PipelineBinaryKeyKHR {
    u32 key_size;
    uint8_t[] vk_max_pipeline_binary_key_size_khr;
    
    VkPipelineBinaryKeyKHR raw() {
        return VkPipelineBinaryKeyKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_BINARY_KEY_KHR,
            .pNext = nullptr,
            .keySize = key_size,
            .VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR = vk_max_pipeline_binary_key_size_khr
        };
    }
};

struct PipelineBinaryKeysAndDataKHR {
    u32 binary_count;
    VkPipelineBinaryKeyKHR* pipeline_binary_keys;
    VkPipelineBinaryDataKHR* pipeline_binary_data;
    
    VkPipelineBinaryKeysAndDataKHR raw() {
        return VkPipelineBinaryKeysAndDataKHR {
            .binaryCount = binary_count,
            .pPipelineBinaryKeys = pipeline_binary_keys,
            .pPipelineBinaryData = pipeline_binary_data
        };
    }
};

struct PipelineCacheCreateInfo {
    VkPipelineCacheCreateFlags flags;
    size_t initial_data_size;
    void* initial_data;
    
    VkPipelineCacheCreateInfo raw() {
        return VkPipelineCacheCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_CACHE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .initialDataSize = initial_data_size,
            .pInitialData = initial_data
        };
    }
};

struct PipelineCacheHeaderVersionOne {
    u32 header_size;
    PipelineCacheHeaderVersion header_version;
    u32 vendor_id;
    u32 device_id;
    uint8_t[] vk_uuid_size;
    
    VkPipelineCacheHeaderVersionOne raw() {
        return VkPipelineCacheHeaderVersionOne {
            .headerSize = header_size,
            .headerVersion = static_cast<VkPipelineCacheHeaderVersion>(header_version),
            .vendorID = vendor_id,
            .deviceID = device_id,
            .VK_UUID_SIZE = vk_uuid_size
        };
    }
};

struct PipelineColorBlendAdvancedStateCreateInfoEXT {
    bool src_premultiplied;
    bool dst_premultiplied;
    BlendOverlapEXT blend_overlap;
    
    VkPipelineColorBlendAdvancedStateCreateInfoEXT raw() {
        return VkPipelineColorBlendAdvancedStateCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .srcPremultiplied = static_cast<VkBool32>(src_premultiplied),
            .dstPremultiplied = static_cast<VkBool32>(dst_premultiplied),
            .blendOverlap = static_cast<VkBlendOverlapEXT>(blend_overlap)
        };
    }
};

struct PipelineColorBlendAttachmentState {
    bool blend_enable;
    BlendFactor src_color_blend_factor;
    BlendFactor dst_color_blend_factor;
    BlendOp color_blend_op;
    BlendFactor src_alpha_blend_factor;
    BlendFactor dst_alpha_blend_factor;
    BlendOp alpha_blend_op;
    VkColorComponentFlags color_write_mask;
    
    VkPipelineColorBlendAttachmentState raw() {
        return VkPipelineColorBlendAttachmentState {
            .blendEnable = static_cast<VkBool32>(blend_enable),
            .srcColorBlendFactor = static_cast<VkBlendFactor>(src_color_blend_factor),
            .dstColorBlendFactor = static_cast<VkBlendFactor>(dst_color_blend_factor),
            .colorBlendOp = static_cast<VkBlendOp>(color_blend_op),
            .srcAlphaBlendFactor = static_cast<VkBlendFactor>(src_alpha_blend_factor),
            .dstAlphaBlendFactor = static_cast<VkBlendFactor>(dst_alpha_blend_factor),
            .alphaBlendOp = static_cast<VkBlendOp>(alpha_blend_op),
            .colorWriteMask = color_write_mask
        };
    }
};

struct PipelineColorBlendStateCreateInfo {
    VkPipelineColorBlendStateCreateFlags flags;
    bool logic_op_enable;
    LogicOp logic_op;
    u32 attachment_count;
    VkPipelineColorBlendAttachmentState* attachments;
    float[4] blend_constants;
    
    VkPipelineColorBlendStateCreateInfo raw() {
        return VkPipelineColorBlendStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .logicOpEnable = static_cast<VkBool32>(logic_op_enable),
            .logicOp = static_cast<VkLogicOp>(logic_op),
            .attachmentCount = attachment_count,
            .pAttachments = attachments,
            .blendConstants = blend_constants
        };
    }
};

struct PipelineColorWriteCreateInfoEXT {
    u32 attachment_count;
    VkBool32* color_write_enables;
    
    VkPipelineColorWriteCreateInfoEXT raw() {
        return VkPipelineColorWriteCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .attachmentCount = attachment_count,
            .pColorWriteEnables = color_write_enables
        };
    }
};

struct PipelineCompilerControlCreateInfoAMD {
    VkPipelineCompilerControlFlagsAMD compiler_control_flags;
    
    VkPipelineCompilerControlCreateInfoAMD raw() {
        return VkPipelineCompilerControlCreateInfoAMD {
            .sType = VK_STRUCT_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD,
            .pNext = nullptr,
            .compilerControlFlags = compiler_control_flags
        };
    }
};

struct PipelineCoverageModulationStateCreateInfoNV {
    VkPipelineCoverageModulationStateCreateFlagsNV flags;
    CoverageModulationModeNV coverage_modulation_mode;
    bool coverage_modulation_table_enable;
    u32 coverage_modulation_table_count;
    float* coverage_modulation_table;
    
    VkPipelineCoverageModulationStateCreateInfoNV raw() {
        return VkPipelineCoverageModulationStateCreateInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV,
            .pNext = nullptr,
            .flags = flags,
            .coverageModulationMode = static_cast<VkCoverageModulationModeNV>(coverage_modulation_mode),
            .coverageModulationTableEnable = static_cast<VkBool32>(coverage_modulation_table_enable),
            .coverageModulationTableCount = coverage_modulation_table_count,
            .pCoverageModulationTable = coverage_modulation_table
        };
    }
};

struct PipelineCoverageReductionStateCreateInfoNV {
    VkPipelineCoverageReductionStateCreateFlagsNV flags;
    CoverageReductionModeNV coverage_reduction_mode;
    
    VkPipelineCoverageReductionStateCreateInfoNV raw() {
        return VkPipelineCoverageReductionStateCreateInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV,
            .pNext = nullptr,
            .flags = flags,
            .coverageReductionMode = static_cast<VkCoverageReductionModeNV>(coverage_reduction_mode)
        };
    }
};

struct PipelineCoverageToColorStateCreateInfoNV {
    VkPipelineCoverageToColorStateCreateFlagsNV flags;
    bool coverage_to_color_enable;
    u32 coverage_to_color_location;
    
    VkPipelineCoverageToColorStateCreateInfoNV raw() {
        return VkPipelineCoverageToColorStateCreateInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV,
            .pNext = nullptr,
            .flags = flags,
            .coverageToColorEnable = static_cast<VkBool32>(coverage_to_color_enable),
            .coverageToColorLocation = coverage_to_color_location
        };
    }
};

struct PipelineCreateFlags2CreateInfo {
    VkPipelineCreateFlags2 flags;
    
    VkPipelineCreateFlags2CreateInfo raw() {
        return VkPipelineCreateFlags2CreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_CREATE_FLAGS2CREATE_INFO,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct PipelineCreateInfoKHR {
    
    VkPipelineCreateInfoKHR raw() {
        return VkPipelineCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_CREATE_INFO_KHR,
            .pNext = nullptr,
        };
    }
};

struct PipelineCreationFeedback {
    VkPipelineCreationFeedbackFlags flags;
    uint64_t duration;
    
    VkPipelineCreationFeedback raw() {
        return VkPipelineCreationFeedback {
            .flags = flags,
            .duration = duration
        };
    }
};

struct PipelineCreationFeedbackCreateInfo {
    VkPipelineCreationFeedback* pipeline_creation_feedback;
    u32 pipeline_stage_creation_feedback_count;
    VkPipelineCreationFeedback* pipeline_stage_creation_feedbacks;
    
    VkPipelineCreationFeedbackCreateInfo raw() {
        return VkPipelineCreationFeedbackCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO,
            .pNext = nullptr,
            .pPipelineCreationFeedback = pipeline_creation_feedback,
            .pipelineStageCreationFeedbackCount = pipeline_stage_creation_feedback_count,
            .pPipelineStageCreationFeedbacks = pipeline_stage_creation_feedbacks
        };
    }
};

struct PipelineDepthStencilStateCreateInfo {
    VkPipelineDepthStencilStateCreateFlags flags;
    bool depth_test_enable;
    bool depth_write_enable;
    CompareOp depth_compare_op;
    bool depth_bounds_test_enable;
    bool stencil_test_enable;
    StencilOpState front;
    StencilOpState back;
    f32 min_depth_bounds;
    f32 max_depth_bounds;
    
    VkPipelineDepthStencilStateCreateInfo raw() {
        return VkPipelineDepthStencilStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .depthTestEnable = static_cast<VkBool32>(depth_test_enable),
            .depthWriteEnable = static_cast<VkBool32>(depth_write_enable),
            .depthCompareOp = static_cast<VkCompareOp>(depth_compare_op),
            .depthBoundsTestEnable = static_cast<VkBool32>(depth_bounds_test_enable),
            .stencilTestEnable = static_cast<VkBool32>(stencil_test_enable),
            .front = front.raw(),
            .back = back.raw(),
            .minDepthBounds = min_depth_bounds,
            .maxDepthBounds = max_depth_bounds
        };
    }
};

struct PipelineDiscardRectangleStateCreateInfoEXT {
    VkPipelineDiscardRectangleStateCreateFlagsEXT flags;
    DiscardRectangleModeEXT discard_rectangle_mode;
    u32 discard_rectangle_count;
    VkRect2D* discard_rectangles;
    
    VkPipelineDiscardRectangleStateCreateInfoEXT raw() {
        return VkPipelineDiscardRectangleStateCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags,
            .discardRectangleMode = static_cast<VkDiscardRectangleModeEXT>(discard_rectangle_mode),
            .discardRectangleCount = discard_rectangle_count,
            .pDiscardRectangles = discard_rectangles
        };
    }
};

struct PipelineDynamicStateCreateInfo {
    VkPipelineDynamicStateCreateFlags flags;
    u32 dynamic_state_count;
    VkDynamicState* dynamic_states;
    
    VkPipelineDynamicStateCreateInfo raw() {
        return VkPipelineDynamicStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .dynamicStateCount = dynamic_state_count,
            .pDynamicStates = dynamic_states
        };
    }
};

struct PipelineExecutableInfoKHR {
    VkPipeline pipeline;
    u32 executable_index;
    
    VkPipelineExecutableInfoKHR raw() {
        return VkPipelineExecutableInfoKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_EXECUTABLE_INFO_KHR,
            .pNext = nullptr,
            .pipeline = pipeline,
            .executableIndex = executable_index
        };
    }
};

struct PipelineExecutableInternalRepresentationKHR {
    char[] vk_max_description_size;
    char[] vk_max_description_size;
    bool is_text;
    size_t data_size;
    void* data;
    
    VkPipelineExecutableInternalRepresentationKHR raw() {
        return VkPipelineExecutableInternalRepresentationKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR,
            .pNext = nullptr,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .isText = static_cast<VkBool32>(is_text),
            .dataSize = data_size,
            .pData = data
        };
    }
};

struct PipelineExecutablePropertiesKHR {
    VkShaderStageFlags stages;
    char[] vk_max_description_size;
    char[] vk_max_description_size;
    u32 subgroup_size;
    
    VkPipelineExecutablePropertiesKHR raw() {
        return VkPipelineExecutablePropertiesKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR,
            .pNext = nullptr,
            .stages = stages,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .subgroupSize = subgroup_size
        };
    }
};

struct PipelineExecutableStatisticKHR {
    char[] vk_max_description_size;
    char[] vk_max_description_size;
    PipelineExecutableStatisticFormatKHR format;
    VkPipelineExecutableStatisticValueKHR value;
    
    VkPipelineExecutableStatisticKHR raw() {
        return VkPipelineExecutableStatisticKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR,
            .pNext = nullptr,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .format = static_cast<VkPipelineExecutableStatisticFormatKHR>(format),
            .value = value
        };
    }
};

struct PipelineFragmentShadingRateEnumStateCreateInfoNV {
    FragmentShadingRateTypeNV shading_rate_type;
    FragmentShadingRateNV shading_rate;
    VkFragmentShadingRateCombinerOpKHR[2] combiner_ops;
    
    VkPipelineFragmentShadingRateEnumStateCreateInfoNV raw() {
        return VkPipelineFragmentShadingRateEnumStateCreateInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV,
            .pNext = nullptr,
            .shadingRateType = static_cast<VkFragmentShadingRateTypeNV>(shading_rate_type),
            .shadingRate = static_cast<VkFragmentShadingRateNV>(shading_rate),
            .combinerOps = combiner_ops
        };
    }
};

struct PipelineFragmentShadingRateStateCreateInfoKHR {
    Extent2D fragment_size;
    VkFragmentShadingRateCombinerOpKHR[2] combiner_ops;
    
    VkPipelineFragmentShadingRateStateCreateInfoKHR raw() {
        return VkPipelineFragmentShadingRateStateCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR,
            .pNext = nullptr,
            .fragmentSize = fragment_size.raw(),
            .combinerOps = combiner_ops
        };
    }
};

struct PipelineIndirectDeviceAddressInfoNV {
    PipelineBindPoint pipeline_bind_point;
    VkPipeline pipeline;
    
    VkPipelineIndirectDeviceAddressInfoNV raw() {
        return VkPipelineIndirectDeviceAddressInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV,
            .pNext = nullptr,
            .pipelineBindPoint = static_cast<VkPipelineBindPoint>(pipeline_bind_point),
            .pipeline = pipeline
        };
    }
};

struct PipelineInfoKHR {
    VkPipeline pipeline;
    
    VkPipelineInfoKHR raw() {
        return VkPipelineInfoKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_INFO_KHR,
            .pNext = nullptr,
            .pipeline = pipeline
        };
    }
};

struct PipelineInputAssemblyStateCreateInfo {
    VkPipelineInputAssemblyStateCreateFlags flags;
    PrimitiveTopology topology;
    bool primitive_restart_enable;
    
    VkPipelineInputAssemblyStateCreateInfo raw() {
        return VkPipelineInputAssemblyStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .topology = static_cast<VkPrimitiveTopology>(topology),
            .primitiveRestartEnable = static_cast<VkBool32>(primitive_restart_enable)
        };
    }
};

struct PipelineLayoutCreateInfo {
    VkPipelineLayoutCreateFlags flags;
    u32 set_layout_count;
    VkDescriptorSetLayout* set_layouts;
    u32 push_constant_range_count;
    VkPushConstantRange* push_constant_ranges;
    
    VkPipelineLayoutCreateInfo raw() {
        return VkPipelineLayoutCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_LAYOUT_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .setLayoutCount = set_layout_count,
            .pSetLayouts = set_layouts,
            .pushConstantRangeCount = push_constant_range_count,
            .pPushConstantRanges = push_constant_ranges
        };
    }
};

struct PipelineLibraryCreateInfoKHR {
    u32 library_count;
    VkPipeline* libraries;
    
    VkPipelineLibraryCreateInfoKHR raw() {
        return VkPipelineLibraryCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR,
            .pNext = nullptr,
            .libraryCount = library_count,
            .pLibraries = libraries
        };
    }
};

struct PipelineMultisampleStateCreateInfo {
    VkPipelineMultisampleStateCreateFlags flags;
    SampleCountFlags rasterization_samples;
    bool sample_shading_enable;
    f32 min_sample_shading;
    VkSampleMask* sample_mask;
    bool alpha_to_coverage_enable;
    bool alpha_to_one_enable;
    
    VkPipelineMultisampleStateCreateInfo raw() {
        return VkPipelineMultisampleStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .rasterizationSamples = static_cast<VkSampleCountFlagBits>(rasterization_samples),
            .sampleShadingEnable = static_cast<VkBool32>(sample_shading_enable),
            .minSampleShading = min_sample_shading,
            .pSampleMask = sample_mask,
            .alphaToCoverageEnable = static_cast<VkBool32>(alpha_to_coverage_enable),
            .alphaToOneEnable = static_cast<VkBool32>(alpha_to_one_enable)
        };
    }
};

struct PipelinePropertiesIdentifierEXT {
    uint8_t[] vk_uuid_size;
    
    VkPipelinePropertiesIdentifierEXT raw() {
        return VkPipelinePropertiesIdentifierEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT,
            .pNext = nullptr,
            .VK_UUID_SIZE = vk_uuid_size
        };
    }
};

struct PipelineRasterizationConservativeStateCreateInfoEXT {
    VkPipelineRasterizationConservativeStateCreateFlagsEXT flags;
    ConservativeRasterizationModeEXT conservative_rasterization_mode;
    f32 extra_primitive_overestimation_size;
    
    VkPipelineRasterizationConservativeStateCreateInfoEXT raw() {
        return VkPipelineRasterizationConservativeStateCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags,
            .conservativeRasterizationMode = static_cast<VkConservativeRasterizationModeEXT>(conservative_rasterization_mode),
            .extraPrimitiveOverestimationSize = extra_primitive_overestimation_size
        };
    }
};

struct PipelineRasterizationDepthClipStateCreateInfoEXT {
    VkPipelineRasterizationDepthClipStateCreateFlagsEXT flags;
    bool depth_clip_enable;
    
    VkPipelineRasterizationDepthClipStateCreateInfoEXT raw() {
        return VkPipelineRasterizationDepthClipStateCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags,
            .depthClipEnable = static_cast<VkBool32>(depth_clip_enable)
        };
    }
};

struct PipelineRasterizationLineStateCreateInfo {
    LineRasterizationMode line_rasterization_mode;
    bool stippled_line_enable;
    u32 line_stipple_factor;
    u16 line_stipple_pattern;
    
    VkPipelineRasterizationLineStateCreateInfo raw() {
        return VkPipelineRasterizationLineStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO,
            .pNext = nullptr,
            .lineRasterizationMode = static_cast<VkLineRasterizationMode>(line_rasterization_mode),
            .stippledLineEnable = static_cast<VkBool32>(stippled_line_enable),
            .lineStippleFactor = line_stipple_factor,
            .lineStipplePattern = line_stipple_pattern
        };
    }
};

struct PipelineRasterizationProvokingVertexStateCreateInfoEXT {
    ProvokingVertexModeEXT provoking_vertex_mode;
    
    VkPipelineRasterizationProvokingVertexStateCreateInfoEXT raw() {
        return VkPipelineRasterizationProvokingVertexStateCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .provokingVertexMode = static_cast<VkProvokingVertexModeEXT>(provoking_vertex_mode)
        };
    }
};

struct PipelineRasterizationStateCreateInfo {
    VkPipelineRasterizationStateCreateFlags flags;
    bool depth_clamp_enable;
    bool rasterizer_discard_enable;
    PolygonMode polygon_mode;
    VkCullModeFlags cull_mode;
    FrontFace front_face;
    bool depth_bias_enable;
    f32 depth_bias_constant_factor;
    f32 depth_bias_clamp;
    f32 depth_bias_slope_factor;
    f32 line_width;
    
    VkPipelineRasterizationStateCreateInfo raw() {
        return VkPipelineRasterizationStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .depthClampEnable = static_cast<VkBool32>(depth_clamp_enable),
            .rasterizerDiscardEnable = static_cast<VkBool32>(rasterizer_discard_enable),
            .polygonMode = static_cast<VkPolygonMode>(polygon_mode),
            .cullMode = cull_mode,
            .frontFace = static_cast<VkFrontFace>(front_face),
            .depthBiasEnable = static_cast<VkBool32>(depth_bias_enable),
            .depthBiasConstantFactor = depth_bias_constant_factor,
            .depthBiasClamp = depth_bias_clamp,
            .depthBiasSlopeFactor = depth_bias_slope_factor,
            .lineWidth = line_width
        };
    }
};

struct PipelineRasterizationStateRasterizationOrderAMD {
    RasterizationOrderAMD rasterization_order;
    
    VkPipelineRasterizationStateRasterizationOrderAMD raw() {
        return VkPipelineRasterizationStateRasterizationOrderAMD {
            .sType = VK_STRUCT_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD,
            .pNext = nullptr,
            .rasterizationOrder = static_cast<VkRasterizationOrderAMD>(rasterization_order)
        };
    }
};

struct PipelineRasterizationStateStreamCreateInfoEXT {
    VkPipelineRasterizationStateStreamCreateFlagsEXT flags;
    u32 rasterization_stream;
    
    VkPipelineRasterizationStateStreamCreateInfoEXT raw() {
        return VkPipelineRasterizationStateStreamCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags,
            .rasterizationStream = rasterization_stream
        };
    }
};

struct PipelineRenderingCreateInfo {
    u32 view_mask;
    u32 color_attachment_count;
    VkFormat* color_attachment_formats;
    Format depth_attachment_format;
    Format stencil_attachment_format;
    
    VkPipelineRenderingCreateInfo raw() {
        return VkPipelineRenderingCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_RENDERING_CREATE_INFO,
            .pNext = nullptr,
            .viewMask = view_mask,
            .colorAttachmentCount = color_attachment_count,
            .pColorAttachmentFormats = color_attachment_formats,
            .depthAttachmentFormat = static_cast<VkFormat>(depth_attachment_format),
            .stencilAttachmentFormat = static_cast<VkFormat>(stencil_attachment_format)
        };
    }
};

struct PipelineRepresentativeFragmentTestStateCreateInfoNV {
    bool representative_fragment_test_enable;
    
    VkPipelineRepresentativeFragmentTestStateCreateInfoNV raw() {
        return VkPipelineRepresentativeFragmentTestStateCreateInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV,
            .pNext = nullptr,
            .representativeFragmentTestEnable = static_cast<VkBool32>(representative_fragment_test_enable)
        };
    }
};

struct PipelineRobustnessCreateInfo {
    PipelineRobustnessBufferBehavior storage_buffers;
    PipelineRobustnessBufferBehavior uniform_buffers;
    PipelineRobustnessBufferBehavior vertex_inputs;
    PipelineRobustnessImageBehavior images;
    
    VkPipelineRobustnessCreateInfo raw() {
        return VkPipelineRobustnessCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO,
            .pNext = nullptr,
            .storageBuffers = static_cast<VkPipelineRobustnessBufferBehavior>(storage_buffers),
            .uniformBuffers = static_cast<VkPipelineRobustnessBufferBehavior>(uniform_buffers),
            .vertexInputs = static_cast<VkPipelineRobustnessBufferBehavior>(vertex_inputs),
            .images = static_cast<VkPipelineRobustnessImageBehavior>(images)
        };
    }
};

struct PipelineSampleLocationsStateCreateInfoEXT {
    bool sample_locations_enable;
    SampleLocationsInfoEXT sample_locations_info;
    
    VkPipelineSampleLocationsStateCreateInfoEXT raw() {
        return VkPipelineSampleLocationsStateCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .sampleLocationsEnable = static_cast<VkBool32>(sample_locations_enable),
            .sampleLocationsInfo = sample_locations_info.raw()
        };
    }
};

struct PipelineShaderStageCreateInfo {
    VkPipelineShaderStageCreateFlags flags;
    ShaderStageFlags stage;
    VkShaderModule module;
    char* name;
    VkSpecializationInfo* specialization_info;
    
    VkPipelineShaderStageCreateInfo raw() {
        return VkPipelineShaderStageCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .stage = static_cast<VkShaderStageFlagBits>(stage),
            .module = module,
            .pName = name,
            .pSpecializationInfo = specialization_info
        };
    }
};

struct PipelineShaderStageModuleIdentifierCreateInfoEXT {
    u32 identifier_size;
    uint8_t* identifier;
    
    VkPipelineShaderStageModuleIdentifierCreateInfoEXT raw() {
        return VkPipelineShaderStageModuleIdentifierCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT,
            .pNext = nullptr,
            .identifierSize = identifier_size,
            .pIdentifier = identifier
        };
    }
};

struct PipelineShaderStageRequiredSubgroupSizeCreateInfo {
    u32 required_subgroup_size;
    
    VkPipelineShaderStageRequiredSubgroupSizeCreateInfo raw() {
        return VkPipelineShaderStageRequiredSubgroupSizeCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO,
            .pNext = nullptr,
            .requiredSubgroupSize = required_subgroup_size
        };
    }
};

struct PipelineTessellationDomainOriginStateCreateInfo {
    TessellationDomainOrigin domain_origin;
    
    VkPipelineTessellationDomainOriginStateCreateInfo raw() {
        return VkPipelineTessellationDomainOriginStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
            .pNext = nullptr,
            .domainOrigin = static_cast<VkTessellationDomainOrigin>(domain_origin)
        };
    }
};

struct PipelineTessellationStateCreateInfo {
    VkPipelineTessellationStateCreateFlags flags;
    u32 patch_control_points;
    
    VkPipelineTessellationStateCreateInfo raw() {
        return VkPipelineTessellationStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .patchControlPoints = patch_control_points
        };
    }
};

struct PipelineVertexInputDivisorStateCreateInfo {
    u32 vertex_binding_divisor_count;
    VkVertexInputBindingDivisorDescription* vertex_binding_divisors;
    
    VkPipelineVertexInputDivisorStateCreateInfo raw() {
        return VkPipelineVertexInputDivisorStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO,
            .pNext = nullptr,
            .vertexBindingDivisorCount = vertex_binding_divisor_count,
            .pVertexBindingDivisors = vertex_binding_divisors
        };
    }
};

struct PipelineVertexInputStateCreateInfo {
    VkPipelineVertexInputStateCreateFlags flags;
    u32 vertex_binding_description_count;
    VkVertexInputBindingDescription* vertex_binding_descriptions;
    u32 vertex_attribute_description_count;
    VkVertexInputAttributeDescription* vertex_attribute_descriptions;
    
    VkPipelineVertexInputStateCreateInfo raw() {
        return VkPipelineVertexInputStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .vertexBindingDescriptionCount = vertex_binding_description_count,
            .pVertexBindingDescriptions = vertex_binding_descriptions,
            .vertexAttributeDescriptionCount = vertex_attribute_description_count,
            .pVertexAttributeDescriptions = vertex_attribute_descriptions
        };
    }
};

struct PipelineViewportCoarseSampleOrderStateCreateInfoNV {
    CoarseSampleOrderTypeNV sample_order_type;
    u32 custom_sample_order_count;
    VkCoarseSampleOrderCustomNV* custom_sample_orders;
    
    VkPipelineViewportCoarseSampleOrderStateCreateInfoNV raw() {
        return VkPipelineViewportCoarseSampleOrderStateCreateInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV,
            .pNext = nullptr,
            .sampleOrderType = static_cast<VkCoarseSampleOrderTypeNV>(sample_order_type),
            .customSampleOrderCount = custom_sample_order_count,
            .pCustomSampleOrders = custom_sample_orders
        };
    }
};

struct PipelineViewportDepthClampControlCreateInfoEXT {
    DepthClampModeEXT depth_clamp_mode;
    VkDepthClampRangeEXT* depth_clamp_range;
    
    VkPipelineViewportDepthClampControlCreateInfoEXT raw() {
        return VkPipelineViewportDepthClampControlCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT,
            .pNext = nullptr,
            .depthClampMode = static_cast<VkDepthClampModeEXT>(depth_clamp_mode),
            .pDepthClampRange = depth_clamp_range
        };
    }
};

struct PipelineViewportDepthClipControlCreateInfoEXT {
    bool negative_one_to_one;
    
    VkPipelineViewportDepthClipControlCreateInfoEXT raw() {
        return VkPipelineViewportDepthClipControlCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT,
            .pNext = nullptr,
            .negativeOneToOne = static_cast<VkBool32>(negative_one_to_one)
        };
    }
};

struct PipelineViewportExclusiveScissorStateCreateInfoNV {
    u32 exclusive_scissor_count;
    VkRect2D* exclusive_scissors;
    
    VkPipelineViewportExclusiveScissorStateCreateInfoNV raw() {
        return VkPipelineViewportExclusiveScissorStateCreateInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV,
            .pNext = nullptr,
            .exclusiveScissorCount = exclusive_scissor_count,
            .pExclusiveScissors = exclusive_scissors
        };
    }
};

struct PipelineViewportShadingRateImageStateCreateInfoNV {
    bool shading_rate_image_enable;
    u32 viewport_count;
    VkShadingRatePaletteNV* shading_rate_palettes;
    
    VkPipelineViewportShadingRateImageStateCreateInfoNV raw() {
        return VkPipelineViewportShadingRateImageStateCreateInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV,
            .pNext = nullptr,
            .shadingRateImageEnable = static_cast<VkBool32>(shading_rate_image_enable),
            .viewportCount = viewport_count,
            .pShadingRatePalettes = shading_rate_palettes
        };
    }
};

struct PipelineViewportStateCreateInfo {
    VkPipelineViewportStateCreateFlags flags;
    u32 viewport_count;
    VkViewport* viewports;
    u32 scissor_count;
    VkRect2D* scissors;
    
    VkPipelineViewportStateCreateInfo raw() {
        return VkPipelineViewportStateCreateInfo {
            .sType = VK_STRUCT_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .viewportCount = viewport_count,
            .pViewports = viewports,
            .scissorCount = scissor_count,
            .pScissors = scissors
        };
    }
};

struct PipelineViewportSwizzleStateCreateInfoNV {
    VkPipelineViewportSwizzleStateCreateFlagsNV flags;
    u32 viewport_count;
    VkViewportSwizzleNV* viewport_swizzles;
    
    VkPipelineViewportSwizzleStateCreateInfoNV raw() {
        return VkPipelineViewportSwizzleStateCreateInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV,
            .pNext = nullptr,
            .flags = flags,
            .viewportCount = viewport_count,
            .pViewportSwizzles = viewport_swizzles
        };
    }
};

struct PipelineViewportWScalingStateCreateInfoNV {
    bool viewport_wscaling_enable;
    u32 viewport_count;
    VkViewportWScalingNV* viewport_wscalings;
    
    VkPipelineViewportWScalingStateCreateInfoNV raw() {
        return VkPipelineViewportWScalingStateCreateInfoNV {
            .sType = VK_STRUCT_TYPE_PIPELINE_VIEWPORT_WSCALING_STATE_CREATE_INFO_NV,
            .pNext = nullptr,
            .viewportWScalingEnable = static_cast<VkBool32>(viewport_wscaling_enable),
            .viewportCount = viewport_count,
            .pViewportWScalings = viewport_wscalings
        };
    }
};

struct PresentIdKHR {
    u32 swapchain_count;
    uint64_t* present_ids;
    
    VkPresentIdKHR raw() {
        return VkPresentIdKHR {
            .sType = VK_STRUCT_TYPE_PRESENT_ID_KHR,
            .pNext = nullptr,
            .swapchainCount = swapchain_count,
            .pPresentIds = present_ids
        };
    }
};

struct PresentInfoKHR {
    u32 wait_semaphore_count;
    VkSemaphore* wait_semaphores;
    u32 swapchain_count;
    VkSwapchainKHR* swapchains;
    uint32_t* image_indices;
    VkResult* results;
    
    VkPresentInfoKHR raw() {
        return VkPresentInfoKHR {
            .sType = VK_STRUCT_TYPE_PRESENT_INFO_KHR,
            .pNext = nullptr,
            .waitSemaphoreCount = wait_semaphore_count,
            .pWaitSemaphores = wait_semaphores,
            .swapchainCount = swapchain_count,
            .pSwapchains = swapchains,
            .pImageIndices = image_indices,
            .pResults = results
        };
    }
};

struct PresentRegionKHR {
    u32 rectangle_count;
    VkRectLayerKHR* rectangles;
    
    VkPresentRegionKHR raw() {
        return VkPresentRegionKHR {
            .rectangleCount = rectangle_count,
            .pRectangles = rectangles
        };
    }
};

struct PresentRegionsKHR {
    u32 swapchain_count;
    VkPresentRegionKHR* regions;
    
    VkPresentRegionsKHR raw() {
        return VkPresentRegionsKHR {
            .sType = VK_STRUCT_TYPE_PRESENT_REGIONS_KHR,
            .pNext = nullptr,
            .swapchainCount = swapchain_count,
            .pRegions = regions
        };
    }
};

struct PresentTimeGOOGLE {
    u32 present_id;
    uint64_t desired_present_time;
    
    VkPresentTimeGOOGLE raw() {
        return VkPresentTimeGOOGLE {
            .presentID = present_id,
            .desiredPresentTime = desired_present_time
        };
    }
};

struct PresentTimesInfoGOOGLE {
    u32 swapchain_count;
    VkPresentTimeGOOGLE* times;
    
    VkPresentTimesInfoGOOGLE raw() {
        return VkPresentTimesInfoGOOGLE {
            .sType = VK_STRUCT_TYPE_PRESENT_TIMES_INFO_GOOGLE,
            .pNext = nullptr,
            .swapchainCount = swapchain_count,
            .pTimes = times
        };
    }
};

struct PrivateDataSlotCreateInfo {
    VkPrivateDataSlotCreateFlags flags;
    
    VkPrivateDataSlotCreateInfo raw() {
        return VkPrivateDataSlotCreateInfo {
            .sType = VK_STRUCT_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct ProtectedSubmitInfo {
    bool protected_submit;
    
    VkProtectedSubmitInfo raw() {
        return VkProtectedSubmitInfo {
            .sType = VK_STRUCT_TYPE_PROTECTED_SUBMIT_INFO,
            .pNext = nullptr,
            .protectedSubmit = static_cast<VkBool32>(protected_submit)
        };
    }
};

struct PushConstantRange {
    VkShaderStageFlags stage_flags;
    u32 offset;
    u32 size;
    
    VkPushConstantRange raw() {
        return VkPushConstantRange {
            .stageFlags = stage_flags,
            .offset = offset,
            .size = size
        };
    }
};

struct PushConstantsInfo {
    VkPipelineLayout layout;
    VkShaderStageFlags stage_flags;
    u32 offset;
    u32 size;
    void* values;
    
    VkPushConstantsInfo raw() {
        return VkPushConstantsInfo {
            .sType = VK_STRUCT_TYPE_PUSH_CONSTANTS_INFO,
            .pNext = nullptr,
            .layout = layout,
            .stageFlags = stage_flags,
            .offset = offset,
            .size = size,
            .pValues = values
        };
    }
};

struct PushDescriptorSetInfo {
    VkShaderStageFlags stage_flags;
    VkPipelineLayout layout;
    u32 set;
    u32 descriptor_write_count;
    VkWriteDescriptorSet* descriptor_writes;
    
    VkPushDescriptorSetInfo raw() {
        return VkPushDescriptorSetInfo {
            .sType = VK_STRUCT_TYPE_PUSH_DESCRIPTOR_SET_INFO,
            .pNext = nullptr,
            .stageFlags = stage_flags,
            .layout = layout,
            .set = set,
            .descriptorWriteCount = descriptor_write_count,
            .pDescriptorWrites = descriptor_writes
        };
    }
};

struct PushDescriptorSetWithTemplateInfo {
    VkDescriptorUpdateTemplate descriptor_update_template;
    VkPipelineLayout layout;
    u32 set;
    void* data;
    
    VkPushDescriptorSetWithTemplateInfo raw() {
        return VkPushDescriptorSetWithTemplateInfo {
            .sType = VK_STRUCT_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO,
            .pNext = nullptr,
            .descriptorUpdateTemplate = descriptor_update_template,
            .layout = layout,
            .set = set,
            .pData = data
        };
    }
};

struct QueryLowLatencySupportNV {
    void* queried_low_latency_data;
    
    VkQueryLowLatencySupportNV raw() {
        return VkQueryLowLatencySupportNV {
            .sType = VK_STRUCT_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV,
            .pNext = nullptr,
            .pQueriedLowLatencyData = queried_low_latency_data
        };
    }
};

struct QueryPoolCreateInfo {
    VkQueryPoolCreateFlags flags;
    QueryType query_type;
    u32 query_count;
    VkQueryPipelineStatisticFlags pipeline_statistics;
    
    VkQueryPoolCreateInfo raw() {
        return VkQueryPoolCreateInfo {
            .sType = VK_STRUCT_TYPE_QUERY_POOL_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .queryType = static_cast<VkQueryType>(query_type),
            .queryCount = query_count,
            .pipelineStatistics = pipeline_statistics
        };
    }
};

struct QueryPoolPerformanceCreateInfoKHR {
    u32 queue_family_index;
    u32 counter_index_count;
    uint32_t* counter_indices;
    
    VkQueryPoolPerformanceCreateInfoKHR raw() {
        return VkQueryPoolPerformanceCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR,
            .pNext = nullptr,
            .queueFamilyIndex = queue_family_index,
            .counterIndexCount = counter_index_count,
            .pCounterIndices = counter_indices
        };
    }
};

struct QueryPoolPerformanceQueryCreateInfoINTEL {
    QueryPoolSamplingModeINTEL performance_counters_sampling;
    
    VkQueryPoolPerformanceQueryCreateInfoINTEL raw() {
        return VkQueryPoolPerformanceQueryCreateInfoINTEL {
            .sType = VK_STRUCT_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL,
            .pNext = nullptr,
            .performanceCountersSampling = static_cast<VkQueryPoolSamplingModeINTEL>(performance_counters_sampling)
        };
    }
};

struct QueryPoolVideoEncodeFeedbackCreateInfoKHR {
    VkVideoEncodeFeedbackFlagsKHR encode_feedback_flags;
    
    VkQueryPoolVideoEncodeFeedbackCreateInfoKHR raw() {
        return VkQueryPoolVideoEncodeFeedbackCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR,
            .pNext = nullptr,
            .encodeFeedbackFlags = encode_feedback_flags
        };
    }
};

struct QueueFamilyCheckpointProperties2NV {
    VkPipelineStageFlags2 checkpoint_execution_stage_mask;
    
    VkQueueFamilyCheckpointProperties2NV raw() {
        return VkQueueFamilyCheckpointProperties2NV {
            .sType = VK_STRUCT_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES2NV,
            .pNext = nullptr,
            .checkpointExecutionStageMask = checkpoint_execution_stage_mask
        };
    }
};

struct QueueFamilyCheckpointPropertiesNV {
    VkPipelineStageFlags checkpoint_execution_stage_mask;
    
    VkQueueFamilyCheckpointPropertiesNV raw() {
        return VkQueueFamilyCheckpointPropertiesNV {
            .sType = VK_STRUCT_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV,
            .pNext = nullptr,
            .checkpointExecutionStageMask = checkpoint_execution_stage_mask
        };
    }
};

struct QueueFamilyGlobalPriorityProperties {
    u32 priority_count;
    VkQueueGlobalPriority[] vk_max_global_priority_size;
    
    VkQueueFamilyGlobalPriorityProperties raw() {
        return VkQueueFamilyGlobalPriorityProperties {
            .sType = VK_STRUCT_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES,
            .pNext = nullptr,
            .priorityCount = priority_count,
            .VK_MAX_GLOBAL_PRIORITY_SIZE = vk_max_global_priority_size
        };
    }
};

struct QueueFamilyProperties {
    VkQueueFlags queue_flags;
    u32 queue_count;
    u32 timestamp_valid_bits;
    Extent3D min_image_transfer_granularity;
    
    VkQueueFamilyProperties raw() {
        return VkQueueFamilyProperties {
            .queueFlags = queue_flags,
            .queueCount = queue_count,
            .timestampValidBits = timestamp_valid_bits,
            .minImageTransferGranularity = min_image_transfer_granularity.raw()
        };
    }
};

struct QueueFamilyProperties2 {
    QueueFamilyProperties queue_family_properties;
    
    VkQueueFamilyProperties2 raw() {
        return VkQueueFamilyProperties2 {
            .sType = VK_STRUCT_TYPE_QUEUE_FAMILY_PROPERTIES2,
            .pNext = nullptr,
            .queueFamilyProperties = queue_family_properties.raw()
        };
    }
};

struct QueueFamilyQueryResultStatusPropertiesKHR {
    bool query_result_status_support;
    
    VkQueueFamilyQueryResultStatusPropertiesKHR raw() {
        return VkQueueFamilyQueryResultStatusPropertiesKHR {
            .sType = VK_STRUCT_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR,
            .pNext = nullptr,
            .queryResultStatusSupport = static_cast<VkBool32>(query_result_status_support)
        };
    }
};

struct QueueFamilyVideoPropertiesKHR {
    VkVideoCodecOperationFlagsKHR video_codec_operations;
    
    VkQueueFamilyVideoPropertiesKHR raw() {
        return VkQueueFamilyVideoPropertiesKHR {
            .sType = VK_STRUCT_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR,
            .pNext = nullptr,
            .videoCodecOperations = video_codec_operations
        };
    }
};

struct RayTracingPipelineClusterAccelerationStructureCreateInfoNV {
    bool allow_cluster_acceleration_structure;
    
    VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV raw() {
        return VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV {
            .sType = VK_STRUCT_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV,
            .pNext = nullptr,
            .allowClusterAccelerationStructure = static_cast<VkBool32>(allow_cluster_acceleration_structure)
        };
    }
};

struct RayTracingPipelineCreateInfoKHR {
    VkPipelineCreateFlags flags;
    u32 stage_count;
    VkPipelineShaderStageCreateInfo* stages;
    u32 group_count;
    VkRayTracingShaderGroupCreateInfoKHR* groups;
    u32 max_pipeline_ray_recursion_depth;
    VkPipelineLibraryCreateInfoKHR* library_info;
    VkRayTracingPipelineInterfaceCreateInfoKHR* library_interface;
    VkPipelineDynamicStateCreateInfo* dynamic_state;
    VkPipelineLayout layout;
    VkPipeline base_pipeline_handle;
    i32 base_pipeline_index;
    
    VkRayTracingPipelineCreateInfoKHR raw() {
        return VkRayTracingPipelineCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .stageCount = stage_count,
            .pStages = stages,
            .groupCount = group_count,
            .pGroups = groups,
            .maxPipelineRayRecursionDepth = max_pipeline_ray_recursion_depth,
            .pLibraryInfo = library_info,
            .pLibraryInterface = library_interface,
            .pDynamicState = dynamic_state,
            .layout = layout,
            .basePipelineHandle = base_pipeline_handle,
            .basePipelineIndex = base_pipeline_index
        };
    }
};

struct RayTracingPipelineCreateInfoNV {
    VkPipelineCreateFlags flags;
    u32 stage_count;
    VkPipelineShaderStageCreateInfo* stages;
    u32 group_count;
    VkRayTracingShaderGroupCreateInfoNV* groups;
    u32 max_recursion_depth;
    VkPipelineLayout layout;
    VkPipeline base_pipeline_handle;
    i32 base_pipeline_index;
    
    VkRayTracingPipelineCreateInfoNV raw() {
        return VkRayTracingPipelineCreateInfoNV {
            .sType = VK_STRUCT_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV,
            .pNext = nullptr,
            .flags = flags,
            .stageCount = stage_count,
            .pStages = stages,
            .groupCount = group_count,
            .pGroups = groups,
            .maxRecursionDepth = max_recursion_depth,
            .layout = layout,
            .basePipelineHandle = base_pipeline_handle,
            .basePipelineIndex = base_pipeline_index
        };
    }
};

struct RayTracingPipelineInterfaceCreateInfoKHR {
    u32 max_pipeline_ray_payload_size;
    u32 max_pipeline_ray_hit_attribute_size;
    
    VkRayTracingPipelineInterfaceCreateInfoKHR raw() {
        return VkRayTracingPipelineInterfaceCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR,
            .pNext = nullptr,
            .maxPipelineRayPayloadSize = max_pipeline_ray_payload_size,
            .maxPipelineRayHitAttributeSize = max_pipeline_ray_hit_attribute_size
        };
    }
};

struct RayTracingShaderGroupCreateInfoKHR {
    RayTracingShaderGroupTypeKHR type;
    u32 general_shader;
    u32 closest_hit_shader;
    u32 any_hit_shader;
    u32 intersection_shader;
    void* shader_group_capture_replay_handle;
    
    VkRayTracingShaderGroupCreateInfoKHR raw() {
        return VkRayTracingShaderGroupCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR,
            .pNext = nullptr,
            .type = static_cast<VkRayTracingShaderGroupTypeKHR>(type),
            .generalShader = general_shader,
            .closestHitShader = closest_hit_shader,
            .anyHitShader = any_hit_shader,
            .intersectionShader = intersection_shader,
            .pShaderGroupCaptureReplayHandle = shader_group_capture_replay_handle
        };
    }
};

struct RayTracingShaderGroupCreateInfoNV {
    RayTracingShaderGroupTypeKHR type;
    u32 general_shader;
    u32 closest_hit_shader;
    u32 any_hit_shader;
    u32 intersection_shader;
    
    VkRayTracingShaderGroupCreateInfoNV raw() {
        return VkRayTracingShaderGroupCreateInfoNV {
            .sType = VK_STRUCT_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV,
            .pNext = nullptr,
            .type = static_cast<VkRayTracingShaderGroupTypeKHR>(type),
            .generalShader = general_shader,
            .closestHitShader = closest_hit_shader,
            .anyHitShader = any_hit_shader,
            .intersectionShader = intersection_shader
        };
    }
};

struct Rect2D {
    Offset2D offset;
    Extent2D extent;
    
    VkRect2D raw() {
        return VkRect2D {
            .offset = offset.raw(),
            .extent = extent.raw()
        };
    }
};

struct RectLayerKHR {
    Offset2D offset;
    Extent2D extent;
    u32 layer;
    
    VkRectLayerKHR raw() {
        return VkRectLayerKHR {
            .offset = offset.raw(),
            .extent = extent.raw(),
            .layer = layer
        };
    }
};

struct RefreshCycleDurationGOOGLE {
    uint64_t refresh_duration;
    
    VkRefreshCycleDurationGOOGLE raw() {
        return VkRefreshCycleDurationGOOGLE {
            .refreshDuration = refresh_duration
        };
    }
};

struct ReleaseCapturedPipelineDataInfoKHR {
    VkPipeline pipeline;
    
    VkReleaseCapturedPipelineDataInfoKHR raw() {
        return VkReleaseCapturedPipelineDataInfoKHR {
            .sType = VK_STRUCT_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR,
            .pNext = nullptr,
            .pipeline = pipeline
        };
    }
};

struct ReleaseSwapchainImagesInfoEXT {
    VkSwapchainKHR swapchain;
    u32 image_index_count;
    uint32_t* image_indices;
    
    VkReleaseSwapchainImagesInfoEXT raw() {
        return VkReleaseSwapchainImagesInfoEXT {
            .sType = VK_STRUCT_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT,
            .pNext = nullptr,
            .swapchain = swapchain,
            .imageIndexCount = image_index_count,
            .pImageIndices = image_indices
        };
    }
};

struct RenderPassAttachmentBeginInfo {
    u32 attachment_count;
    VkImageView* attachments;
    
    VkRenderPassAttachmentBeginInfo raw() {
        return VkRenderPassAttachmentBeginInfo {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO,
            .pNext = nullptr,
            .attachmentCount = attachment_count,
            .pAttachments = attachments
        };
    }
};

struct RenderPassBeginInfo {
    VkRenderPass render_pass;
    VkFramebuffer framebuffer;
    Rect2D render_area;
    u32 clear_value_count;
    VkClearValue* clear_values;
    
    VkRenderPassBeginInfo raw() {
        return VkRenderPassBeginInfo {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_BEGIN_INFO,
            .pNext = nullptr,
            .renderPass = render_pass,
            .framebuffer = framebuffer,
            .renderArea = render_area.raw(),
            .clearValueCount = clear_value_count,
            .pClearValues = clear_values
        };
    }
};

struct RenderPassCreateInfo {
    VkRenderPassCreateFlags flags;
    u32 attachment_count;
    VkAttachmentDescription* attachments;
    u32 subpass_count;
    VkSubpassDescription* subpasses;
    u32 dependency_count;
    VkSubpassDependency* dependencies;
    
    VkRenderPassCreateInfo raw() {
        return VkRenderPassCreateInfo {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .attachmentCount = attachment_count,
            .pAttachments = attachments,
            .subpassCount = subpass_count,
            .pSubpasses = subpasses,
            .dependencyCount = dependency_count,
            .pDependencies = dependencies
        };
    }
};

struct RenderPassCreateInfo2 {
    VkRenderPassCreateFlags flags;
    u32 attachment_count;
    VkAttachmentDescription2* attachments;
    u32 subpass_count;
    VkSubpassDescription2* subpasses;
    u32 dependency_count;
    VkSubpassDependency2* dependencies;
    u32 correlated_view_mask_count;
    uint32_t* correlated_view_masks;
    
    VkRenderPassCreateInfo2 raw() {
        return VkRenderPassCreateInfo2 {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_CREATE_INFO2,
            .pNext = nullptr,
            .flags = flags,
            .attachmentCount = attachment_count,
            .pAttachments = attachments,
            .subpassCount = subpass_count,
            .pSubpasses = subpasses,
            .dependencyCount = dependency_count,
            .pDependencies = dependencies,
            .correlatedViewMaskCount = correlated_view_mask_count,
            .pCorrelatedViewMasks = correlated_view_masks
        };
    }
};

struct RenderPassCreationControlEXT {
    bool disallow_merging;
    
    VkRenderPassCreationControlEXT raw() {
        return VkRenderPassCreationControlEXT {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_CREATION_CONTROL_EXT,
            .pNext = nullptr,
            .disallowMerging = static_cast<VkBool32>(disallow_merging)
        };
    }
};

struct RenderPassCreationFeedbackCreateInfoEXT {
    VkRenderPassCreationFeedbackInfoEXT* render_pass_feedback;
    
    VkRenderPassCreationFeedbackCreateInfoEXT raw() {
        return VkRenderPassCreationFeedbackCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT,
            .pNext = nullptr,
            .pRenderPassFeedback = render_pass_feedback
        };
    }
};

struct RenderPassCreationFeedbackInfoEXT {
    u32 post_merge_subpass_count;
    
    VkRenderPassCreationFeedbackInfoEXT raw() {
        return VkRenderPassCreationFeedbackInfoEXT {
            .postMergeSubpassCount = post_merge_subpass_count
        };
    }
};

struct RenderPassFragmentDensityMapCreateInfoEXT {
    AttachmentReference fragment_density_map_attachment;
    
    VkRenderPassFragmentDensityMapCreateInfoEXT raw() {
        return VkRenderPassFragmentDensityMapCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT,
            .pNext = nullptr,
            .fragmentDensityMapAttachment = fragment_density_map_attachment.raw()
        };
    }
};

struct RenderPassFragmentDensityMapOffsetEndInfoEXT {
    u32 fragment_density_offset_count;
    VkOffset2D* fragment_density_offsets;
    
    VkRenderPassFragmentDensityMapOffsetEndInfoEXT raw() {
        return VkRenderPassFragmentDensityMapOffsetEndInfoEXT {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT,
            .pNext = nullptr,
            .fragmentDensityOffsetCount = fragment_density_offset_count,
            .pFragmentDensityOffsets = fragment_density_offsets
        };
    }
};

struct RenderPassInputAttachmentAspectCreateInfo {
    u32 aspect_reference_count;
    VkInputAttachmentAspectReference* aspect_references;
    
    VkRenderPassInputAttachmentAspectCreateInfo raw() {
        return VkRenderPassInputAttachmentAspectCreateInfo {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
            .pNext = nullptr,
            .aspectReferenceCount = aspect_reference_count,
            .pAspectReferences = aspect_references
        };
    }
};

struct RenderPassMultiviewCreateInfo {
    u32 subpass_count;
    uint32_t* view_masks;
    u32 dependency_count;
    int32_t* view_offsets;
    u32 correlation_mask_count;
    uint32_t* correlation_masks;
    
    VkRenderPassMultiviewCreateInfo raw() {
        return VkRenderPassMultiviewCreateInfo {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
            .pNext = nullptr,
            .subpassCount = subpass_count,
            .pViewMasks = view_masks,
            .dependencyCount = dependency_count,
            .pViewOffsets = view_offsets,
            .correlationMaskCount = correlation_mask_count,
            .pCorrelationMasks = correlation_masks
        };
    }
};

struct RenderPassSampleLocationsBeginInfoEXT {
    u32 attachment_initial_sample_locations_count;
    VkAttachmentSampleLocationsEXT* attachment_initial_sample_locations;
    u32 post_subpass_sample_locations_count;
    VkSubpassSampleLocationsEXT* post_subpass_sample_locations;
    
    VkRenderPassSampleLocationsBeginInfoEXT raw() {
        return VkRenderPassSampleLocationsBeginInfoEXT {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT,
            .pNext = nullptr,
            .attachmentInitialSampleLocationsCount = attachment_initial_sample_locations_count,
            .pAttachmentInitialSampleLocations = attachment_initial_sample_locations,
            .postSubpassSampleLocationsCount = post_subpass_sample_locations_count,
            .pPostSubpassSampleLocations = post_subpass_sample_locations
        };
    }
};

struct RenderPassStripeBeginInfoARM {
    u32 stripe_info_count;
    VkRenderPassStripeInfoARM* stripe_infos;
    
    VkRenderPassStripeBeginInfoARM raw() {
        return VkRenderPassStripeBeginInfoARM {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM,
            .pNext = nullptr,
            .stripeInfoCount = stripe_info_count,
            .pStripeInfos = stripe_infos
        };
    }
};

struct RenderPassStripeInfoARM {
    Rect2D stripe_area;
    
    VkRenderPassStripeInfoARM raw() {
        return VkRenderPassStripeInfoARM {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_STRIPE_INFO_ARM,
            .pNext = nullptr,
            .stripeArea = stripe_area.raw()
        };
    }
};

struct RenderPassStripeSubmitInfoARM {
    u32 stripe_semaphore_info_count;
    VkSemaphoreSubmitInfo* stripe_semaphore_infos;
    
    VkRenderPassStripeSubmitInfoARM raw() {
        return VkRenderPassStripeSubmitInfoARM {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM,
            .pNext = nullptr,
            .stripeSemaphoreInfoCount = stripe_semaphore_info_count,
            .pStripeSemaphoreInfos = stripe_semaphore_infos
        };
    }
};

struct RenderPassSubpassFeedbackCreateInfoEXT {
    VkRenderPassSubpassFeedbackInfoEXT* subpass_feedback;
    
    VkRenderPassSubpassFeedbackCreateInfoEXT raw() {
        return VkRenderPassSubpassFeedbackCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT,
            .pNext = nullptr,
            .pSubpassFeedback = subpass_feedback
        };
    }
};

struct RenderPassSubpassFeedbackInfoEXT {
    SubpassMergeStatusEXT subpass_merge_status;
    char[] vk_max_description_size;
    u32 post_merge_index;
    
    VkRenderPassSubpassFeedbackInfoEXT raw() {
        return VkRenderPassSubpassFeedbackInfoEXT {
            .subpassMergeStatus = static_cast<VkSubpassMergeStatusEXT>(subpass_merge_status),
            .VK_MAX_DESCRIPTION_SIZE = vk_max_description_size,
            .postMergeIndex = post_merge_index
        };
    }
};

struct RenderPassTileShadingCreateInfoQCOM {
    VkTileShadingRenderPassFlagsQCOM flags;
    Extent2D tile_apron_size;
    
    VkRenderPassTileShadingCreateInfoQCOM raw() {
        return VkRenderPassTileShadingCreateInfoQCOM {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM,
            .pNext = nullptr,
            .flags = flags,
            .tileApronSize = tile_apron_size.raw()
        };
    }
};

struct RenderPassTransformBeginInfoQCOM {
    SurfaceTransformFlagsKHR transform;
    
    VkRenderPassTransformBeginInfoQCOM raw() {
        return VkRenderPassTransformBeginInfoQCOM {
            .sType = VK_STRUCT_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM,
            .pNext = nullptr,
            .transform = static_cast<VkSurfaceTransformFlagBitsKHR>(transform)
        };
    }
};

struct RenderingAreaInfo {
    u32 view_mask;
    u32 color_attachment_count;
    VkFormat* color_attachment_formats;
    Format depth_attachment_format;
    Format stencil_attachment_format;
    
    VkRenderingAreaInfo raw() {
        return VkRenderingAreaInfo {
            .sType = VK_STRUCT_TYPE_RENDERING_AREA_INFO,
            .pNext = nullptr,
            .viewMask = view_mask,
            .colorAttachmentCount = color_attachment_count,
            .pColorAttachmentFormats = color_attachment_formats,
            .depthAttachmentFormat = static_cast<VkFormat>(depth_attachment_format),
            .stencilAttachmentFormat = static_cast<VkFormat>(stencil_attachment_format)
        };
    }
};

struct RenderingAttachmentInfo {
    VkImageView image_view;
    ImageLayout image_layout;
    ResolveModeFlags resolve_mode;
    VkImageView resolve_image_view;
    ImageLayout resolve_image_layout;
    AttachmentLoadOp load_op;
    AttachmentStoreOp store_op;
    VkClearValue clear_value;
    
    VkRenderingAttachmentInfo raw() {
        return VkRenderingAttachmentInfo {
            .sType = VK_STRUCT_TYPE_RENDERING_ATTACHMENT_INFO,
            .pNext = nullptr,
            .imageView = image_view,
            .imageLayout = static_cast<VkImageLayout>(image_layout),
            .resolveMode = static_cast<VkResolveModeFlagBits>(resolve_mode),
            .resolveImageView = resolve_image_view,
            .resolveImageLayout = static_cast<VkImageLayout>(resolve_image_layout),
            .loadOp = static_cast<VkAttachmentLoadOp>(load_op),
            .storeOp = static_cast<VkAttachmentStoreOp>(store_op),
            .clearValue = clear_value
        };
    }
};

struct RenderingAttachmentLocationInfo {
    u32 color_attachment_count;
    uint32_t* color_attachment_locations;
    
    VkRenderingAttachmentLocationInfo raw() {
        return VkRenderingAttachmentLocationInfo {
            .sType = VK_STRUCT_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO,
            .pNext = nullptr,
            .colorAttachmentCount = color_attachment_count,
            .pColorAttachmentLocations = color_attachment_locations
        };
    }
};

struct RenderingEndInfoEXT {
    
    VkRenderingEndInfoEXT raw() {
        return VkRenderingEndInfoEXT {
            .sType = VK_STRUCT_TYPE_RENDERING_END_INFO_EXT,
            .pNext = nullptr,
        };
    }
};

struct RenderingFragmentDensityMapAttachmentInfoEXT {
    VkImageView image_view;
    ImageLayout image_layout;
    
    VkRenderingFragmentDensityMapAttachmentInfoEXT raw() {
        return VkRenderingFragmentDensityMapAttachmentInfoEXT {
            .sType = VK_STRUCT_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT,
            .pNext = nullptr,
            .imageView = image_view,
            .imageLayout = static_cast<VkImageLayout>(image_layout)
        };
    }
};

struct RenderingFragmentShadingRateAttachmentInfoKHR {
    VkImageView image_view;
    ImageLayout image_layout;
    Extent2D shading_rate_attachment_texel_size;
    
    VkRenderingFragmentShadingRateAttachmentInfoKHR raw() {
        return VkRenderingFragmentShadingRateAttachmentInfoKHR {
            .sType = VK_STRUCT_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR,
            .pNext = nullptr,
            .imageView = image_view,
            .imageLayout = static_cast<VkImageLayout>(image_layout),
            .shadingRateAttachmentTexelSize = shading_rate_attachment_texel_size.raw()
        };
    }
};

struct RenderingInfo {
    VkRenderingFlags flags;
    Rect2D render_area;
    u32 layer_count;
    u32 view_mask;
    u32 color_attachment_count;
    VkRenderingAttachmentInfo* color_attachments;
    VkRenderingAttachmentInfo* depth_attachment;
    VkRenderingAttachmentInfo* stencil_attachment;
    
    VkRenderingInfo raw() {
        return VkRenderingInfo {
            .sType = VK_STRUCT_TYPE_RENDERING_INFO,
            .pNext = nullptr,
            .flags = flags,
            .renderArea = render_area.raw(),
            .layerCount = layer_count,
            .viewMask = view_mask,
            .colorAttachmentCount = color_attachment_count,
            .pColorAttachments = color_attachments,
            .pDepthAttachment = depth_attachment,
            .pStencilAttachment = stencil_attachment
        };
    }
};

struct RenderingInputAttachmentIndexInfo {
    u32 color_attachment_count;
    uint32_t* color_attachment_input_indices;
    uint32_t* depth_input_attachment_index;
    uint32_t* stencil_input_attachment_index;
    
    VkRenderingInputAttachmentIndexInfo raw() {
        return VkRenderingInputAttachmentIndexInfo {
            .sType = VK_STRUCT_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO,
            .pNext = nullptr,
            .colorAttachmentCount = color_attachment_count,
            .pColorAttachmentInputIndices = color_attachment_input_indices,
            .pDepthInputAttachmentIndex = depth_input_attachment_index,
            .pStencilInputAttachmentIndex = stencil_input_attachment_index
        };
    }
};

struct ResolveImageInfo2 {
    VkImage src_image;
    ImageLayout src_image_layout;
    VkImage dst_image;
    ImageLayout dst_image_layout;
    u32 region_count;
    VkImageResolve2* regions;
    
    VkResolveImageInfo2 raw() {
        return VkResolveImageInfo2 {
            .sType = VK_STRUCT_TYPE_RESOLVE_IMAGE_INFO2,
            .pNext = nullptr,
            .srcImage = src_image,
            .srcImageLayout = static_cast<VkImageLayout>(src_image_layout),
            .dstImage = dst_image,
            .dstImageLayout = static_cast<VkImageLayout>(dst_image_layout),
            .regionCount = region_count,
            .pRegions = regions
        };
    }
};

struct SRTDataNV {
    f32 sx;
    f32 a;
    f32 b;
    f32 pvx;
    f32 sy;
    f32 c;
    f32 pvy;
    f32 sz;
    f32 pvz;
    f32 qx;
    f32 qy;
    f32 qz;
    f32 qw;
    f32 tx;
    f32 ty;
    f32 tz;
    
    VkSRTDataNV raw() {
        return VkSRTDataNV {
            .sx = sx,
            .a = a,
            .b = b,
            .pvx = pvx,
            .sy = sy,
            .c = c,
            .pvy = pvy,
            .sz = sz,
            .pvz = pvz,
            .qx = qx,
            .qy = qy,
            .qz = qz,
            .qw = qw,
            .tx = tx,
            .ty = ty,
            .tz = tz
        };
    }
};

struct SampleLocationEXT {
    f32 x;
    f32 y;
    
    VkSampleLocationEXT raw() {
        return VkSampleLocationEXT {
            .x = x,
            .y = y
        };
    }
};

struct SampleLocationsInfoEXT {
    SampleCountFlags sample_locations_per_pixel;
    Extent2D sample_location_grid_size;
    u32 sample_locations_count;
    VkSampleLocationEXT* sample_locations;
    
    VkSampleLocationsInfoEXT raw() {
        return VkSampleLocationsInfoEXT {
            .sType = VK_STRUCT_TYPE_SAMPLE_LOCATIONS_INFO_EXT,
            .pNext = nullptr,
            .sampleLocationsPerPixel = static_cast<VkSampleCountFlagBits>(sample_locations_per_pixel),
            .sampleLocationGridSize = sample_location_grid_size.raw(),
            .sampleLocationsCount = sample_locations_count,
            .pSampleLocations = sample_locations
        };
    }
};

struct SamplerBlockMatchWindowCreateInfoQCOM {
    Extent2D window_extent;
    BlockMatchWindowCompareModeQCOM window_compare_mode;
    
    VkSamplerBlockMatchWindowCreateInfoQCOM raw() {
        return VkSamplerBlockMatchWindowCreateInfoQCOM {
            .sType = VK_STRUCT_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM,
            .pNext = nullptr,
            .windowExtent = window_extent.raw(),
            .windowCompareMode = static_cast<VkBlockMatchWindowCompareModeQCOM>(window_compare_mode)
        };
    }
};

struct SamplerBorderColorComponentMappingCreateInfoEXT {
    ComponentMapping components;
    bool srgb;
    
    VkSamplerBorderColorComponentMappingCreateInfoEXT raw() {
        return VkSamplerBorderColorComponentMappingCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT,
            .pNext = nullptr,
            .components = components.raw(),
            .srgb = static_cast<VkBool32>(srgb)
        };
    }
};

struct SamplerCaptureDescriptorDataInfoEXT {
    VkSampler sampler;
    
    VkSamplerCaptureDescriptorDataInfoEXT raw() {
        return VkSamplerCaptureDescriptorDataInfoEXT {
            .sType = VK_STRUCT_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT,
            .pNext = nullptr,
            .sampler = sampler
        };
    }
};

struct SamplerCreateInfo {
    VkSamplerCreateFlags flags;
    Filter mag_filter;
    Filter min_filter;
    SamplerMipmapMode mipmap_mode;
    SamplerAddressMode address_mode_u;
    SamplerAddressMode address_mode_v;
    SamplerAddressMode address_mode_w;
    f32 mip_lod_bias;
    bool anisotropy_enable;
    f32 max_anisotropy;
    bool compare_enable;
    CompareOp compare_op;
    f32 min_lod;
    f32 max_lod;
    BorderColor border_color;
    bool unnormalized_coordinates;
    
    VkSamplerCreateInfo raw() {
        return VkSamplerCreateInfo {
            .sType = VK_STRUCT_TYPE_SAMPLER_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .magFilter = static_cast<VkFilter>(mag_filter),
            .minFilter = static_cast<VkFilter>(min_filter),
            .mipmapMode = static_cast<VkSamplerMipmapMode>(mipmap_mode),
            .addressModeU = static_cast<VkSamplerAddressMode>(address_mode_u),
            .addressModeV = static_cast<VkSamplerAddressMode>(address_mode_v),
            .addressModeW = static_cast<VkSamplerAddressMode>(address_mode_w),
            .mipLodBias = mip_lod_bias,
            .anisotropyEnable = static_cast<VkBool32>(anisotropy_enable),
            .maxAnisotropy = max_anisotropy,
            .compareEnable = static_cast<VkBool32>(compare_enable),
            .compareOp = static_cast<VkCompareOp>(compare_op),
            .minLod = min_lod,
            .maxLod = max_lod,
            .borderColor = static_cast<VkBorderColor>(border_color),
            .unnormalizedCoordinates = static_cast<VkBool32>(unnormalized_coordinates)
        };
    }
};

struct SamplerCubicWeightsCreateInfoQCOM {
    CubicFilterWeightsQCOM cubic_weights;
    
    VkSamplerCubicWeightsCreateInfoQCOM raw() {
        return VkSamplerCubicWeightsCreateInfoQCOM {
            .sType = VK_STRUCT_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM,
            .pNext = nullptr,
            .cubicWeights = static_cast<VkCubicFilterWeightsQCOM>(cubic_weights)
        };
    }
};

struct SamplerCustomBorderColorCreateInfoEXT {
    VkClearColorValue custom_border_color;
    Format format;
    
    VkSamplerCustomBorderColorCreateInfoEXT raw() {
        return VkSamplerCustomBorderColorCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT,
            .pNext = nullptr,
            .customBorderColor = custom_border_color,
            .format = static_cast<VkFormat>(format)
        };
    }
};

struct SamplerReductionModeCreateInfo {
    SamplerReductionMode reduction_mode;
    
    VkSamplerReductionModeCreateInfo raw() {
        return VkSamplerReductionModeCreateInfo {
            .sType = VK_STRUCT_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO,
            .pNext = nullptr,
            .reductionMode = static_cast<VkSamplerReductionMode>(reduction_mode)
        };
    }
};

struct SamplerYcbcrConversionCreateInfo {
    Format format;
    SamplerYcbcrModelConversion ycbcr_model;
    SamplerYcbcrRange ycbcr_range;
    ComponentMapping components;
    ChromaLocation x_chroma_offset;
    ChromaLocation y_chroma_offset;
    Filter chroma_filter;
    bool force_explicit_reconstruction;
    
    VkSamplerYcbcrConversionCreateInfo raw() {
        return VkSamplerYcbcrConversionCreateInfo {
            .sType = VK_STRUCT_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
            .pNext = nullptr,
            .format = static_cast<VkFormat>(format),
            .ycbcrModel = static_cast<VkSamplerYcbcrModelConversion>(ycbcr_model),
            .ycbcrRange = static_cast<VkSamplerYcbcrRange>(ycbcr_range),
            .components = components.raw(),
            .xChromaOffset = static_cast<VkChromaLocation>(x_chroma_offset),
            .yChromaOffset = static_cast<VkChromaLocation>(y_chroma_offset),
            .chromaFilter = static_cast<VkFilter>(chroma_filter),
            .forceExplicitReconstruction = static_cast<VkBool32>(force_explicit_reconstruction)
        };
    }
};

struct SamplerYcbcrConversionImageFormatProperties {
    u32 combined_image_sampler_descriptor_count;
    
    VkSamplerYcbcrConversionImageFormatProperties raw() {
        return VkSamplerYcbcrConversionImageFormatProperties {
            .sType = VK_STRUCT_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
            .pNext = nullptr,
            .combinedImageSamplerDescriptorCount = combined_image_sampler_descriptor_count
        };
    }
};

struct SamplerYcbcrConversionInfo {
    VkSamplerYcbcrConversion conversion;
    
    VkSamplerYcbcrConversionInfo raw() {
        return VkSamplerYcbcrConversionInfo {
            .sType = VK_STRUCT_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
            .pNext = nullptr,
            .conversion = conversion
        };
    }
};

struct SamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM {
    bool enable_ydegamma;
    bool enable_cb_cr_degamma;
    
    VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM raw() {
        return VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM {
            .sType = VK_STRUCT_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM,
            .pNext = nullptr,
            .enableYDegamma = static_cast<VkBool32>(enable_ydegamma),
            .enableCbCrDegamma = static_cast<VkBool32>(enable_cb_cr_degamma)
        };
    }
};

struct SemaphoreCreateInfo {
    VkSemaphoreCreateFlags flags;
    
    VkSemaphoreCreateInfo raw() {
        return VkSemaphoreCreateInfo {
            .sType = VK_STRUCT_TYPE_SEMAPHORE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct SemaphoreGetFdInfoKHR {
    VkSemaphore semaphore;
    ExternalSemaphoreHandleTypeFlags handle_type;
    
    VkSemaphoreGetFdInfoKHR raw() {
        return VkSemaphoreGetFdInfoKHR {
            .sType = VK_STRUCT_TYPE_SEMAPHORE_GET_FD_INFO_KHR,
            .pNext = nullptr,
            .semaphore = semaphore,
            .handleType = static_cast<VkExternalSemaphoreHandleTypeFlagBits>(handle_type)
        };
    }
};

struct SemaphoreSignalInfo {
    VkSemaphore semaphore;
    uint64_t value;
    
    VkSemaphoreSignalInfo raw() {
        return VkSemaphoreSignalInfo {
            .sType = VK_STRUCT_TYPE_SEMAPHORE_SIGNAL_INFO,
            .pNext = nullptr,
            .semaphore = semaphore,
            .value = value
        };
    }
};

struct SemaphoreSubmitInfo {
    VkSemaphore semaphore;
    uint64_t value;
    VkPipelineStageFlags2 stage_mask;
    u32 device_index;
    
    VkSemaphoreSubmitInfo raw() {
        return VkSemaphoreSubmitInfo {
            .sType = VK_STRUCT_TYPE_SEMAPHORE_SUBMIT_INFO,
            .pNext = nullptr,
            .semaphore = semaphore,
            .value = value,
            .stageMask = stage_mask,
            .deviceIndex = device_index
        };
    }
};

struct SemaphoreTypeCreateInfo {
    SemaphoreType semaphore_type;
    uint64_t initial_value;
    
    VkSemaphoreTypeCreateInfo raw() {
        return VkSemaphoreTypeCreateInfo {
            .sType = VK_STRUCT_TYPE_SEMAPHORE_TYPE_CREATE_INFO,
            .pNext = nullptr,
            .semaphoreType = static_cast<VkSemaphoreType>(semaphore_type),
            .initialValue = initial_value
        };
    }
};

struct SemaphoreWaitInfo {
    VkSemaphoreWaitFlags flags;
    u32 semaphore_count;
    VkSemaphore* semaphores;
    uint64_t* values;
    
    VkSemaphoreWaitInfo raw() {
        return VkSemaphoreWaitInfo {
            .sType = VK_STRUCT_TYPE_SEMAPHORE_WAIT_INFO,
            .pNext = nullptr,
            .flags = flags,
            .semaphoreCount = semaphore_count,
            .pSemaphores = semaphores,
            .pValues = values
        };
    }
};

struct SetDescriptorBufferOffsetsInfoEXT {
    VkShaderStageFlags stage_flags;
    VkPipelineLayout layout;
    u32 first_set;
    u32 set_count;
    uint32_t* buffer_indices;
    VkDeviceSize* offsets;
    
    VkSetDescriptorBufferOffsetsInfoEXT raw() {
        return VkSetDescriptorBufferOffsetsInfoEXT {
            .sType = VK_STRUCT_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT,
            .pNext = nullptr,
            .stageFlags = stage_flags,
            .layout = layout,
            .firstSet = first_set,
            .setCount = set_count,
            .pBufferIndices = buffer_indices,
            .pOffsets = offsets
        };
    }
};

struct SetLatencyMarkerInfoNV {
    uint64_t present_id;
    LatencyMarkerNV marker;
    
    VkSetLatencyMarkerInfoNV raw() {
        return VkSetLatencyMarkerInfoNV {
            .sType = VK_STRUCT_TYPE_SET_LATENCY_MARKER_INFO_NV,
            .pNext = nullptr,
            .presentID = present_id,
            .marker = static_cast<VkLatencyMarkerNV>(marker)
        };
    }
};

struct SetPresentConfigNV {
    u32 num_frames_per_batch;
    u32 present_config_feedback;
    
    VkSetPresentConfigNV raw() {
        return VkSetPresentConfigNV {
            .sType = VK_STRUCT_TYPE_SET_PRESENT_CONFIG_NV,
            .pNext = nullptr,
            .numFramesPerBatch = num_frames_per_batch,
            .presentConfigFeedback = present_config_feedback
        };
    }
};

struct SetStateFlagsIndirectCommandNV {
    u32 data;
    
    VkSetStateFlagsIndirectCommandNV raw() {
        return VkSetStateFlagsIndirectCommandNV {
            .data = data
        };
    }
};

struct ShaderCreateInfoEXT {
    VkShaderCreateFlagsEXT flags;
    ShaderStageFlags stage;
    VkShaderStageFlags next_stage;
    ShaderCodeTypeEXT code_type;
    size_t code_size;
    void* code;
    char* name;
    u32 set_layout_count;
    VkDescriptorSetLayout* set_layouts;
    u32 push_constant_range_count;
    VkPushConstantRange* push_constant_ranges;
    VkSpecializationInfo* specialization_info;
    
    VkShaderCreateInfoEXT raw() {
        return VkShaderCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_SHADER_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags,
            .stage = static_cast<VkShaderStageFlagBits>(stage),
            .nextStage = next_stage,
            .codeType = static_cast<VkShaderCodeTypeEXT>(code_type),
            .codeSize = code_size,
            .pCode = code,
            .pName = name,
            .setLayoutCount = set_layout_count,
            .pSetLayouts = set_layouts,
            .pushConstantRangeCount = push_constant_range_count,
            .pPushConstantRanges = push_constant_ranges,
            .pSpecializationInfo = specialization_info
        };
    }
};

struct ShaderModuleCreateInfo {
    VkShaderModuleCreateFlags flags;
    size_t code_size;
    uint32_t* code;
    
    VkShaderModuleCreateInfo raw() {
        return VkShaderModuleCreateInfo {
            .sType = VK_STRUCT_TYPE_SHADER_MODULE_CREATE_INFO,
            .pNext = nullptr,
            .flags = flags,
            .codeSize = code_size,
            .pCode = code
        };
    }
};

struct ShaderModuleIdentifierEXT {
    u32 identifier_size;
    uint8_t[] vk_max_shader_module_identifier_size_ext;
    
    VkShaderModuleIdentifierEXT raw() {
        return VkShaderModuleIdentifierEXT {
            .sType = VK_STRUCT_TYPE_SHADER_MODULE_IDENTIFIER_EXT,
            .pNext = nullptr,
            .identifierSize = identifier_size,
            .VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT = vk_max_shader_module_identifier_size_ext
        };
    }
};

struct ShaderModuleValidationCacheCreateInfoEXT {
    VkValidationCacheEXT validation_cache;
    
    VkShaderModuleValidationCacheCreateInfoEXT raw() {
        return VkShaderModuleValidationCacheCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .validationCache = validation_cache
        };
    }
};

struct ShaderResourceUsageAMD {
    u32 num_used_vgprs;
    u32 num_used_sgprs;
    u32 lds_size_per_local_work_group;
    size_t lds_usage_size_in_bytes;
    size_t scratch_mem_usage_in_bytes;
    
    VkShaderResourceUsageAMD raw() {
        return VkShaderResourceUsageAMD {
            .numUsedVgprs = num_used_vgprs,
            .numUsedSgprs = num_used_sgprs,
            .ldsSizePerLocalWorkGroup = lds_size_per_local_work_group,
            .ldsUsageSizeInBytes = lds_usage_size_in_bytes,
            .scratchMemUsageInBytes = scratch_mem_usage_in_bytes
        };
    }
};

struct ShaderStatisticsInfoAMD {
    VkShaderStageFlags shader_stage_mask;
    ShaderResourceUsageAMD resource_usage;
    u32 num_physical_vgprs;
    u32 num_physical_sgprs;
    u32 num_available_vgprs;
    u32 num_available_sgprs;
    uint32_t[3] compute_work_group_size;
    
    VkShaderStatisticsInfoAMD raw() {
        return VkShaderStatisticsInfoAMD {
            .shaderStageMask = shader_stage_mask,
            .resourceUsage = resource_usage.raw(),
            .numPhysicalVgprs = num_physical_vgprs,
            .numPhysicalSgprs = num_physical_sgprs,
            .numAvailableVgprs = num_available_vgprs,
            .numAvailableSgprs = num_available_sgprs,
            .computeWorkGroupSize = compute_work_group_size
        };
    }
};

struct ShadingRatePaletteNV {
    u32 shading_rate_palette_entry_count;
    VkShadingRatePaletteEntryNV* shading_rate_palette_entries;
    
    VkShadingRatePaletteNV raw() {
        return VkShadingRatePaletteNV {
            .shadingRatePaletteEntryCount = shading_rate_palette_entry_count,
            .pShadingRatePaletteEntries = shading_rate_palette_entries
        };
    }
};

struct SharedPresentSurfaceCapabilitiesKHR {
    VkImageUsageFlags shared_present_supported_usage_flags;
    
    VkSharedPresentSurfaceCapabilitiesKHR raw() {
        return VkSharedPresentSurfaceCapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR,
            .pNext = nullptr,
            .sharedPresentSupportedUsageFlags = shared_present_supported_usage_flags
        };
    }
};

struct SparseBufferMemoryBindInfo {
    VkBuffer buffer;
    u32 bind_count;
    VkSparseMemoryBind* binds;
    
    VkSparseBufferMemoryBindInfo raw() {
        return VkSparseBufferMemoryBindInfo {
            .buffer = buffer,
            .bindCount = bind_count,
            .pBinds = binds
        };
    }
};

struct SparseImageFormatProperties {
    VkImageAspectFlags aspect_mask;
    Extent3D image_granularity;
    VkSparseImageFormatFlags flags;
    
    VkSparseImageFormatProperties raw() {
        return VkSparseImageFormatProperties {
            .aspectMask = aspect_mask,
            .imageGranularity = image_granularity.raw(),
            .flags = flags
        };
    }
};

struct SparseImageFormatProperties2 {
    SparseImageFormatProperties properties;
    
    VkSparseImageFormatProperties2 raw() {
        return VkSparseImageFormatProperties2 {
            .sType = VK_STRUCT_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES2,
            .pNext = nullptr,
            .properties = properties.raw()
        };
    }
};

struct SparseImageMemoryBind {
    ImageSubresource subresource;
    Offset3D offset;
    Extent3D extent;
    VkDeviceMemory memory;
    VkDeviceSize memory_offset;
    VkSparseMemoryBindFlags flags;
    
    VkSparseImageMemoryBind raw() {
        return VkSparseImageMemoryBind {
            .subresource = subresource.raw(),
            .offset = offset.raw(),
            .extent = extent.raw(),
            .memory = memory,
            .memoryOffset = memory_offset,
            .flags = flags
        };
    }
};

struct SparseImageMemoryBindInfo {
    VkImage image;
    u32 bind_count;
    VkSparseImageMemoryBind* binds;
    
    VkSparseImageMemoryBindInfo raw() {
        return VkSparseImageMemoryBindInfo {
            .image = image,
            .bindCount = bind_count,
            .pBinds = binds
        };
    }
};

struct SparseImageMemoryRequirements {
    SparseImageFormatProperties format_properties;
    u32 image_mip_tail_first_lod;
    VkDeviceSize image_mip_tail_size;
    VkDeviceSize image_mip_tail_offset;
    VkDeviceSize image_mip_tail_stride;
    
    VkSparseImageMemoryRequirements raw() {
        return VkSparseImageMemoryRequirements {
            .formatProperties = format_properties.raw(),
            .imageMipTailFirstLod = image_mip_tail_first_lod,
            .imageMipTailSize = image_mip_tail_size,
            .imageMipTailOffset = image_mip_tail_offset,
            .imageMipTailStride = image_mip_tail_stride
        };
    }
};

struct SparseImageMemoryRequirements2 {
    SparseImageMemoryRequirements memory_requirements;
    
    VkSparseImageMemoryRequirements2 raw() {
        return VkSparseImageMemoryRequirements2 {
            .sType = VK_STRUCT_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS2,
            .pNext = nullptr,
            .memoryRequirements = memory_requirements.raw()
        };
    }
};

struct SparseImageOpaqueMemoryBindInfo {
    VkImage image;
    u32 bind_count;
    VkSparseMemoryBind* binds;
    
    VkSparseImageOpaqueMemoryBindInfo raw() {
        return VkSparseImageOpaqueMemoryBindInfo {
            .image = image,
            .bindCount = bind_count,
            .pBinds = binds
        };
    }
};

struct SparseMemoryBind {
    VkDeviceSize resource_offset;
    VkDeviceSize size;
    VkDeviceMemory memory;
    VkDeviceSize memory_offset;
    VkSparseMemoryBindFlags flags;
    
    VkSparseMemoryBind raw() {
        return VkSparseMemoryBind {
            .resourceOffset = resource_offset,
            .size = size,
            .memory = memory,
            .memoryOffset = memory_offset,
            .flags = flags
        };
    }
};

struct SpecializationInfo {
    u32 map_entry_count;
    VkSpecializationMapEntry* map_entries;
    size_t data_size;
    void* data;
    
    VkSpecializationInfo raw() {
        return VkSpecializationInfo {
            .mapEntryCount = map_entry_count,
            .pMapEntries = map_entries,
            .dataSize = data_size,
            .pData = data
        };
    }
};

struct SpecializationMapEntry {
    u32 constant_id;
    u32 offset;
    size_t size;
    
    VkSpecializationMapEntry raw() {
        return VkSpecializationMapEntry {
            .constantID = constant_id,
            .offset = offset,
            .size = size
        };
    }
};

struct StencilOpState {
    StencilOp fail_op;
    StencilOp pass_op;
    StencilOp depth_fail_op;
    CompareOp compare_op;
    u32 compare_mask;
    u32 write_mask;
    u32 reference;
    
    VkStencilOpState raw() {
        return VkStencilOpState {
            .failOp = static_cast<VkStencilOp>(fail_op),
            .passOp = static_cast<VkStencilOp>(pass_op),
            .depthFailOp = static_cast<VkStencilOp>(depth_fail_op),
            .compareOp = static_cast<VkCompareOp>(compare_op),
            .compareMask = compare_mask,
            .writeMask = write_mask,
            .reference = reference
        };
    }
};

struct StridedDeviceAddressNV {
    VkDeviceAddress start_address;
    VkDeviceSize stride_in_bytes;
    
    VkStridedDeviceAddressNV raw() {
        return VkStridedDeviceAddressNV {
            .startAddress = start_address,
            .strideInBytes = stride_in_bytes
        };
    }
};

struct StridedDeviceAddressRegionKHR {
    VkDeviceAddress device_address;
    VkDeviceSize stride;
    VkDeviceSize size;
    
    VkStridedDeviceAddressRegionKHR raw() {
        return VkStridedDeviceAddressRegionKHR {
            .deviceAddress = device_address,
            .stride = stride,
            .size = size
        };
    }
};

struct SubmitInfo {
    u32 wait_semaphore_count;
    VkSemaphore* wait_semaphores;
    VkPipelineStageFlags* wait_dst_stage_mask;
    u32 command_buffer_count;
    VkCommandBuffer* command_buffers;
    u32 signal_semaphore_count;
    VkSemaphore* signal_semaphores;
    
    VkSubmitInfo raw() {
        return VkSubmitInfo {
            .sType = VK_STRUCT_TYPE_SUBMIT_INFO,
            .pNext = nullptr,
            .waitSemaphoreCount = wait_semaphore_count,
            .pWaitSemaphores = wait_semaphores,
            .pWaitDstStageMask = wait_dst_stage_mask,
            .commandBufferCount = command_buffer_count,
            .pCommandBuffers = command_buffers,
            .signalSemaphoreCount = signal_semaphore_count,
            .pSignalSemaphores = signal_semaphores
        };
    }
};

struct SubmitInfo2 {
    VkSubmitFlags flags;
    u32 wait_semaphore_info_count;
    VkSemaphoreSubmitInfo* wait_semaphore_infos;
    u32 command_buffer_info_count;
    VkCommandBufferSubmitInfo* command_buffer_infos;
    u32 signal_semaphore_info_count;
    VkSemaphoreSubmitInfo* signal_semaphore_infos;
    
    VkSubmitInfo2 raw() {
        return VkSubmitInfo2 {
            .sType = VK_STRUCT_TYPE_SUBMIT_INFO2,
            .pNext = nullptr,
            .flags = flags,
            .waitSemaphoreInfoCount = wait_semaphore_info_count,
            .pWaitSemaphoreInfos = wait_semaphore_infos,
            .commandBufferInfoCount = command_buffer_info_count,
            .pCommandBufferInfos = command_buffer_infos,
            .signalSemaphoreInfoCount = signal_semaphore_info_count,
            .pSignalSemaphoreInfos = signal_semaphore_infos
        };
    }
};

struct SubpassBeginInfo {
    SubpassContents contents;
    
    VkSubpassBeginInfo raw() {
        return VkSubpassBeginInfo {
            .sType = VK_STRUCT_TYPE_SUBPASS_BEGIN_INFO,
            .pNext = nullptr,
            .contents = static_cast<VkSubpassContents>(contents)
        };
    }
};

struct SubpassDependency {
    u32 src_subpass;
    u32 dst_subpass;
    VkPipelineStageFlags src_stage_mask;
    VkPipelineStageFlags dst_stage_mask;
    VkAccessFlags src_access_mask;
    VkAccessFlags dst_access_mask;
    VkDependencyFlags dependency_flags;
    
    VkSubpassDependency raw() {
        return VkSubpassDependency {
            .srcSubpass = src_subpass,
            .dstSubpass = dst_subpass,
            .srcStageMask = src_stage_mask,
            .dstStageMask = dst_stage_mask,
            .srcAccessMask = src_access_mask,
            .dstAccessMask = dst_access_mask,
            .dependencyFlags = dependency_flags
        };
    }
};

struct SubpassDependency2 {
    u32 src_subpass;
    u32 dst_subpass;
    VkPipelineStageFlags src_stage_mask;
    VkPipelineStageFlags dst_stage_mask;
    VkAccessFlags src_access_mask;
    VkAccessFlags dst_access_mask;
    VkDependencyFlags dependency_flags;
    i32 view_offset;
    
    VkSubpassDependency2 raw() {
        return VkSubpassDependency2 {
            .sType = VK_STRUCT_TYPE_SUBPASS_DEPENDENCY2,
            .pNext = nullptr,
            .srcSubpass = src_subpass,
            .dstSubpass = dst_subpass,
            .srcStageMask = src_stage_mask,
            .dstStageMask = dst_stage_mask,
            .srcAccessMask = src_access_mask,
            .dstAccessMask = dst_access_mask,
            .dependencyFlags = dependency_flags,
            .viewOffset = view_offset
        };
    }
};

struct SubpassDescription {
    VkSubpassDescriptionFlags flags;
    PipelineBindPoint pipeline_bind_point;
    u32 input_attachment_count;
    VkAttachmentReference* input_attachments;
    u32 color_attachment_count;
    VkAttachmentReference* color_attachments;
    VkAttachmentReference* resolve_attachments;
    VkAttachmentReference* depth_stencil_attachment;
    u32 preserve_attachment_count;
    uint32_t* preserve_attachments;
    
    VkSubpassDescription raw() {
        return VkSubpassDescription {
            .flags = flags,
            .pipelineBindPoint = static_cast<VkPipelineBindPoint>(pipeline_bind_point),
            .inputAttachmentCount = input_attachment_count,
            .pInputAttachments = input_attachments,
            .colorAttachmentCount = color_attachment_count,
            .pColorAttachments = color_attachments,
            .pResolveAttachments = resolve_attachments,
            .pDepthStencilAttachment = depth_stencil_attachment,
            .preserveAttachmentCount = preserve_attachment_count,
            .pPreserveAttachments = preserve_attachments
        };
    }
};

struct SubpassDescription2 {
    VkSubpassDescriptionFlags flags;
    PipelineBindPoint pipeline_bind_point;
    u32 view_mask;
    u32 input_attachment_count;
    VkAttachmentReference2* input_attachments;
    u32 color_attachment_count;
    VkAttachmentReference2* color_attachments;
    VkAttachmentReference2* resolve_attachments;
    VkAttachmentReference2* depth_stencil_attachment;
    u32 preserve_attachment_count;
    uint32_t* preserve_attachments;
    
    VkSubpassDescription2 raw() {
        return VkSubpassDescription2 {
            .sType = VK_STRUCT_TYPE_SUBPASS_DESCRIPTION2,
            .pNext = nullptr,
            .flags = flags,
            .pipelineBindPoint = static_cast<VkPipelineBindPoint>(pipeline_bind_point),
            .viewMask = view_mask,
            .inputAttachmentCount = input_attachment_count,
            .pInputAttachments = input_attachments,
            .colorAttachmentCount = color_attachment_count,
            .pColorAttachments = color_attachments,
            .pResolveAttachments = resolve_attachments,
            .pDepthStencilAttachment = depth_stencil_attachment,
            .preserveAttachmentCount = preserve_attachment_count,
            .pPreserveAttachments = preserve_attachments
        };
    }
};

struct SubpassDescriptionDepthStencilResolve {
    ResolveModeFlags depth_resolve_mode;
    ResolveModeFlags stencil_resolve_mode;
    VkAttachmentReference2* depth_stencil_resolve_attachment;
    
    VkSubpassDescriptionDepthStencilResolve raw() {
        return VkSubpassDescriptionDepthStencilResolve {
            .sType = VK_STRUCT_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE,
            .pNext = nullptr,
            .depthResolveMode = static_cast<VkResolveModeFlagBits>(depth_resolve_mode),
            .stencilResolveMode = static_cast<VkResolveModeFlagBits>(stencil_resolve_mode),
            .pDepthStencilResolveAttachment = depth_stencil_resolve_attachment
        };
    }
};

struct SubpassEndInfo {
    
    VkSubpassEndInfo raw() {
        return VkSubpassEndInfo {
            .sType = VK_STRUCT_TYPE_SUBPASS_END_INFO,
            .pNext = nullptr,
        };
    }
};

struct SubpassResolvePerformanceQueryEXT {
    bool optimal;
    
    VkSubpassResolvePerformanceQueryEXT raw() {
        return VkSubpassResolvePerformanceQueryEXT {
            .sType = VK_STRUCT_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT,
            .pNext = nullptr,
            .optimal = static_cast<VkBool32>(optimal)
        };
    }
};

struct SubpassSampleLocationsEXT {
    u32 subpass_index;
    SampleLocationsInfoEXT sample_locations_info;
    
    VkSubpassSampleLocationsEXT raw() {
        return VkSubpassSampleLocationsEXT {
            .subpassIndex = subpass_index,
            .sampleLocationsInfo = sample_locations_info.raw()
        };
    }
};

struct SubpassShadingPipelineCreateInfoHUAWEI {
    VkRenderPass render_pass;
    u32 subpass;
    
    VkSubpassShadingPipelineCreateInfoHUAWEI raw() {
        return VkSubpassShadingPipelineCreateInfoHUAWEI {
            .sType = VK_STRUCT_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI,
            .pNext = nullptr,
            .renderPass = render_pass,
            .subpass = subpass
        };
    }
};

struct SubresourceHostMemcpySize {
    VkDeviceSize size;
    
    VkSubresourceHostMemcpySize raw() {
        return VkSubresourceHostMemcpySize {
            .sType = VK_STRUCT_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE,
            .pNext = nullptr,
            .size = size
        };
    }
};

struct SubresourceLayout {
    VkDeviceSize offset;
    VkDeviceSize size;
    VkDeviceSize row_pitch;
    VkDeviceSize array_pitch;
    VkDeviceSize depth_pitch;
    
    VkSubresourceLayout raw() {
        return VkSubresourceLayout {
            .offset = offset,
            .size = size,
            .rowPitch = row_pitch,
            .arrayPitch = array_pitch,
            .depthPitch = depth_pitch
        };
    }
};

struct SubresourceLayout2 {
    SubresourceLayout subresource_layout;
    
    VkSubresourceLayout2 raw() {
        return VkSubresourceLayout2 {
            .sType = VK_STRUCT_TYPE_SUBRESOURCE_LAYOUT2,
            .pNext = nullptr,
            .subresourceLayout = subresource_layout.raw()
        };
    }
};

struct SurfaceCapabilities2EXT {
    u32 min_image_count;
    u32 max_image_count;
    Extent2D current_extent;
    Extent2D min_image_extent;
    Extent2D max_image_extent;
    u32 max_image_array_layers;
    VkSurfaceTransformFlagsKHR supported_transforms;
    SurfaceTransformFlagsKHR current_transform;
    VkCompositeAlphaFlagsKHR supported_composite_alpha;
    VkImageUsageFlags supported_usage_flags;
    VkSurfaceCounterFlagsEXT supported_surface_counters;
    
    VkSurfaceCapabilities2EXT raw() {
        return VkSurfaceCapabilities2EXT {
            .sType = VK_STRUCT_TYPE_SURFACE_CAPABILITIES2EXT,
            .pNext = nullptr,
            .minImageCount = min_image_count,
            .maxImageCount = max_image_count,
            .currentExtent = current_extent.raw(),
            .minImageExtent = min_image_extent.raw(),
            .maxImageExtent = max_image_extent.raw(),
            .maxImageArrayLayers = max_image_array_layers,
            .supportedTransforms = supported_transforms,
            .currentTransform = static_cast<VkSurfaceTransformFlagBitsKHR>(current_transform),
            .supportedCompositeAlpha = supported_composite_alpha,
            .supportedUsageFlags = supported_usage_flags,
            .supportedSurfaceCounters = supported_surface_counters
        };
    }
};

struct SurfaceCapabilities2KHR {
    SurfaceCapabilitiesKHR surface_capabilities;
    
    VkSurfaceCapabilities2KHR raw() {
        return VkSurfaceCapabilities2KHR {
            .sType = VK_STRUCT_TYPE_SURFACE_CAPABILITIES2KHR,
            .pNext = nullptr,
            .surfaceCapabilities = surface_capabilities.raw()
        };
    }
};

struct SurfaceCapabilitiesKHR {
    u32 min_image_count;
    u32 max_image_count;
    Extent2D current_extent;
    Extent2D min_image_extent;
    Extent2D max_image_extent;
    u32 max_image_array_layers;
    VkSurfaceTransformFlagsKHR supported_transforms;
    SurfaceTransformFlagsKHR current_transform;
    VkCompositeAlphaFlagsKHR supported_composite_alpha;
    VkImageUsageFlags supported_usage_flags;
    
    VkSurfaceCapabilitiesKHR raw() {
        return VkSurfaceCapabilitiesKHR {
            .minImageCount = min_image_count,
            .maxImageCount = max_image_count,
            .currentExtent = current_extent.raw(),
            .minImageExtent = min_image_extent.raw(),
            .maxImageExtent = max_image_extent.raw(),
            .maxImageArrayLayers = max_image_array_layers,
            .supportedTransforms = supported_transforms,
            .currentTransform = static_cast<VkSurfaceTransformFlagBitsKHR>(current_transform),
            .supportedCompositeAlpha = supported_composite_alpha,
            .supportedUsageFlags = supported_usage_flags
        };
    }
};

struct SurfaceCapabilitiesPresentBarrierNV {
    bool present_barrier_supported;
    
    VkSurfaceCapabilitiesPresentBarrierNV raw() {
        return VkSurfaceCapabilitiesPresentBarrierNV {
            .sType = VK_STRUCT_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV,
            .pNext = nullptr,
            .presentBarrierSupported = static_cast<VkBool32>(present_barrier_supported)
        };
    }
};

struct SurfaceFormat2KHR {
    SurfaceFormatKHR surface_format;
    
    VkSurfaceFormat2KHR raw() {
        return VkSurfaceFormat2KHR {
            .sType = VK_STRUCT_TYPE_SURFACE_FORMAT2KHR,
            .pNext = nullptr,
            .surfaceFormat = surface_format.raw()
        };
    }
};

struct SurfaceFormatKHR {
    Format format;
    ColorSpaceKHR color_space;
    
    VkSurfaceFormatKHR raw() {
        return VkSurfaceFormatKHR {
            .format = static_cast<VkFormat>(format),
            .colorSpace = static_cast<VkColorSpaceKHR>(color_space)
        };
    }
};

struct SurfacePresentModeCompatibilityEXT {
    u32 present_mode_count;
    VkPresentModeKHR* present_modes;
    
    VkSurfacePresentModeCompatibilityEXT raw() {
        return VkSurfacePresentModeCompatibilityEXT {
            .sType = VK_STRUCT_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT,
            .pNext = nullptr,
            .presentModeCount = present_mode_count,
            .pPresentModes = present_modes
        };
    }
};

struct SurfacePresentModeEXT {
    PresentModeKHR present_mode;
    
    VkSurfacePresentModeEXT raw() {
        return VkSurfacePresentModeEXT {
            .sType = VK_STRUCT_TYPE_SURFACE_PRESENT_MODE_EXT,
            .pNext = nullptr,
            .presentMode = static_cast<VkPresentModeKHR>(present_mode)
        };
    }
};

struct SurfacePresentScalingCapabilitiesEXT {
    VkPresentScalingFlagsEXT supported_present_scaling;
    VkPresentGravityFlagsEXT supported_present_gravity_x;
    VkPresentGravityFlagsEXT supported_present_gravity_y;
    Extent2D min_scaled_image_extent;
    Extent2D max_scaled_image_extent;
    
    VkSurfacePresentScalingCapabilitiesEXT raw() {
        return VkSurfacePresentScalingCapabilitiesEXT {
            .sType = VK_STRUCT_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT,
            .pNext = nullptr,
            .supportedPresentScaling = supported_present_scaling,
            .supportedPresentGravityX = supported_present_gravity_x,
            .supportedPresentGravityY = supported_present_gravity_y,
            .minScaledImageExtent = min_scaled_image_extent.raw(),
            .maxScaledImageExtent = max_scaled_image_extent.raw()
        };
    }
};

struct SurfaceProtectedCapabilitiesKHR {
    bool supports_protected;
    
    VkSurfaceProtectedCapabilitiesKHR raw() {
        return VkSurfaceProtectedCapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR,
            .pNext = nullptr,
            .supportsProtected = static_cast<VkBool32>(supports_protected)
        };
    }
};

struct SwapchainCounterCreateInfoEXT {
    VkSurfaceCounterFlagsEXT surface_counters;
    
    VkSwapchainCounterCreateInfoEXT raw() {
        return VkSwapchainCounterCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT,
            .pNext = nullptr,
            .surfaceCounters = surface_counters
        };
    }
};

struct SwapchainCreateInfoKHR {
    VkSwapchainCreateFlagsKHR flags;
    VkSurfaceKHR surface;
    u32 min_image_count;
    Format image_format;
    ColorSpaceKHR image_color_space;
    Extent2D image_extent;
    u32 image_array_layers;
    VkImageUsageFlags image_usage;
    SharingMode image_sharing_mode;
    u32 queue_family_index_count;
    uint32_t* queue_family_indices;
    SurfaceTransformFlagsKHR pre_transform;
    CompositeAlphaFlagsKHR composite_alpha;
    PresentModeKHR present_mode;
    bool clipped;
    VkSwapchainKHR old_swapchain;
    
    VkSwapchainCreateInfoKHR raw() {
        return VkSwapchainCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .surface = surface,
            .minImageCount = min_image_count,
            .imageFormat = static_cast<VkFormat>(image_format),
            .imageColorSpace = static_cast<VkColorSpaceKHR>(image_color_space),
            .imageExtent = image_extent.raw(),
            .imageArrayLayers = image_array_layers,
            .imageUsage = image_usage,
            .imageSharingMode = static_cast<VkSharingMode>(image_sharing_mode),
            .queueFamilyIndexCount = queue_family_index_count,
            .pQueueFamilyIndices = queue_family_indices,
            .preTransform = static_cast<VkSurfaceTransformFlagBitsKHR>(pre_transform),
            .compositeAlpha = static_cast<VkCompositeAlphaFlagBitsKHR>(composite_alpha),
            .presentMode = static_cast<VkPresentModeKHR>(present_mode),
            .clipped = static_cast<VkBool32>(clipped),
            .oldSwapchain = old_swapchain
        };
    }
};

struct SwapchainDisplayNativeHdrCreateInfoAMD {
    bool local_dimming_enable;
    
    VkSwapchainDisplayNativeHdrCreateInfoAMD raw() {
        return VkSwapchainDisplayNativeHdrCreateInfoAMD {
            .sType = VK_STRUCT_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD,
            .pNext = nullptr,
            .localDimmingEnable = static_cast<VkBool32>(local_dimming_enable)
        };
    }
};

struct SwapchainLatencyCreateInfoNV {
    bool latency_mode_enable;
    
    VkSwapchainLatencyCreateInfoNV raw() {
        return VkSwapchainLatencyCreateInfoNV {
            .sType = VK_STRUCT_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV,
            .pNext = nullptr,
            .latencyModeEnable = static_cast<VkBool32>(latency_mode_enable)
        };
    }
};

struct SwapchainPresentBarrierCreateInfoNV {
    bool present_barrier_enable;
    
    VkSwapchainPresentBarrierCreateInfoNV raw() {
        return VkSwapchainPresentBarrierCreateInfoNV {
            .sType = VK_STRUCT_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV,
            .pNext = nullptr,
            .presentBarrierEnable = static_cast<VkBool32>(present_barrier_enable)
        };
    }
};

struct SwapchainPresentFenceInfoEXT {
    u32 swapchain_count;
    VkFence* fences;
    
    VkSwapchainPresentFenceInfoEXT raw() {
        return VkSwapchainPresentFenceInfoEXT {
            .sType = VK_STRUCT_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT,
            .pNext = nullptr,
            .swapchainCount = swapchain_count,
            .pFences = fences
        };
    }
};

struct SwapchainPresentModeInfoEXT {
    u32 swapchain_count;
    VkPresentModeKHR* present_modes;
    
    VkSwapchainPresentModeInfoEXT raw() {
        return VkSwapchainPresentModeInfoEXT {
            .sType = VK_STRUCT_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT,
            .pNext = nullptr,
            .swapchainCount = swapchain_count,
            .pPresentModes = present_modes
        };
    }
};

struct SwapchainPresentModesCreateInfoEXT {
    u32 present_mode_count;
    VkPresentModeKHR* present_modes;
    
    VkSwapchainPresentModesCreateInfoEXT raw() {
        return VkSwapchainPresentModesCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT,
            .pNext = nullptr,
            .presentModeCount = present_mode_count,
            .pPresentModes = present_modes
        };
    }
};

struct SwapchainPresentScalingCreateInfoEXT {
    VkPresentScalingFlagsEXT scaling_behavior;
    VkPresentGravityFlagsEXT present_gravity_x;
    VkPresentGravityFlagsEXT present_gravity_y;
    
    VkSwapchainPresentScalingCreateInfoEXT raw() {
        return VkSwapchainPresentScalingCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT,
            .pNext = nullptr,
            .scalingBehavior = scaling_behavior,
            .presentGravityX = present_gravity_x,
            .presentGravityY = present_gravity_y
        };
    }
};

struct TextureLODGatherFormatPropertiesAMD {
    bool supports_texture_gather_lodbias_amd;
    
    VkTextureLODGatherFormatPropertiesAMD raw() {
        return VkTextureLODGatherFormatPropertiesAMD {
            .sType = VK_STRUCT_TYPE_TEXTURE_LODGATHER_FORMAT_PROPERTIES_AMD,
            .pNext = nullptr,
            .supportsTextureGatherLODBiasAMD = static_cast<VkBool32>(supports_texture_gather_lodbias_amd)
        };
    }
};

struct TileMemoryBindInfoQCOM {
    VkDeviceMemory memory;
    
    VkTileMemoryBindInfoQCOM raw() {
        return VkTileMemoryBindInfoQCOM {
            .sType = VK_STRUCT_TYPE_TILE_MEMORY_BIND_INFO_QCOM,
            .pNext = nullptr,
            .memory = memory
        };
    }
};

struct TileMemoryRequirementsQCOM {
    VkDeviceSize size;
    VkDeviceSize alignment;
    
    VkTileMemoryRequirementsQCOM raw() {
        return VkTileMemoryRequirementsQCOM {
            .sType = VK_STRUCT_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM,
            .pNext = nullptr,
            .size = size,
            .alignment = alignment
        };
    }
};

struct TileMemorySizeInfoQCOM {
    VkDeviceSize size;
    
    VkTileMemorySizeInfoQCOM raw() {
        return VkTileMemorySizeInfoQCOM {
            .sType = VK_STRUCT_TYPE_TILE_MEMORY_SIZE_INFO_QCOM,
            .pNext = nullptr,
            .size = size
        };
    }
};

struct TilePropertiesQCOM {
    Extent3D tile_size;
    Extent2D apron_size;
    Offset2D origin;
    
    VkTilePropertiesQCOM raw() {
        return VkTilePropertiesQCOM {
            .sType = VK_STRUCT_TYPE_TILE_PROPERTIES_QCOM,
            .pNext = nullptr,
            .tileSize = tile_size.raw(),
            .apronSize = apron_size.raw(),
            .origin = origin.raw()
        };
    }
};

struct TimelineSemaphoreSubmitInfo {
    u32 wait_semaphore_value_count;
    uint64_t* wait_semaphore_values;
    u32 signal_semaphore_value_count;
    uint64_t* signal_semaphore_values;
    
    VkTimelineSemaphoreSubmitInfo raw() {
        return VkTimelineSemaphoreSubmitInfo {
            .sType = VK_STRUCT_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO,
            .pNext = nullptr,
            .waitSemaphoreValueCount = wait_semaphore_value_count,
            .pWaitSemaphoreValues = wait_semaphore_values,
            .signalSemaphoreValueCount = signal_semaphore_value_count,
            .pSignalSemaphoreValues = signal_semaphore_values
        };
    }
};

struct TraceRaysIndirectCommand2KHR {
    VkDeviceAddress raygen_shader_record_address;
    VkDeviceSize raygen_shader_record_size;
    VkDeviceAddress miss_shader_binding_table_address;
    VkDeviceSize miss_shader_binding_table_size;
    VkDeviceSize miss_shader_binding_table_stride;
    VkDeviceAddress hit_shader_binding_table_address;
    VkDeviceSize hit_shader_binding_table_size;
    VkDeviceSize hit_shader_binding_table_stride;
    VkDeviceAddress callable_shader_binding_table_address;
    VkDeviceSize callable_shader_binding_table_size;
    VkDeviceSize callable_shader_binding_table_stride;
    u32 width;
    u32 height;
    u32 depth;
    
    VkTraceRaysIndirectCommand2KHR raw() {
        return VkTraceRaysIndirectCommand2KHR {
            .raygenShaderRecordAddress = raygen_shader_record_address,
            .raygenShaderRecordSize = raygen_shader_record_size,
            .missShaderBindingTableAddress = miss_shader_binding_table_address,
            .missShaderBindingTableSize = miss_shader_binding_table_size,
            .missShaderBindingTableStride = miss_shader_binding_table_stride,
            .hitShaderBindingTableAddress = hit_shader_binding_table_address,
            .hitShaderBindingTableSize = hit_shader_binding_table_size,
            .hitShaderBindingTableStride = hit_shader_binding_table_stride,
            .callableShaderBindingTableAddress = callable_shader_binding_table_address,
            .callableShaderBindingTableSize = callable_shader_binding_table_size,
            .callableShaderBindingTableStride = callable_shader_binding_table_stride,
            .width = width,
            .height = height,
            .depth = depth
        };
    }
};

struct TraceRaysIndirectCommandKHR {
    u32 width;
    u32 height;
    u32 depth;
    
    VkTraceRaysIndirectCommandKHR raw() {
        return VkTraceRaysIndirectCommandKHR {
            .width = width,
            .height = height,
            .depth = depth
        };
    }
};

struct TransformMatrixKHR {
    
    VkTransformMatrixKHR raw() {
        return VkTransformMatrixKHR {
        };
    }
};

struct ValidationCacheCreateInfoEXT {
    VkValidationCacheCreateFlagsEXT flags;
    size_t initial_data_size;
    void* initial_data;
    
    VkValidationCacheCreateInfoEXT raw() {
        return VkValidationCacheCreateInfoEXT {
            .sType = VK_STRUCT_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT,
            .pNext = nullptr,
            .flags = flags,
            .initialDataSize = initial_data_size,
            .pInitialData = initial_data
        };
    }
};

struct ValidationFeaturesEXT {
    u32 enabled_validation_feature_count;
    VkValidationFeatureEnableEXT* enabled_validation_features;
    u32 disabled_validation_feature_count;
    VkValidationFeatureDisableEXT* disabled_validation_features;
    
    VkValidationFeaturesEXT raw() {
        return VkValidationFeaturesEXT {
            .sType = VK_STRUCT_TYPE_VALIDATION_FEATURES_EXT,
            .pNext = nullptr,
            .enabledValidationFeatureCount = enabled_validation_feature_count,
            .pEnabledValidationFeatures = enabled_validation_features,
            .disabledValidationFeatureCount = disabled_validation_feature_count,
            .pDisabledValidationFeatures = disabled_validation_features
        };
    }
};

struct ValidationFlagsEXT {
    u32 disabled_validation_check_count;
    VkValidationCheckEXT* disabled_validation_checks;
    
    VkValidationFlagsEXT raw() {
        return VkValidationFlagsEXT {
            .sType = VK_STRUCT_TYPE_VALIDATION_FLAGS_EXT,
            .pNext = nullptr,
            .disabledValidationCheckCount = disabled_validation_check_count,
            .pDisabledValidationChecks = disabled_validation_checks
        };
    }
};

struct VertexInputAttributeDescription {
    u32 location;
    u32 binding;
    Format format;
    u32 offset;
    
    VkVertexInputAttributeDescription raw() {
        return VkVertexInputAttributeDescription {
            .location = location,
            .binding = binding,
            .format = static_cast<VkFormat>(format),
            .offset = offset
        };
    }
};

struct VertexInputAttributeDescription2EXT {
    u32 location;
    u32 binding;
    Format format;
    u32 offset;
    
    VkVertexInputAttributeDescription2EXT raw() {
        return VkVertexInputAttributeDescription2EXT {
            .sType = VK_STRUCT_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION2EXT,
            .pNext = nullptr,
            .location = location,
            .binding = binding,
            .format = static_cast<VkFormat>(format),
            .offset = offset
        };
    }
};

struct VertexInputBindingDescription {
    u32 binding;
    u32 stride;
    VertexInputRate input_rate;
    
    VkVertexInputBindingDescription raw() {
        return VkVertexInputBindingDescription {
            .binding = binding,
            .stride = stride,
            .inputRate = static_cast<VkVertexInputRate>(input_rate)
        };
    }
};

struct VertexInputBindingDescription2EXT {
    u32 binding;
    u32 stride;
    VertexInputRate input_rate;
    u32 divisor;
    
    VkVertexInputBindingDescription2EXT raw() {
        return VkVertexInputBindingDescription2EXT {
            .sType = VK_STRUCT_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION2EXT,
            .pNext = nullptr,
            .binding = binding,
            .stride = stride,
            .inputRate = static_cast<VkVertexInputRate>(input_rate),
            .divisor = divisor
        };
    }
};

struct VertexInputBindingDivisorDescription {
    u32 binding;
    u32 divisor;
    
    VkVertexInputBindingDivisorDescription raw() {
        return VkVertexInputBindingDivisorDescription {
            .binding = binding,
            .divisor = divisor
        };
    }
};

struct VideoBeginCodingInfoKHR {
    VkVideoBeginCodingFlagsKHR flags;
    VkVideoSessionKHR video_session;
    VkVideoSessionParametersKHR video_session_parameters;
    u32 reference_slot_count;
    VkVideoReferenceSlotInfoKHR* reference_slots;
    
    VkVideoBeginCodingInfoKHR raw() {
        return VkVideoBeginCodingInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_BEGIN_CODING_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .videoSession = video_session,
            .videoSessionParameters = video_session_parameters,
            .referenceSlotCount = reference_slot_count,
            .pReferenceSlots = reference_slots
        };
    }
};

struct VideoCapabilitiesKHR {
    VkVideoCapabilityFlagsKHR flags;
    VkDeviceSize min_bitstream_buffer_offset_alignment;
    VkDeviceSize min_bitstream_buffer_size_alignment;
    Extent2D picture_access_granularity;
    Extent2D min_coded_extent;
    Extent2D max_coded_extent;
    u32 max_dpb_slots;
    u32 max_active_reference_pictures;
    ExtensionProperties std_header_version;
    
    VkVideoCapabilitiesKHR raw() {
        return VkVideoCapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_CAPABILITIES_KHR,
            .pNext = nullptr,
            .flags = flags,
            .minBitstreamBufferOffsetAlignment = min_bitstream_buffer_offset_alignment,
            .minBitstreamBufferSizeAlignment = min_bitstream_buffer_size_alignment,
            .pictureAccessGranularity = picture_access_granularity.raw(),
            .minCodedExtent = min_coded_extent.raw(),
            .maxCodedExtent = max_coded_extent.raw(),
            .maxDpbSlots = max_dpb_slots,
            .maxActiveReferencePictures = max_active_reference_pictures,
            .stdHeaderVersion = std_header_version.raw()
        };
    }
};

struct VideoCodingControlInfoKHR {
    VkVideoCodingControlFlagsKHR flags;
    
    VkVideoCodingControlInfoKHR raw() {
        return VkVideoCodingControlInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_CODING_CONTROL_INFO_KHR,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct VideoDecodeAV1CapabilitiesKHR {
    StdVideoAV1Level max_level;
    
    VkVideoDecodeAV1CapabilitiesKHR raw() {
        return VkVideoDecodeAV1CapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_AV1CAPABILITIES_KHR,
            .pNext = nullptr,
            .maxLevel = max_level
        };
    }
};

struct VideoDecodeAV1DpbSlotInfoKHR {
    StdVideoDecodeAV1ReferenceInfo* std_reference_info;
    
    VkVideoDecodeAV1DpbSlotInfoKHR raw() {
        return VkVideoDecodeAV1DpbSlotInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_AV1DPB_SLOT_INFO_KHR,
            .pNext = nullptr,
            .pStdReferenceInfo = std_reference_info
        };
    }
};

struct VideoDecodeAV1InlineSessionParametersInfoKHR {
    StdVideoAV1SequenceHeader* std_sequence_header;
    
    VkVideoDecodeAV1InlineSessionParametersInfoKHR raw() {
        return VkVideoDecodeAV1InlineSessionParametersInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_AV1INLINE_SESSION_PARAMETERS_INFO_KHR,
            .pNext = nullptr,
            .pStdSequenceHeader = std_sequence_header
        };
    }
};

struct VideoDecodeAV1PictureInfoKHR {
    StdVideoDecodeAV1PictureInfo* std_picture_info;
    int32_t[] vk_max_video_av1_references_per_frame_khr;
    u32 frame_header_offset;
    u32 tile_count;
    uint32_t* tile_offsets;
    uint32_t* tile_sizes;
    
    VkVideoDecodeAV1PictureInfoKHR raw() {
        return VkVideoDecodeAV1PictureInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_AV1PICTURE_INFO_KHR,
            .pNext = nullptr,
            .pStdPictureInfo = std_picture_info,
            .VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR = vk_max_video_av1_references_per_frame_khr,
            .frameHeaderOffset = frame_header_offset,
            .tileCount = tile_count,
            .pTileOffsets = tile_offsets,
            .pTileSizes = tile_sizes
        };
    }
};

struct VideoDecodeAV1ProfileInfoKHR {
    StdVideoAV1Profile std_profile;
    bool film_grain_support;
    
    VkVideoDecodeAV1ProfileInfoKHR raw() {
        return VkVideoDecodeAV1ProfileInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_AV1PROFILE_INFO_KHR,
            .pNext = nullptr,
            .stdProfile = std_profile,
            .filmGrainSupport = static_cast<VkBool32>(film_grain_support)
        };
    }
};

struct VideoDecodeAV1SessionParametersCreateInfoKHR {
    StdVideoAV1SequenceHeader* std_sequence_header;
    
    VkVideoDecodeAV1SessionParametersCreateInfoKHR raw() {
        return VkVideoDecodeAV1SessionParametersCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_AV1SESSION_PARAMETERS_CREATE_INFO_KHR,
            .pNext = nullptr,
            .pStdSequenceHeader = std_sequence_header
        };
    }
};

struct VideoDecodeCapabilitiesKHR {
    VkVideoDecodeCapabilityFlagsKHR flags;
    
    VkVideoDecodeCapabilitiesKHR raw() {
        return VkVideoDecodeCapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_CAPABILITIES_KHR,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct VideoDecodeH264CapabilitiesKHR {
    StdVideoH264LevelIdc max_level_idc;
    Offset2D field_offset_granularity;
    
    VkVideoDecodeH264CapabilitiesKHR raw() {
        return VkVideoDecodeH264CapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H264CAPABILITIES_KHR,
            .pNext = nullptr,
            .maxLevelIdc = max_level_idc,
            .fieldOffsetGranularity = field_offset_granularity.raw()
        };
    }
};

struct VideoDecodeH264DpbSlotInfoKHR {
    StdVideoDecodeH264ReferenceInfo* std_reference_info;
    
    VkVideoDecodeH264DpbSlotInfoKHR raw() {
        return VkVideoDecodeH264DpbSlotInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H264DPB_SLOT_INFO_KHR,
            .pNext = nullptr,
            .pStdReferenceInfo = std_reference_info
        };
    }
};

struct VideoDecodeH264InlineSessionParametersInfoKHR {
    StdVideoH264SequenceParameterSet* std_sps;
    StdVideoH264PictureParameterSet* std_pps;
    
    VkVideoDecodeH264InlineSessionParametersInfoKHR raw() {
        return VkVideoDecodeH264InlineSessionParametersInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H264INLINE_SESSION_PARAMETERS_INFO_KHR,
            .pNext = nullptr,
            .pStdSPS = std_sps,
            .pStdPPS = std_pps
        };
    }
};

struct VideoDecodeH264PictureInfoKHR {
    StdVideoDecodeH264PictureInfo* std_picture_info;
    u32 slice_count;
    uint32_t* slice_offsets;
    
    VkVideoDecodeH264PictureInfoKHR raw() {
        return VkVideoDecodeH264PictureInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H264PICTURE_INFO_KHR,
            .pNext = nullptr,
            .pStdPictureInfo = std_picture_info,
            .sliceCount = slice_count,
            .pSliceOffsets = slice_offsets
        };
    }
};

struct VideoDecodeH264ProfileInfoKHR {
    StdVideoH264ProfileIdc std_profile_idc;
    VideoDecodeH264PictureLayoutFlagsKHR picture_layout;
    
    VkVideoDecodeH264ProfileInfoKHR raw() {
        return VkVideoDecodeH264ProfileInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H264PROFILE_INFO_KHR,
            .pNext = nullptr,
            .stdProfileIdc = std_profile_idc,
            .pictureLayout = static_cast<VkVideoDecodeH264PictureLayoutFlagBitsKHR>(picture_layout)
        };
    }
};

struct VideoDecodeH264SessionParametersAddInfoKHR {
    u32 std_spscount;
    StdVideoH264SequenceParameterSet* std_spss;
    u32 std_ppscount;
    StdVideoH264PictureParameterSet* std_ppss;
    
    VkVideoDecodeH264SessionParametersAddInfoKHR raw() {
        return VkVideoDecodeH264SessionParametersAddInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H264SESSION_PARAMETERS_ADD_INFO_KHR,
            .pNext = nullptr,
            .stdSPSCount = std_spscount,
            .pStdSPSs = std_spss,
            .stdPPSCount = std_ppscount,
            .pStdPPSs = std_ppss
        };
    }
};

struct VideoDecodeH264SessionParametersCreateInfoKHR {
    u32 max_std_spscount;
    u32 max_std_ppscount;
    VkVideoDecodeH264SessionParametersAddInfoKHR* parameters_add_info;
    
    VkVideoDecodeH264SessionParametersCreateInfoKHR raw() {
        return VkVideoDecodeH264SessionParametersCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H264SESSION_PARAMETERS_CREATE_INFO_KHR,
            .pNext = nullptr,
            .maxStdSPSCount = max_std_spscount,
            .maxStdPPSCount = max_std_ppscount,
            .pParametersAddInfo = parameters_add_info
        };
    }
};

struct VideoDecodeH265CapabilitiesKHR {
    StdVideoH265LevelIdc max_level_idc;
    
    VkVideoDecodeH265CapabilitiesKHR raw() {
        return VkVideoDecodeH265CapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H265CAPABILITIES_KHR,
            .pNext = nullptr,
            .maxLevelIdc = max_level_idc
        };
    }
};

struct VideoDecodeH265DpbSlotInfoKHR {
    StdVideoDecodeH265ReferenceInfo* std_reference_info;
    
    VkVideoDecodeH265DpbSlotInfoKHR raw() {
        return VkVideoDecodeH265DpbSlotInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H265DPB_SLOT_INFO_KHR,
            .pNext = nullptr,
            .pStdReferenceInfo = std_reference_info
        };
    }
};

struct VideoDecodeH265InlineSessionParametersInfoKHR {
    StdVideoH265VideoParameterSet* std_vps;
    StdVideoH265SequenceParameterSet* std_sps;
    StdVideoH265PictureParameterSet* std_pps;
    
    VkVideoDecodeH265InlineSessionParametersInfoKHR raw() {
        return VkVideoDecodeH265InlineSessionParametersInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H265INLINE_SESSION_PARAMETERS_INFO_KHR,
            .pNext = nullptr,
            .pStdVPS = std_vps,
            .pStdSPS = std_sps,
            .pStdPPS = std_pps
        };
    }
};

struct VideoDecodeH265PictureInfoKHR {
    StdVideoDecodeH265PictureInfo* std_picture_info;
    u32 slice_segment_count;
    uint32_t* slice_segment_offsets;
    
    VkVideoDecodeH265PictureInfoKHR raw() {
        return VkVideoDecodeH265PictureInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H265PICTURE_INFO_KHR,
            .pNext = nullptr,
            .pStdPictureInfo = std_picture_info,
            .sliceSegmentCount = slice_segment_count,
            .pSliceSegmentOffsets = slice_segment_offsets
        };
    }
};

struct VideoDecodeH265ProfileInfoKHR {
    StdVideoH265ProfileIdc std_profile_idc;
    
    VkVideoDecodeH265ProfileInfoKHR raw() {
        return VkVideoDecodeH265ProfileInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H265PROFILE_INFO_KHR,
            .pNext = nullptr,
            .stdProfileIdc = std_profile_idc
        };
    }
};

struct VideoDecodeH265SessionParametersAddInfoKHR {
    u32 std_vpscount;
    StdVideoH265VideoParameterSet* std_vpss;
    u32 std_spscount;
    StdVideoH265SequenceParameterSet* std_spss;
    u32 std_ppscount;
    StdVideoH265PictureParameterSet* std_ppss;
    
    VkVideoDecodeH265SessionParametersAddInfoKHR raw() {
        return VkVideoDecodeH265SessionParametersAddInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H265SESSION_PARAMETERS_ADD_INFO_KHR,
            .pNext = nullptr,
            .stdVPSCount = std_vpscount,
            .pStdVPSs = std_vpss,
            .stdSPSCount = std_spscount,
            .pStdSPSs = std_spss,
            .stdPPSCount = std_ppscount,
            .pStdPPSs = std_ppss
        };
    }
};

struct VideoDecodeH265SessionParametersCreateInfoKHR {
    u32 max_std_vpscount;
    u32 max_std_spscount;
    u32 max_std_ppscount;
    VkVideoDecodeH265SessionParametersAddInfoKHR* parameters_add_info;
    
    VkVideoDecodeH265SessionParametersCreateInfoKHR raw() {
        return VkVideoDecodeH265SessionParametersCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_H265SESSION_PARAMETERS_CREATE_INFO_KHR,
            .pNext = nullptr,
            .maxStdVPSCount = max_std_vpscount,
            .maxStdSPSCount = max_std_spscount,
            .maxStdPPSCount = max_std_ppscount,
            .pParametersAddInfo = parameters_add_info
        };
    }
};

struct VideoDecodeInfoKHR {
    VkVideoDecodeFlagsKHR flags;
    VkBuffer src_buffer;
    VkDeviceSize src_buffer_offset;
    VkDeviceSize src_buffer_range;
    VideoPictureResourceInfoKHR dst_picture_resource;
    VkVideoReferenceSlotInfoKHR* setup_reference_slot;
    u32 reference_slot_count;
    VkVideoReferenceSlotInfoKHR* reference_slots;
    
    VkVideoDecodeInfoKHR raw() {
        return VkVideoDecodeInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .srcBuffer = src_buffer,
            .srcBufferOffset = src_buffer_offset,
            .srcBufferRange = src_buffer_range,
            .dstPictureResource = dst_picture_resource.raw(),
            .pSetupReferenceSlot = setup_reference_slot,
            .referenceSlotCount = reference_slot_count,
            .pReferenceSlots = reference_slots
        };
    }
};

struct VideoDecodeUsageInfoKHR {
    VkVideoDecodeUsageFlagsKHR video_usage_hints;
    
    VkVideoDecodeUsageInfoKHR raw() {
        return VkVideoDecodeUsageInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_DECODE_USAGE_INFO_KHR,
            .pNext = nullptr,
            .videoUsageHints = video_usage_hints
        };
    }
};

struct VideoEncodeAV1CapabilitiesKHR {
    VkVideoEncodeAV1CapabilityFlagsKHR flags;
    StdVideoAV1Level max_level;
    Extent2D coded_picture_alignment;
    Extent2D max_tiles;
    Extent2D min_tile_size;
    Extent2D max_tile_size;
    VkVideoEncodeAV1SuperblockSizeFlagsKHR superblock_sizes;
    u32 max_single_reference_count;
    u32 single_reference_name_mask;
    u32 max_unidirectional_compound_reference_count;
    u32 max_unidirectional_compound_group1reference_count;
    u32 unidirectional_compound_reference_name_mask;
    u32 max_bidirectional_compound_reference_count;
    u32 max_bidirectional_compound_group1reference_count;
    u32 max_bidirectional_compound_group2reference_count;
    u32 bidirectional_compound_reference_name_mask;
    u32 max_temporal_layer_count;
    u32 max_spatial_layer_count;
    u32 max_operating_points;
    u32 min_qindex;
    u32 max_qindex;
    bool prefers_gop_remaining_frames;
    bool requires_gop_remaining_frames;
    VkVideoEncodeAV1StdFlagsKHR std_syntax_flags;
    
    VkVideoEncodeAV1CapabilitiesKHR raw() {
        return VkVideoEncodeAV1CapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1CAPABILITIES_KHR,
            .pNext = nullptr,
            .flags = flags,
            .maxLevel = max_level,
            .codedPictureAlignment = coded_picture_alignment.raw(),
            .maxTiles = max_tiles.raw(),
            .minTileSize = min_tile_size.raw(),
            .maxTileSize = max_tile_size.raw(),
            .superblockSizes = superblock_sizes,
            .maxSingleReferenceCount = max_single_reference_count,
            .singleReferenceNameMask = single_reference_name_mask,
            .maxUnidirectionalCompoundReferenceCount = max_unidirectional_compound_reference_count,
            .maxUnidirectionalCompoundGroup1ReferenceCount = max_unidirectional_compound_group1reference_count,
            .unidirectionalCompoundReferenceNameMask = unidirectional_compound_reference_name_mask,
            .maxBidirectionalCompoundReferenceCount = max_bidirectional_compound_reference_count,
            .maxBidirectionalCompoundGroup1ReferenceCount = max_bidirectional_compound_group1reference_count,
            .maxBidirectionalCompoundGroup2ReferenceCount = max_bidirectional_compound_group2reference_count,
            .bidirectionalCompoundReferenceNameMask = bidirectional_compound_reference_name_mask,
            .maxTemporalLayerCount = max_temporal_layer_count,
            .maxSpatialLayerCount = max_spatial_layer_count,
            .maxOperatingPoints = max_operating_points,
            .minQIndex = min_qindex,
            .maxQIndex = max_qindex,
            .prefersGopRemainingFrames = static_cast<VkBool32>(prefers_gop_remaining_frames),
            .requiresGopRemainingFrames = static_cast<VkBool32>(requires_gop_remaining_frames),
            .stdSyntaxFlags = std_syntax_flags
        };
    }
};

struct VideoEncodeAV1DpbSlotInfoKHR {
    StdVideoEncodeAV1ReferenceInfo* std_reference_info;
    
    VkVideoEncodeAV1DpbSlotInfoKHR raw() {
        return VkVideoEncodeAV1DpbSlotInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1DPB_SLOT_INFO_KHR,
            .pNext = nullptr,
            .pStdReferenceInfo = std_reference_info
        };
    }
};

struct VideoEncodeAV1FrameSizeKHR {
    u32 intra_frame_size;
    u32 predictive_frame_size;
    u32 bipredictive_frame_size;
    
    VkVideoEncodeAV1FrameSizeKHR raw() {
        return VkVideoEncodeAV1FrameSizeKHR {
            .intraFrameSize = intra_frame_size,
            .predictiveFrameSize = predictive_frame_size,
            .bipredictiveFrameSize = bipredictive_frame_size
        };
    }
};

struct VideoEncodeAV1GopRemainingFrameInfoKHR {
    bool use_gop_remaining_frames;
    u32 gop_remaining_intra;
    u32 gop_remaining_predictive;
    u32 gop_remaining_bipredictive;
    
    VkVideoEncodeAV1GopRemainingFrameInfoKHR raw() {
        return VkVideoEncodeAV1GopRemainingFrameInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1GOP_REMAINING_FRAME_INFO_KHR,
            .pNext = nullptr,
            .useGopRemainingFrames = static_cast<VkBool32>(use_gop_remaining_frames),
            .gopRemainingIntra = gop_remaining_intra,
            .gopRemainingPredictive = gop_remaining_predictive,
            .gopRemainingBipredictive = gop_remaining_bipredictive
        };
    }
};

struct VideoEncodeAV1PictureInfoKHR {
    VideoEncodeAV1PredictionModeKHR prediction_mode;
    VideoEncodeAV1RateControlGroupKHR rate_control_group;
    u32 constant_qindex;
    StdVideoEncodeAV1PictureInfo* std_picture_info;
    int32_t[] vk_max_video_av1_references_per_frame_khr;
    bool primary_reference_cdf_only;
    bool generate_obu_extension_header;
    
    VkVideoEncodeAV1PictureInfoKHR raw() {
        return VkVideoEncodeAV1PictureInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1PICTURE_INFO_KHR,
            .pNext = nullptr,
            .predictionMode = static_cast<VkVideoEncodeAV1PredictionModeKHR>(prediction_mode),
            .rateControlGroup = static_cast<VkVideoEncodeAV1RateControlGroupKHR>(rate_control_group),
            .constantQIndex = constant_qindex,
            .pStdPictureInfo = std_picture_info,
            .VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR = vk_max_video_av1_references_per_frame_khr,
            .primaryReferenceCdfOnly = static_cast<VkBool32>(primary_reference_cdf_only),
            .generateObuExtensionHeader = static_cast<VkBool32>(generate_obu_extension_header)
        };
    }
};

struct VideoEncodeAV1ProfileInfoKHR {
    StdVideoAV1Profile std_profile;
    
    VkVideoEncodeAV1ProfileInfoKHR raw() {
        return VkVideoEncodeAV1ProfileInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1PROFILE_INFO_KHR,
            .pNext = nullptr,
            .stdProfile = std_profile
        };
    }
};

struct VideoEncodeAV1QIndexKHR {
    u32 intra_qindex;
    u32 predictive_qindex;
    u32 bipredictive_qindex;
    
    VkVideoEncodeAV1QIndexKHR raw() {
        return VkVideoEncodeAV1QIndexKHR {
            .intraQIndex = intra_qindex,
            .predictiveQIndex = predictive_qindex,
            .bipredictiveQIndex = bipredictive_qindex
        };
    }
};

struct VideoEncodeAV1QualityLevelPropertiesKHR {
    VkVideoEncodeAV1RateControlFlagsKHR preferred_rate_control_flags;
    u32 preferred_gop_frame_count;
    u32 preferred_key_frame_period;
    u32 preferred_consecutive_bipredictive_frame_count;
    u32 preferred_temporal_layer_count;
    VideoEncodeAV1QIndexKHR preferred_constant_qindex;
    u32 preferred_max_single_reference_count;
    u32 preferred_single_reference_name_mask;
    u32 preferred_max_unidirectional_compound_reference_count;
    u32 preferred_max_unidirectional_compound_group1reference_count;
    u32 preferred_unidirectional_compound_reference_name_mask;
    u32 preferred_max_bidirectional_compound_reference_count;
    u32 preferred_max_bidirectional_compound_group1reference_count;
    u32 preferred_max_bidirectional_compound_group2reference_count;
    u32 preferred_bidirectional_compound_reference_name_mask;
    
    VkVideoEncodeAV1QualityLevelPropertiesKHR raw() {
        return VkVideoEncodeAV1QualityLevelPropertiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1QUALITY_LEVEL_PROPERTIES_KHR,
            .pNext = nullptr,
            .preferredRateControlFlags = preferred_rate_control_flags,
            .preferredGopFrameCount = preferred_gop_frame_count,
            .preferredKeyFramePeriod = preferred_key_frame_period,
            .preferredConsecutiveBipredictiveFrameCount = preferred_consecutive_bipredictive_frame_count,
            .preferredTemporalLayerCount = preferred_temporal_layer_count,
            .preferredConstantQIndex = preferred_constant_qindex.raw(),
            .preferredMaxSingleReferenceCount = preferred_max_single_reference_count,
            .preferredSingleReferenceNameMask = preferred_single_reference_name_mask,
            .preferredMaxUnidirectionalCompoundReferenceCount = preferred_max_unidirectional_compound_reference_count,
            .preferredMaxUnidirectionalCompoundGroup1ReferenceCount = preferred_max_unidirectional_compound_group1reference_count,
            .preferredUnidirectionalCompoundReferenceNameMask = preferred_unidirectional_compound_reference_name_mask,
            .preferredMaxBidirectionalCompoundReferenceCount = preferred_max_bidirectional_compound_reference_count,
            .preferredMaxBidirectionalCompoundGroup1ReferenceCount = preferred_max_bidirectional_compound_group1reference_count,
            .preferredMaxBidirectionalCompoundGroup2ReferenceCount = preferred_max_bidirectional_compound_group2reference_count,
            .preferredBidirectionalCompoundReferenceNameMask = preferred_bidirectional_compound_reference_name_mask
        };
    }
};

struct VideoEncodeAV1QuantizationMapCapabilitiesKHR {
    i32 min_qindex_delta;
    i32 max_qindex_delta;
    
    VkVideoEncodeAV1QuantizationMapCapabilitiesKHR raw() {
        return VkVideoEncodeAV1QuantizationMapCapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1QUANTIZATION_MAP_CAPABILITIES_KHR,
            .pNext = nullptr,
            .minQIndexDelta = min_qindex_delta,
            .maxQIndexDelta = max_qindex_delta
        };
    }
};

struct VideoEncodeAV1RateControlInfoKHR {
    VkVideoEncodeAV1RateControlFlagsKHR flags;
    u32 gop_frame_count;
    u32 key_frame_period;
    u32 consecutive_bipredictive_frame_count;
    u32 temporal_layer_count;
    
    VkVideoEncodeAV1RateControlInfoKHR raw() {
        return VkVideoEncodeAV1RateControlInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1RATE_CONTROL_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .gopFrameCount = gop_frame_count,
            .keyFramePeriod = key_frame_period,
            .consecutiveBipredictiveFrameCount = consecutive_bipredictive_frame_count,
            .temporalLayerCount = temporal_layer_count
        };
    }
};

struct VideoEncodeAV1RateControlLayerInfoKHR {
    bool use_min_qindex;
    VideoEncodeAV1QIndexKHR min_qindex;
    bool use_max_qindex;
    VideoEncodeAV1QIndexKHR max_qindex;
    bool use_max_frame_size;
    VideoEncodeAV1FrameSizeKHR max_frame_size;
    
    VkVideoEncodeAV1RateControlLayerInfoKHR raw() {
        return VkVideoEncodeAV1RateControlLayerInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1RATE_CONTROL_LAYER_INFO_KHR,
            .pNext = nullptr,
            .useMinQIndex = static_cast<VkBool32>(use_min_qindex),
            .minQIndex = min_qindex.raw(),
            .useMaxQIndex = static_cast<VkBool32>(use_max_qindex),
            .maxQIndex = max_qindex.raw(),
            .useMaxFrameSize = static_cast<VkBool32>(use_max_frame_size),
            .maxFrameSize = max_frame_size.raw()
        };
    }
};

struct VideoEncodeAV1SessionCreateInfoKHR {
    bool use_max_level;
    StdVideoAV1Level max_level;
    
    VkVideoEncodeAV1SessionCreateInfoKHR raw() {
        return VkVideoEncodeAV1SessionCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1SESSION_CREATE_INFO_KHR,
            .pNext = nullptr,
            .useMaxLevel = static_cast<VkBool32>(use_max_level),
            .maxLevel = max_level
        };
    }
};

struct VideoEncodeAV1SessionParametersCreateInfoKHR {
    StdVideoAV1SequenceHeader* std_sequence_header;
    StdVideoEncodeAV1DecoderModelInfo* std_decoder_model_info;
    u32 std_operating_point_count;
    StdVideoEncodeAV1OperatingPointInfo* std_operating_points;
    
    VkVideoEncodeAV1SessionParametersCreateInfoKHR raw() {
        return VkVideoEncodeAV1SessionParametersCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_AV1SESSION_PARAMETERS_CREATE_INFO_KHR,
            .pNext = nullptr,
            .pStdSequenceHeader = std_sequence_header,
            .pStdDecoderModelInfo = std_decoder_model_info,
            .stdOperatingPointCount = std_operating_point_count,
            .pStdOperatingPoints = std_operating_points
        };
    }
};

struct VideoEncodeCapabilitiesKHR {
    VkVideoEncodeCapabilityFlagsKHR flags;
    VkVideoEncodeRateControlModeFlagsKHR rate_control_modes;
    u32 max_rate_control_layers;
    uint64_t max_bitrate;
    u32 max_quality_levels;
    Extent2D encode_input_picture_granularity;
    VkVideoEncodeFeedbackFlagsKHR supported_encode_feedback_flags;
    
    VkVideoEncodeCapabilitiesKHR raw() {
        return VkVideoEncodeCapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR,
            .pNext = nullptr,
            .flags = flags,
            .rateControlModes = rate_control_modes,
            .maxRateControlLayers = max_rate_control_layers,
            .maxBitrate = max_bitrate,
            .maxQualityLevels = max_quality_levels,
            .encodeInputPictureGranularity = encode_input_picture_granularity.raw(),
            .supportedEncodeFeedbackFlags = supported_encode_feedback_flags
        };
    }
};

struct VideoEncodeH264CapabilitiesKHR {
    VkVideoEncodeH264CapabilityFlagsKHR flags;
    StdVideoH264LevelIdc max_level_idc;
    u32 max_slice_count;
    u32 max_ppicture_l0reference_count;
    u32 max_bpicture_l0reference_count;
    u32 max_l1reference_count;
    u32 max_temporal_layer_count;
    bool expect_dyadic_temporal_layer_pattern;
    i32 min_qp;
    i32 max_qp;
    bool prefers_gop_remaining_frames;
    bool requires_gop_remaining_frames;
    VkVideoEncodeH264StdFlagsKHR std_syntax_flags;
    
    VkVideoEncodeH264CapabilitiesKHR raw() {
        return VkVideoEncodeH264CapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264CAPABILITIES_KHR,
            .pNext = nullptr,
            .flags = flags,
            .maxLevelIdc = max_level_idc,
            .maxSliceCount = max_slice_count,
            .maxPPictureL0ReferenceCount = max_ppicture_l0reference_count,
            .maxBPictureL0ReferenceCount = max_bpicture_l0reference_count,
            .maxL1ReferenceCount = max_l1reference_count,
            .maxTemporalLayerCount = max_temporal_layer_count,
            .expectDyadicTemporalLayerPattern = static_cast<VkBool32>(expect_dyadic_temporal_layer_pattern),
            .minQp = min_qp,
            .maxQp = max_qp,
            .prefersGopRemainingFrames = static_cast<VkBool32>(prefers_gop_remaining_frames),
            .requiresGopRemainingFrames = static_cast<VkBool32>(requires_gop_remaining_frames),
            .stdSyntaxFlags = std_syntax_flags
        };
    }
};

struct VideoEncodeH264DpbSlotInfoKHR {
    StdVideoEncodeH264ReferenceInfo* std_reference_info;
    
    VkVideoEncodeH264DpbSlotInfoKHR raw() {
        return VkVideoEncodeH264DpbSlotInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264DPB_SLOT_INFO_KHR,
            .pNext = nullptr,
            .pStdReferenceInfo = std_reference_info
        };
    }
};

struct VideoEncodeH264FrameSizeKHR {
    u32 frame_isize;
    u32 frame_psize;
    u32 frame_bsize;
    
    VkVideoEncodeH264FrameSizeKHR raw() {
        return VkVideoEncodeH264FrameSizeKHR {
            .frameISize = frame_isize,
            .framePSize = frame_psize,
            .frameBSize = frame_bsize
        };
    }
};

struct VideoEncodeH264GopRemainingFrameInfoKHR {
    bool use_gop_remaining_frames;
    u32 gop_remaining_i;
    u32 gop_remaining_p;
    u32 gop_remaining_b;
    
    VkVideoEncodeH264GopRemainingFrameInfoKHR raw() {
        return VkVideoEncodeH264GopRemainingFrameInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264GOP_REMAINING_FRAME_INFO_KHR,
            .pNext = nullptr,
            .useGopRemainingFrames = static_cast<VkBool32>(use_gop_remaining_frames),
            .gopRemainingI = gop_remaining_i,
            .gopRemainingP = gop_remaining_p,
            .gopRemainingB = gop_remaining_b
        };
    }
};

struct VideoEncodeH264NaluSliceInfoKHR {
    i32 constant_qp;
    StdVideoEncodeH264SliceHeader* std_slice_header;
    
    VkVideoEncodeH264NaluSliceInfoKHR raw() {
        return VkVideoEncodeH264NaluSliceInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264NALU_SLICE_INFO_KHR,
            .pNext = nullptr,
            .constantQp = constant_qp,
            .pStdSliceHeader = std_slice_header
        };
    }
};

struct VideoEncodeH264PictureInfoKHR {
    u32 nalu_slice_entry_count;
    VkVideoEncodeH264NaluSliceInfoKHR* nalu_slice_entries;
    StdVideoEncodeH264PictureInfo* std_picture_info;
    bool generate_prefix_nalu;
    
    VkVideoEncodeH264PictureInfoKHR raw() {
        return VkVideoEncodeH264PictureInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264PICTURE_INFO_KHR,
            .pNext = nullptr,
            .naluSliceEntryCount = nalu_slice_entry_count,
            .pNaluSliceEntries = nalu_slice_entries,
            .pStdPictureInfo = std_picture_info,
            .generatePrefixNalu = static_cast<VkBool32>(generate_prefix_nalu)
        };
    }
};

struct VideoEncodeH264ProfileInfoKHR {
    StdVideoH264ProfileIdc std_profile_idc;
    
    VkVideoEncodeH264ProfileInfoKHR raw() {
        return VkVideoEncodeH264ProfileInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264PROFILE_INFO_KHR,
            .pNext = nullptr,
            .stdProfileIdc = std_profile_idc
        };
    }
};

struct VideoEncodeH264QpKHR {
    i32 qp_i;
    i32 qp_p;
    i32 qp_b;
    
    VkVideoEncodeH264QpKHR raw() {
        return VkVideoEncodeH264QpKHR {
            .qpI = qp_i,
            .qpP = qp_p,
            .qpB = qp_b
        };
    }
};

struct VideoEncodeH264QualityLevelPropertiesKHR {
    VkVideoEncodeH264RateControlFlagsKHR preferred_rate_control_flags;
    u32 preferred_gop_frame_count;
    u32 preferred_idr_period;
    u32 preferred_consecutive_bframe_count;
    u32 preferred_temporal_layer_count;
    VideoEncodeH264QpKHR preferred_constant_qp;
    u32 preferred_max_l0reference_count;
    u32 preferred_max_l1reference_count;
    bool preferred_std_entropy_coding_mode_flag;
    
    VkVideoEncodeH264QualityLevelPropertiesKHR raw() {
        return VkVideoEncodeH264QualityLevelPropertiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264QUALITY_LEVEL_PROPERTIES_KHR,
            .pNext = nullptr,
            .preferredRateControlFlags = preferred_rate_control_flags,
            .preferredGopFrameCount = preferred_gop_frame_count,
            .preferredIdrPeriod = preferred_idr_period,
            .preferredConsecutiveBFrameCount = preferred_consecutive_bframe_count,
            .preferredTemporalLayerCount = preferred_temporal_layer_count,
            .preferredConstantQp = preferred_constant_qp.raw(),
            .preferredMaxL0ReferenceCount = preferred_max_l0reference_count,
            .preferredMaxL1ReferenceCount = preferred_max_l1reference_count,
            .preferredStdEntropyCodingModeFlag = static_cast<VkBool32>(preferred_std_entropy_coding_mode_flag)
        };
    }
};

struct VideoEncodeH264QuantizationMapCapabilitiesKHR {
    i32 min_qp_delta;
    i32 max_qp_delta;
    
    VkVideoEncodeH264QuantizationMapCapabilitiesKHR raw() {
        return VkVideoEncodeH264QuantizationMapCapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264QUANTIZATION_MAP_CAPABILITIES_KHR,
            .pNext = nullptr,
            .minQpDelta = min_qp_delta,
            .maxQpDelta = max_qp_delta
        };
    }
};

struct VideoEncodeH264RateControlInfoKHR {
    VkVideoEncodeH264RateControlFlagsKHR flags;
    u32 gop_frame_count;
    u32 idr_period;
    u32 consecutive_bframe_count;
    u32 temporal_layer_count;
    
    VkVideoEncodeH264RateControlInfoKHR raw() {
        return VkVideoEncodeH264RateControlInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264RATE_CONTROL_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .gopFrameCount = gop_frame_count,
            .idrPeriod = idr_period,
            .consecutiveBFrameCount = consecutive_bframe_count,
            .temporalLayerCount = temporal_layer_count
        };
    }
};

struct VideoEncodeH264RateControlLayerInfoKHR {
    bool use_min_qp;
    VideoEncodeH264QpKHR min_qp;
    bool use_max_qp;
    VideoEncodeH264QpKHR max_qp;
    bool use_max_frame_size;
    VideoEncodeH264FrameSizeKHR max_frame_size;
    
    VkVideoEncodeH264RateControlLayerInfoKHR raw() {
        return VkVideoEncodeH264RateControlLayerInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264RATE_CONTROL_LAYER_INFO_KHR,
            .pNext = nullptr,
            .useMinQp = static_cast<VkBool32>(use_min_qp),
            .minQp = min_qp.raw(),
            .useMaxQp = static_cast<VkBool32>(use_max_qp),
            .maxQp = max_qp.raw(),
            .useMaxFrameSize = static_cast<VkBool32>(use_max_frame_size),
            .maxFrameSize = max_frame_size.raw()
        };
    }
};

struct VideoEncodeH264SessionCreateInfoKHR {
    bool use_max_level_idc;
    StdVideoH264LevelIdc max_level_idc;
    
    VkVideoEncodeH264SessionCreateInfoKHR raw() {
        return VkVideoEncodeH264SessionCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264SESSION_CREATE_INFO_KHR,
            .pNext = nullptr,
            .useMaxLevelIdc = static_cast<VkBool32>(use_max_level_idc),
            .maxLevelIdc = max_level_idc
        };
    }
};

struct VideoEncodeH264SessionParametersAddInfoKHR {
    u32 std_spscount;
    StdVideoH264SequenceParameterSet* std_spss;
    u32 std_ppscount;
    StdVideoH264PictureParameterSet* std_ppss;
    
    VkVideoEncodeH264SessionParametersAddInfoKHR raw() {
        return VkVideoEncodeH264SessionParametersAddInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264SESSION_PARAMETERS_ADD_INFO_KHR,
            .pNext = nullptr,
            .stdSPSCount = std_spscount,
            .pStdSPSs = std_spss,
            .stdPPSCount = std_ppscount,
            .pStdPPSs = std_ppss
        };
    }
};

struct VideoEncodeH264SessionParametersCreateInfoKHR {
    u32 max_std_spscount;
    u32 max_std_ppscount;
    VkVideoEncodeH264SessionParametersAddInfoKHR* parameters_add_info;
    
    VkVideoEncodeH264SessionParametersCreateInfoKHR raw() {
        return VkVideoEncodeH264SessionParametersCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264SESSION_PARAMETERS_CREATE_INFO_KHR,
            .pNext = nullptr,
            .maxStdSPSCount = max_std_spscount,
            .maxStdPPSCount = max_std_ppscount,
            .pParametersAddInfo = parameters_add_info
        };
    }
};

struct VideoEncodeH264SessionParametersFeedbackInfoKHR {
    bool has_std_spsoverrides;
    bool has_std_ppsoverrides;
    
    VkVideoEncodeH264SessionParametersFeedbackInfoKHR raw() {
        return VkVideoEncodeH264SessionParametersFeedbackInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            .pNext = nullptr,
            .hasStdSPSOverrides = static_cast<VkBool32>(has_std_spsoverrides),
            .hasStdPPSOverrides = static_cast<VkBool32>(has_std_ppsoverrides)
        };
    }
};

struct VideoEncodeH264SessionParametersGetInfoKHR {
    bool write_std_sps;
    bool write_std_pps;
    u32 std_spsid;
    u32 std_ppsid;
    
    VkVideoEncodeH264SessionParametersGetInfoKHR raw() {
        return VkVideoEncodeH264SessionParametersGetInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H264SESSION_PARAMETERS_GET_INFO_KHR,
            .pNext = nullptr,
            .writeStdSPS = static_cast<VkBool32>(write_std_sps),
            .writeStdPPS = static_cast<VkBool32>(write_std_pps),
            .stdSPSId = std_spsid,
            .stdPPSId = std_ppsid
        };
    }
};

struct VideoEncodeH265CapabilitiesKHR {
    VkVideoEncodeH265CapabilityFlagsKHR flags;
    StdVideoH265LevelIdc max_level_idc;
    u32 max_slice_segment_count;
    Extent2D max_tiles;
    VkVideoEncodeH265CtbSizeFlagsKHR ctb_sizes;
    VkVideoEncodeH265TransformBlockSizeFlagsKHR transform_block_sizes;
    u32 max_ppicture_l0reference_count;
    u32 max_bpicture_l0reference_count;
    u32 max_l1reference_count;
    u32 max_sub_layer_count;
    bool expect_dyadic_temporal_sub_layer_pattern;
    i32 min_qp;
    i32 max_qp;
    bool prefers_gop_remaining_frames;
    bool requires_gop_remaining_frames;
    VkVideoEncodeH265StdFlagsKHR std_syntax_flags;
    
    VkVideoEncodeH265CapabilitiesKHR raw() {
        return VkVideoEncodeH265CapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265CAPABILITIES_KHR,
            .pNext = nullptr,
            .flags = flags,
            .maxLevelIdc = max_level_idc,
            .maxSliceSegmentCount = max_slice_segment_count,
            .maxTiles = max_tiles.raw(),
            .ctbSizes = ctb_sizes,
            .transformBlockSizes = transform_block_sizes,
            .maxPPictureL0ReferenceCount = max_ppicture_l0reference_count,
            .maxBPictureL0ReferenceCount = max_bpicture_l0reference_count,
            .maxL1ReferenceCount = max_l1reference_count,
            .maxSubLayerCount = max_sub_layer_count,
            .expectDyadicTemporalSubLayerPattern = static_cast<VkBool32>(expect_dyadic_temporal_sub_layer_pattern),
            .minQp = min_qp,
            .maxQp = max_qp,
            .prefersGopRemainingFrames = static_cast<VkBool32>(prefers_gop_remaining_frames),
            .requiresGopRemainingFrames = static_cast<VkBool32>(requires_gop_remaining_frames),
            .stdSyntaxFlags = std_syntax_flags
        };
    }
};

struct VideoEncodeH265DpbSlotInfoKHR {
    StdVideoEncodeH265ReferenceInfo* std_reference_info;
    
    VkVideoEncodeH265DpbSlotInfoKHR raw() {
        return VkVideoEncodeH265DpbSlotInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265DPB_SLOT_INFO_KHR,
            .pNext = nullptr,
            .pStdReferenceInfo = std_reference_info
        };
    }
};

struct VideoEncodeH265FrameSizeKHR {
    u32 frame_isize;
    u32 frame_psize;
    u32 frame_bsize;
    
    VkVideoEncodeH265FrameSizeKHR raw() {
        return VkVideoEncodeH265FrameSizeKHR {
            .frameISize = frame_isize,
            .framePSize = frame_psize,
            .frameBSize = frame_bsize
        };
    }
};

struct VideoEncodeH265GopRemainingFrameInfoKHR {
    bool use_gop_remaining_frames;
    u32 gop_remaining_i;
    u32 gop_remaining_p;
    u32 gop_remaining_b;
    
    VkVideoEncodeH265GopRemainingFrameInfoKHR raw() {
        return VkVideoEncodeH265GopRemainingFrameInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265GOP_REMAINING_FRAME_INFO_KHR,
            .pNext = nullptr,
            .useGopRemainingFrames = static_cast<VkBool32>(use_gop_remaining_frames),
            .gopRemainingI = gop_remaining_i,
            .gopRemainingP = gop_remaining_p,
            .gopRemainingB = gop_remaining_b
        };
    }
};

struct VideoEncodeH265NaluSliceSegmentInfoKHR {
    i32 constant_qp;
    StdVideoEncodeH265SliceSegmentHeader* std_slice_segment_header;
    
    VkVideoEncodeH265NaluSliceSegmentInfoKHR raw() {
        return VkVideoEncodeH265NaluSliceSegmentInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265NALU_SLICE_SEGMENT_INFO_KHR,
            .pNext = nullptr,
            .constantQp = constant_qp,
            .pStdSliceSegmentHeader = std_slice_segment_header
        };
    }
};

struct VideoEncodeH265PictureInfoKHR {
    u32 nalu_slice_segment_entry_count;
    VkVideoEncodeH265NaluSliceSegmentInfoKHR* nalu_slice_segment_entries;
    StdVideoEncodeH265PictureInfo* std_picture_info;
    
    VkVideoEncodeH265PictureInfoKHR raw() {
        return VkVideoEncodeH265PictureInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265PICTURE_INFO_KHR,
            .pNext = nullptr,
            .naluSliceSegmentEntryCount = nalu_slice_segment_entry_count,
            .pNaluSliceSegmentEntries = nalu_slice_segment_entries,
            .pStdPictureInfo = std_picture_info
        };
    }
};

struct VideoEncodeH265ProfileInfoKHR {
    StdVideoH265ProfileIdc std_profile_idc;
    
    VkVideoEncodeH265ProfileInfoKHR raw() {
        return VkVideoEncodeH265ProfileInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265PROFILE_INFO_KHR,
            .pNext = nullptr,
            .stdProfileIdc = std_profile_idc
        };
    }
};

struct VideoEncodeH265QpKHR {
    i32 qp_i;
    i32 qp_p;
    i32 qp_b;
    
    VkVideoEncodeH265QpKHR raw() {
        return VkVideoEncodeH265QpKHR {
            .qpI = qp_i,
            .qpP = qp_p,
            .qpB = qp_b
        };
    }
};

struct VideoEncodeH265QualityLevelPropertiesKHR {
    VkVideoEncodeH265RateControlFlagsKHR preferred_rate_control_flags;
    u32 preferred_gop_frame_count;
    u32 preferred_idr_period;
    u32 preferred_consecutive_bframe_count;
    u32 preferred_sub_layer_count;
    VideoEncodeH265QpKHR preferred_constant_qp;
    u32 preferred_max_l0reference_count;
    u32 preferred_max_l1reference_count;
    
    VkVideoEncodeH265QualityLevelPropertiesKHR raw() {
        return VkVideoEncodeH265QualityLevelPropertiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265QUALITY_LEVEL_PROPERTIES_KHR,
            .pNext = nullptr,
            .preferredRateControlFlags = preferred_rate_control_flags,
            .preferredGopFrameCount = preferred_gop_frame_count,
            .preferredIdrPeriod = preferred_idr_period,
            .preferredConsecutiveBFrameCount = preferred_consecutive_bframe_count,
            .preferredSubLayerCount = preferred_sub_layer_count,
            .preferredConstantQp = preferred_constant_qp.raw(),
            .preferredMaxL0ReferenceCount = preferred_max_l0reference_count,
            .preferredMaxL1ReferenceCount = preferred_max_l1reference_count
        };
    }
};

struct VideoEncodeH265QuantizationMapCapabilitiesKHR {
    i32 min_qp_delta;
    i32 max_qp_delta;
    
    VkVideoEncodeH265QuantizationMapCapabilitiesKHR raw() {
        return VkVideoEncodeH265QuantizationMapCapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265QUANTIZATION_MAP_CAPABILITIES_KHR,
            .pNext = nullptr,
            .minQpDelta = min_qp_delta,
            .maxQpDelta = max_qp_delta
        };
    }
};

struct VideoEncodeH265RateControlInfoKHR {
    VkVideoEncodeH265RateControlFlagsKHR flags;
    u32 gop_frame_count;
    u32 idr_period;
    u32 consecutive_bframe_count;
    u32 sub_layer_count;
    
    VkVideoEncodeH265RateControlInfoKHR raw() {
        return VkVideoEncodeH265RateControlInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265RATE_CONTROL_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .gopFrameCount = gop_frame_count,
            .idrPeriod = idr_period,
            .consecutiveBFrameCount = consecutive_bframe_count,
            .subLayerCount = sub_layer_count
        };
    }
};

struct VideoEncodeH265RateControlLayerInfoKHR {
    bool use_min_qp;
    VideoEncodeH265QpKHR min_qp;
    bool use_max_qp;
    VideoEncodeH265QpKHR max_qp;
    bool use_max_frame_size;
    VideoEncodeH265FrameSizeKHR max_frame_size;
    
    VkVideoEncodeH265RateControlLayerInfoKHR raw() {
        return VkVideoEncodeH265RateControlLayerInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265RATE_CONTROL_LAYER_INFO_KHR,
            .pNext = nullptr,
            .useMinQp = static_cast<VkBool32>(use_min_qp),
            .minQp = min_qp.raw(),
            .useMaxQp = static_cast<VkBool32>(use_max_qp),
            .maxQp = max_qp.raw(),
            .useMaxFrameSize = static_cast<VkBool32>(use_max_frame_size),
            .maxFrameSize = max_frame_size.raw()
        };
    }
};

struct VideoEncodeH265SessionCreateInfoKHR {
    bool use_max_level_idc;
    StdVideoH265LevelIdc max_level_idc;
    
    VkVideoEncodeH265SessionCreateInfoKHR raw() {
        return VkVideoEncodeH265SessionCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265SESSION_CREATE_INFO_KHR,
            .pNext = nullptr,
            .useMaxLevelIdc = static_cast<VkBool32>(use_max_level_idc),
            .maxLevelIdc = max_level_idc
        };
    }
};

struct VideoEncodeH265SessionParametersAddInfoKHR {
    u32 std_vpscount;
    StdVideoH265VideoParameterSet* std_vpss;
    u32 std_spscount;
    StdVideoH265SequenceParameterSet* std_spss;
    u32 std_ppscount;
    StdVideoH265PictureParameterSet* std_ppss;
    
    VkVideoEncodeH265SessionParametersAddInfoKHR raw() {
        return VkVideoEncodeH265SessionParametersAddInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265SESSION_PARAMETERS_ADD_INFO_KHR,
            .pNext = nullptr,
            .stdVPSCount = std_vpscount,
            .pStdVPSs = std_vpss,
            .stdSPSCount = std_spscount,
            .pStdSPSs = std_spss,
            .stdPPSCount = std_ppscount,
            .pStdPPSs = std_ppss
        };
    }
};

struct VideoEncodeH265SessionParametersCreateInfoKHR {
    u32 max_std_vpscount;
    u32 max_std_spscount;
    u32 max_std_ppscount;
    VkVideoEncodeH265SessionParametersAddInfoKHR* parameters_add_info;
    
    VkVideoEncodeH265SessionParametersCreateInfoKHR raw() {
        return VkVideoEncodeH265SessionParametersCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265SESSION_PARAMETERS_CREATE_INFO_KHR,
            .pNext = nullptr,
            .maxStdVPSCount = max_std_vpscount,
            .maxStdSPSCount = max_std_spscount,
            .maxStdPPSCount = max_std_ppscount,
            .pParametersAddInfo = parameters_add_info
        };
    }
};

struct VideoEncodeH265SessionParametersFeedbackInfoKHR {
    bool has_std_vpsoverrides;
    bool has_std_spsoverrides;
    bool has_std_ppsoverrides;
    
    VkVideoEncodeH265SessionParametersFeedbackInfoKHR raw() {
        return VkVideoEncodeH265SessionParametersFeedbackInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            .pNext = nullptr,
            .hasStdVPSOverrides = static_cast<VkBool32>(has_std_vpsoverrides),
            .hasStdSPSOverrides = static_cast<VkBool32>(has_std_spsoverrides),
            .hasStdPPSOverrides = static_cast<VkBool32>(has_std_ppsoverrides)
        };
    }
};

struct VideoEncodeH265SessionParametersGetInfoKHR {
    bool write_std_vps;
    bool write_std_sps;
    bool write_std_pps;
    u32 std_vpsid;
    u32 std_spsid;
    u32 std_ppsid;
    
    VkVideoEncodeH265SessionParametersGetInfoKHR raw() {
        return VkVideoEncodeH265SessionParametersGetInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_H265SESSION_PARAMETERS_GET_INFO_KHR,
            .pNext = nullptr,
            .writeStdVPS = static_cast<VkBool32>(write_std_vps),
            .writeStdSPS = static_cast<VkBool32>(write_std_sps),
            .writeStdPPS = static_cast<VkBool32>(write_std_pps),
            .stdVPSId = std_vpsid,
            .stdSPSId = std_spsid,
            .stdPPSId = std_ppsid
        };
    }
};

struct VideoEncodeInfoKHR {
    VkVideoEncodeFlagsKHR flags;
    VkBuffer dst_buffer;
    VkDeviceSize dst_buffer_offset;
    VkDeviceSize dst_buffer_range;
    VideoPictureResourceInfoKHR src_picture_resource;
    VkVideoReferenceSlotInfoKHR* setup_reference_slot;
    u32 reference_slot_count;
    VkVideoReferenceSlotInfoKHR* reference_slots;
    u32 preceding_externally_encoded_bytes;
    
    VkVideoEncodeInfoKHR raw() {
        return VkVideoEncodeInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .dstBuffer = dst_buffer,
            .dstBufferOffset = dst_buffer_offset,
            .dstBufferRange = dst_buffer_range,
            .srcPictureResource = src_picture_resource.raw(),
            .pSetupReferenceSlot = setup_reference_slot,
            .referenceSlotCount = reference_slot_count,
            .pReferenceSlots = reference_slots,
            .precedingExternallyEncodedBytes = preceding_externally_encoded_bytes
        };
    }
};

struct VideoEncodeQualityLevelInfoKHR {
    u32 quality_level;
    
    VkVideoEncodeQualityLevelInfoKHR raw() {
        return VkVideoEncodeQualityLevelInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR,
            .pNext = nullptr,
            .qualityLevel = quality_level
        };
    }
};

struct VideoEncodeQualityLevelPropertiesKHR {
    VideoEncodeRateControlModeFlagsKHR preferred_rate_control_mode;
    u32 preferred_rate_control_layer_count;
    
    VkVideoEncodeQualityLevelPropertiesKHR raw() {
        return VkVideoEncodeQualityLevelPropertiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR,
            .pNext = nullptr,
            .preferredRateControlMode = static_cast<VkVideoEncodeRateControlModeFlagBitsKHR>(preferred_rate_control_mode),
            .preferredRateControlLayerCount = preferred_rate_control_layer_count
        };
    }
};

struct VideoEncodeQuantizationMapCapabilitiesKHR {
    Extent2D max_quantization_map_extent;
    
    VkVideoEncodeQuantizationMapCapabilitiesKHR raw() {
        return VkVideoEncodeQuantizationMapCapabilitiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR,
            .pNext = nullptr,
            .maxQuantizationMapExtent = max_quantization_map_extent.raw()
        };
    }
};

struct VideoEncodeQuantizationMapInfoKHR {
    VkImageView quantization_map;
    Extent2D quantization_map_extent;
    
    VkVideoEncodeQuantizationMapInfoKHR raw() {
        return VkVideoEncodeQuantizationMapInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR,
            .pNext = nullptr,
            .quantizationMap = quantization_map,
            .quantizationMapExtent = quantization_map_extent.raw()
        };
    }
};

struct VideoEncodeQuantizationMapSessionParametersCreateInfoKHR {
    Extent2D quantization_map_texel_size;
    
    VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR raw() {
        return VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR,
            .pNext = nullptr,
            .quantizationMapTexelSize = quantization_map_texel_size.raw()
        };
    }
};

struct VideoEncodeRateControlInfoKHR {
    VkVideoEncodeRateControlFlagsKHR flags;
    VideoEncodeRateControlModeFlagsKHR rate_control_mode;
    u32 layer_count;
    VkVideoEncodeRateControlLayerInfoKHR* layers;
    u32 virtual_buffer_size_in_ms;
    u32 initial_virtual_buffer_size_in_ms;
    
    VkVideoEncodeRateControlInfoKHR raw() {
        return VkVideoEncodeRateControlInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .rateControlMode = static_cast<VkVideoEncodeRateControlModeFlagBitsKHR>(rate_control_mode),
            .layerCount = layer_count,
            .pLayers = layers,
            .virtualBufferSizeInMs = virtual_buffer_size_in_ms,
            .initialVirtualBufferSizeInMs = initial_virtual_buffer_size_in_ms
        };
    }
};

struct VideoEncodeRateControlLayerInfoKHR {
    uint64_t average_bitrate;
    uint64_t max_bitrate;
    u32 frame_rate_numerator;
    u32 frame_rate_denominator;
    
    VkVideoEncodeRateControlLayerInfoKHR raw() {
        return VkVideoEncodeRateControlLayerInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR,
            .pNext = nullptr,
            .averageBitrate = average_bitrate,
            .maxBitrate = max_bitrate,
            .frameRateNumerator = frame_rate_numerator,
            .frameRateDenominator = frame_rate_denominator
        };
    }
};

struct VideoEncodeSessionParametersFeedbackInfoKHR {
    bool has_overrides;
    
    VkVideoEncodeSessionParametersFeedbackInfoKHR raw() {
        return VkVideoEncodeSessionParametersFeedbackInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR,
            .pNext = nullptr,
            .hasOverrides = static_cast<VkBool32>(has_overrides)
        };
    }
};

struct VideoEncodeSessionParametersGetInfoKHR {
    VkVideoSessionParametersKHR video_session_parameters;
    
    VkVideoEncodeSessionParametersGetInfoKHR raw() {
        return VkVideoEncodeSessionParametersGetInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR,
            .pNext = nullptr,
            .videoSessionParameters = video_session_parameters
        };
    }
};

struct VideoEncodeUsageInfoKHR {
    VkVideoEncodeUsageFlagsKHR video_usage_hints;
    VkVideoEncodeContentFlagsKHR video_content_hints;
    VideoEncodeTuningModeKHR tuning_mode;
    
    VkVideoEncodeUsageInfoKHR raw() {
        return VkVideoEncodeUsageInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR,
            .pNext = nullptr,
            .videoUsageHints = video_usage_hints,
            .videoContentHints = video_content_hints,
            .tuningMode = static_cast<VkVideoEncodeTuningModeKHR>(tuning_mode)
        };
    }
};

struct VideoEndCodingInfoKHR {
    VkVideoEndCodingFlagsKHR flags;
    
    VkVideoEndCodingInfoKHR raw() {
        return VkVideoEndCodingInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_END_CODING_INFO_KHR,
            .pNext = nullptr,
            .flags = flags
        };
    }
};

struct VideoFormatAV1QuantizationMapPropertiesKHR {
    VkVideoEncodeAV1SuperblockSizeFlagsKHR compatible_superblock_sizes;
    
    VkVideoFormatAV1QuantizationMapPropertiesKHR raw() {
        return VkVideoFormatAV1QuantizationMapPropertiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_FORMAT_AV1QUANTIZATION_MAP_PROPERTIES_KHR,
            .pNext = nullptr,
            .compatibleSuperblockSizes = compatible_superblock_sizes
        };
    }
};

struct VideoFormatH265QuantizationMapPropertiesKHR {
    VkVideoEncodeH265CtbSizeFlagsKHR compatible_ctb_sizes;
    
    VkVideoFormatH265QuantizationMapPropertiesKHR raw() {
        return VkVideoFormatH265QuantizationMapPropertiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_FORMAT_H265QUANTIZATION_MAP_PROPERTIES_KHR,
            .pNext = nullptr,
            .compatibleCtbSizes = compatible_ctb_sizes
        };
    }
};

struct VideoFormatPropertiesKHR {
    Format format;
    ComponentMapping component_mapping;
    VkImageCreateFlags image_create_flags;
    ImageType image_type;
    ImageTiling image_tiling;
    VkImageUsageFlags image_usage_flags;
    
    VkVideoFormatPropertiesKHR raw() {
        return VkVideoFormatPropertiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_FORMAT_PROPERTIES_KHR,
            .pNext = nullptr,
            .format = static_cast<VkFormat>(format),
            .componentMapping = component_mapping.raw(),
            .imageCreateFlags = image_create_flags,
            .imageType = static_cast<VkImageType>(image_type),
            .imageTiling = static_cast<VkImageTiling>(image_tiling),
            .imageUsageFlags = image_usage_flags
        };
    }
};

struct VideoFormatQuantizationMapPropertiesKHR {
    Extent2D quantization_map_texel_size;
    
    VkVideoFormatQuantizationMapPropertiesKHR raw() {
        return VkVideoFormatQuantizationMapPropertiesKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR,
            .pNext = nullptr,
            .quantizationMapTexelSize = quantization_map_texel_size.raw()
        };
    }
};

struct VideoInlineQueryInfoKHR {
    VkQueryPool query_pool;
    u32 first_query;
    u32 query_count;
    
    VkVideoInlineQueryInfoKHR raw() {
        return VkVideoInlineQueryInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_INLINE_QUERY_INFO_KHR,
            .pNext = nullptr,
            .queryPool = query_pool,
            .firstQuery = first_query,
            .queryCount = query_count
        };
    }
};

struct VideoPictureResourceInfoKHR {
    Offset2D coded_offset;
    Extent2D coded_extent;
    u32 base_array_layer;
    VkImageView image_view_binding;
    
    VkVideoPictureResourceInfoKHR raw() {
        return VkVideoPictureResourceInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR,
            .pNext = nullptr,
            .codedOffset = coded_offset.raw(),
            .codedExtent = coded_extent.raw(),
            .baseArrayLayer = base_array_layer,
            .imageViewBinding = image_view_binding
        };
    }
};

struct VideoProfileInfoKHR {
    VideoCodecOperationFlagsKHR video_codec_operation;
    VkVideoChromaSubsamplingFlagsKHR chroma_subsampling;
    VkVideoComponentBitDepthFlagsKHR luma_bit_depth;
    VkVideoComponentBitDepthFlagsKHR chroma_bit_depth;
    
    VkVideoProfileInfoKHR raw() {
        return VkVideoProfileInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_PROFILE_INFO_KHR,
            .pNext = nullptr,
            .videoCodecOperation = static_cast<VkVideoCodecOperationFlagBitsKHR>(video_codec_operation),
            .chromaSubsampling = chroma_subsampling,
            .lumaBitDepth = luma_bit_depth,
            .chromaBitDepth = chroma_bit_depth
        };
    }
};

struct VideoProfileListInfoKHR {
    u32 profile_count;
    VkVideoProfileInfoKHR* profiles;
    
    VkVideoProfileListInfoKHR raw() {
        return VkVideoProfileListInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_PROFILE_LIST_INFO_KHR,
            .pNext = nullptr,
            .profileCount = profile_count,
            .pProfiles = profiles
        };
    }
};

struct VideoReferenceSlotInfoKHR {
    i32 slot_index;
    VkVideoPictureResourceInfoKHR* picture_resource;
    
    VkVideoReferenceSlotInfoKHR raw() {
        return VkVideoReferenceSlotInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR,
            .pNext = nullptr,
            .slotIndex = slot_index,
            .pPictureResource = picture_resource
        };
    }
};

struct VideoSessionCreateInfoKHR {
    u32 queue_family_index;
    VkVideoSessionCreateFlagsKHR flags;
    VkVideoProfileInfoKHR* video_profile;
    Format picture_format;
    Extent2D max_coded_extent;
    Format reference_picture_format;
    u32 max_dpb_slots;
    u32 max_active_reference_pictures;
    VkExtensionProperties* std_header_version;
    
    VkVideoSessionCreateInfoKHR raw() {
        return VkVideoSessionCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_SESSION_CREATE_INFO_KHR,
            .pNext = nullptr,
            .queueFamilyIndex = queue_family_index,
            .flags = flags,
            .pVideoProfile = video_profile,
            .pictureFormat = static_cast<VkFormat>(picture_format),
            .maxCodedExtent = max_coded_extent.raw(),
            .referencePictureFormat = static_cast<VkFormat>(reference_picture_format),
            .maxDpbSlots = max_dpb_slots,
            .maxActiveReferencePictures = max_active_reference_pictures,
            .pStdHeaderVersion = std_header_version
        };
    }
};

struct VideoSessionMemoryRequirementsKHR {
    u32 memory_bind_index;
    MemoryRequirements memory_requirements;
    
    VkVideoSessionMemoryRequirementsKHR raw() {
        return VkVideoSessionMemoryRequirementsKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR,
            .pNext = nullptr,
            .memoryBindIndex = memory_bind_index,
            .memoryRequirements = memory_requirements.raw()
        };
    }
};

struct VideoSessionParametersCreateInfoKHR {
    VkVideoSessionParametersCreateFlagsKHR flags;
    VkVideoSessionParametersKHR video_session_parameters_template;
    VkVideoSessionKHR video_session;
    
    VkVideoSessionParametersCreateInfoKHR raw() {
        return VkVideoSessionParametersCreateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR,
            .pNext = nullptr,
            .flags = flags,
            .videoSessionParametersTemplate = video_session_parameters_template,
            .videoSession = video_session
        };
    }
};

struct VideoSessionParametersUpdateInfoKHR {
    u32 update_sequence_count;
    
    VkVideoSessionParametersUpdateInfoKHR raw() {
        return VkVideoSessionParametersUpdateInfoKHR {
            .sType = VK_STRUCT_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR,
            .pNext = nullptr,
            .updateSequenceCount = update_sequence_count
        };
    }
};

struct Viewport {
    f32 x;
    f32 y;
    f32 width;
    f32 height;
    f32 min_depth;
    f32 max_depth;
    
    VkViewport raw() {
        return VkViewport {
            .x = x,
            .y = y,
            .width = width,
            .height = height,
            .minDepth = min_depth,
            .maxDepth = max_depth
        };
    }
};

struct ViewportSwizzleNV {
    ViewportCoordinateSwizzleNV x;
    ViewportCoordinateSwizzleNV y;
    ViewportCoordinateSwizzleNV z;
    ViewportCoordinateSwizzleNV w;
    
    VkViewportSwizzleNV raw() {
        return VkViewportSwizzleNV {
            .x = static_cast<VkViewportCoordinateSwizzleNV>(x),
            .y = static_cast<VkViewportCoordinateSwizzleNV>(y),
            .z = static_cast<VkViewportCoordinateSwizzleNV>(z),
            .w = static_cast<VkViewportCoordinateSwizzleNV>(w)
        };
    }
};

struct ViewportWScalingNV {
    f32 xcoeff;
    f32 ycoeff;
    
    VkViewportWScalingNV raw() {
        return VkViewportWScalingNV {
            .xcoeff = xcoeff,
            .ycoeff = ycoeff
        };
    }
};

struct WriteDescriptorSet {
    VkDescriptorSet dst_set;
    u32 dst_binding;
    u32 dst_array_element;
    u32 descriptor_count;
    DescriptorType descriptor_type;
    VkDescriptorImageInfo* image_info;
    VkDescriptorBufferInfo* buffer_info;
    VkBufferView* texel_buffer_view;
    
    VkWriteDescriptorSet raw() {
        return VkWriteDescriptorSet {
            .sType = VK_STRUCT_TYPE_WRITE_DESCRIPTOR_SET,
            .pNext = nullptr,
            .dstSet = dst_set,
            .dstBinding = dst_binding,
            .dstArrayElement = dst_array_element,
            .descriptorCount = descriptor_count,
            .descriptorType = static_cast<VkDescriptorType>(descriptor_type),
            .pImageInfo = image_info,
            .pBufferInfo = buffer_info,
            .pTexelBufferView = texel_buffer_view
        };
    }
};

struct WriteDescriptorSetAccelerationStructureKHR {
    u32 acceleration_structure_count;
    VkAccelerationStructureKHR* acceleration_structures;
    
    VkWriteDescriptorSetAccelerationStructureKHR raw() {
        return VkWriteDescriptorSetAccelerationStructureKHR {
            .sType = VK_STRUCT_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,
            .pNext = nullptr,
            .accelerationStructureCount = acceleration_structure_count,
            .pAccelerationStructures = acceleration_structures
        };
    }
};

struct WriteDescriptorSetAccelerationStructureNV {
    u32 acceleration_structure_count;
    VkAccelerationStructureNV* acceleration_structures;
    
    VkWriteDescriptorSetAccelerationStructureNV raw() {
        return VkWriteDescriptorSetAccelerationStructureNV {
            .sType = VK_STRUCT_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV,
            .pNext = nullptr,
            .accelerationStructureCount = acceleration_structure_count,
            .pAccelerationStructures = acceleration_structures
        };
    }
};

struct WriteDescriptorSetInlineUniformBlock {
    u32 data_size;
    void* data;
    
    VkWriteDescriptorSetInlineUniformBlock raw() {
        return VkWriteDescriptorSetInlineUniformBlock {
            .sType = VK_STRUCT_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK,
            .pNext = nullptr,
            .dataSize = data_size,
            .pData = data
        };
    }
};

struct WriteDescriptorSetPartitionedAccelerationStructureNV {
    u32 acceleration_structure_count;
    VkDeviceAddress* acceleration_structures;
    
    VkWriteDescriptorSetPartitionedAccelerationStructureNV raw() {
        return VkWriteDescriptorSetPartitionedAccelerationStructureNV {
            .sType = VK_STRUCT_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV,
            .pNext = nullptr,
            .accelerationStructureCount = acceleration_structure_count,
            .pAccelerationStructures = acceleration_structures
        };
    }
};

struct WriteIndirectExecutionSetPipelineEXT {
    u32 index;
    VkPipeline pipeline;
    
    VkWriteIndirectExecutionSetPipelineEXT raw() {
        return VkWriteIndirectExecutionSetPipelineEXT {
            .sType = VK_STRUCT_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT,
            .pNext = nullptr,
            .index = index,
            .pipeline = pipeline
        };
    }
};

struct WriteIndirectExecutionSetShaderEXT {
    u32 index;
    VkShaderEXT shader;
    
    VkWriteIndirectExecutionSetShaderEXT raw() {
        return VkWriteIndirectExecutionSetShaderEXT {
            .sType = VK_STRUCT_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT,
            .pNext = nullptr,
            .index = index,
            .shader = shader
        };
    }
};

struct XYColorEXT {
    f32 x;
    f32 y;
    
    VkXYColorEXT raw() {
        return VkXYColorEXT {
            .x = x,
            .y = y
        };
    }
};

